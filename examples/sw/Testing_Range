using Catlab
using CombinatorialSpaces
using CombinatorialSpaces.ExteriorCalculus
using Decapodes
using MultiScaleArrays
using OrdinaryDiffEq
using MLStyle
using Distributions
using LinearAlgebra
using GeometryBasics: Point3

using Catlab.CategoricalAlgebra

Point3D = Point3{Float64}

flatten(vfield::Function, mesh) =  ♭(mesh, DualVectorField(vfield.(mesh[triangle_center(mesh),:dual_point])))

function generate(sd, my_symbol; hodge=GeometricHodge())
    op = @match my_symbol begin
      :k => x->2000x
      :plus => (+)
      :.* => (x,y) -> x .* y
      :(-) => x-> -x
      _ => default_dec_generate(sd, my_symbol, hodge)
    end
  
    return (args...) ->  op(args...)
  end

#= function generate(sd, my_symbol; hodge=GeometricHodge())
    i0 = (v,x) -> ⋆(1, sd, hodge=hodge)*wedge_product(Tuple{0,1}, sd, v, inv_hodge_star(0,sd, hodge=DiagonalHodge())*x)
    op = @match my_symbol begin
      :k => x->2000x
      :⋆₀ => x->⋆(0,sd,hodge=hodge)*x
      :⋆₁ => x->⋆(1, sd, hodge=hodge)*x
      #= :⋆₁ => begin 
            tmpstar1 = ⋆(1, sd, hodge=hodge)
            x->tmpstar1*x
        end =#
      :⋆₀⁻¹ => x->inv_hodge_star(0,sd, x; hodge=hodge)
      :⋆₁⁻¹ => x->inv_hodge_star(1,sd,hodge=hodge)*x
      :d₀ => x->d(0,sd)*x
      :dual_d₀ => x->dual_derivative(0,sd)*x
      :dual_d₁ => x->dual_derivative(1,sd)*x
      :∧₀₁ => (x,y)-> wedge_product(Tuple{0,1}, sd, x, y)
      :plus => (+)
      :(-) => x-> -x
      # :L₀ => (v,x)->dual_derivative(1, sd)*(i0(v, x))
      :L₀ => (v,x)->begin
        # dual_derivative(1, sd)*⋆(1, sd)*wedge_product(Tuple{1,0}, sd, v, x)
        ⋆(1, sd; hodge=hodge)*wedge_product(Tuple{1,0}, sd, v, x)
      end
      :i₀ => i0 
      :debug => (args...)->begin println(args[1], length.(args[2:end])) end
    end
    # return (args...) -> begin println("applying $my_symbol"); println("arg length $(length.(args))"); op(args...);end
    return (args...) ->  op(args...)
end =#
  
begin
    RADIUS = 6371+90
    #primal_earth = loadmesh(Icosphere(4, RADIUS))
    primal_earth = EmbeddedDeltaSet2D("Icosphere6.obj")
    nploc = argmax(x -> x[3], primal_earth[:point])
    primal_earth[:edge_orientation] .= false
    orient!(primal_earth)
    earth = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3D}(primal_earth)
    subdivide_duals!(earth, Circumcenter())
end

begin
  Brusselator = SummationDecapode(parse_decapode(
quote
  # Values living on vertices.
  (U, V)::Form0{X} # State variables.
  (U2V, One)::Form0{X} # Named intermediate variables.
  (U̇, V̇)::Form0{X} # Tangent variables.
  # Scalars.
  (fourfour, threefour, α)::Constant{X}
  F::Parameter{X}
  # A named intermediate variable.
  U2V == (U .* U) .* V
  # Specify how to compute the tangent variables.
  U̇ == One + U2V - (fourfour * U) + (α * Δ(U)) + F
  V̇ == (threefour * U) - U2V + (α * Δ(U))
  # Associate tangent variables with a state variable.
  ∂ₜ(U) == U̇
  ∂ₜ(V) == V̇
end))
# Visualize. You must have graphviz installed.
#to_graphviz(Brusselator)

# We resolve types of intermediate variables using sets of rules.
bespoke_op1_inf_rules = [
  (src_type = :Form0, tgt_type = :infer, replacement_type = :Form0, op = :Δ)]

bespoke_op2_inf_rules = [
  (proj1_type = :Form0, proj2_type = :Form0, res_type = :infer, replacement_type = :Form0, op = :.*),
  (proj1_type = :Form0, proj2_type = :Parameter, res_type = :infer, replacement_type = :Form0, op = :*),
  (proj1_type = :Parameter, proj2_type = :Form0, res_type = :infer, replacement_type = :Form0, op = :*)]

infer_types!(Brusselator,
    vcat(bespoke_op1_inf_rules, op1_inf_rules_2D),
    vcat(bespoke_op2_inf_rules, op2_inf_rules_2D))
# Visualize. Note that variables now all have types.
#to_graphviz(Brusselator)

# Resolve overloads. i.e. ~dispatch
resolve_overloads!(Brusselator)
end

#function man_simulate(mesh, operators)
#    begin
#        d₀ = generate(mesh, :d₀)
#        (⋆₁) = generate(mesh, :⋆₁)
#        dual_d₁ = generate(mesh, :dual_d₁)
#        (⋆₀⁻¹) = generate(mesh, :⋆₀⁻¹)
#        L₀ = operators(mesh, :L₀)
#        k = generate(mesh, :k)
#        (-) = generate(mesh, :-)
#        plus = operators(mesh, :plus)
#        
#        # TODO: Could place matrix allocation code in here instead of in generate
#        # Would allow for composite functions to use previously found matrices
#
#        #= tmpstar1 = ⋆(1, earth, hodge=GeometricHodge())
#        tmpinvstar1 = inv_hodge_star(0,earth; hodge=GeometricHodge())
#        tmpd0 = d(0,earth)
#        tmpdd1 = dual_derivative(1,earth)
#
#        ⋆₁ = x -> tmpstar1 * x
#        ⋆₀⁻¹ = x -> tmpinvstar1 * x
#        d₀ = x -> tmpd0 * x
#        dual_d₁ = x -> tmpdd1 * x
#        L₀ = (v, x) -> tmpstar1*wedge_product(Tuple{1,0}, earth, v, x) =#
#
#        tmpstar1 = ⋆(1, mesh, hodge=GeometricHodge())
#        val_pack = p_wedge_product(1, mesh)
#        L₀ = (v, x) -> tmpstar1 * c_wedge_product(1, x, v, val_pack)
#
#        end
#    return begin
#        f(du, u, p, t) = begin
#            begin
#                C = (findnode(u, :C)).values
#                V = (findnode(u, :V)).values
#            end
#            var"•_1_1" = d₀(C)
#            var"•_1_2" = k(var"•_1_1")
#            ϕ₁ = ⋆₁(var"•_1_2")
#            var"•1" = L₀(V, C)
#            ϕ₂ = -var"•1"
#            ϕ = plus(ϕ₁, ϕ₂)
#            var"•_3_1" = dual_d₁(ϕ)
#            Ċ = ⋆₀⁻¹(var"•_3_1")
#            du .= 0.0
#            begin
#                (findnode(du, :C)).values .= Ċ
#            end
#        end
#    end
#end

# TODO: Code actually just uses this simulate function, not the above
#fₘ = eval(man_simulate(earth, generate))
 sim = eval(gensim(Brusselator))
 fₘ = sim(earth, generate)

begin
    #c_dist = MvNormal(nploc[[1,2]], 100[1, 1])
    #c = [pdf(c_dist, [p[1], p[2]]./√RADIUS) for p in earth[:point]]

    #vmag = 500
    #velocity(p) = TangentBasis(CartesianPoint(p))((vmag/4, vmag/4))
    #v = flatten(velocity, earth)

    sd = earth
    U = map(sd[:point]) do (_,y,_)
      abs(y)
    end
    
    V = map(sd[:point]) do (x,_,_)
      abs(x)
    end
    
    # TODO: Try making this sparse.
    F₁ = map(sd[:point]) do (_,_,z)
      z ≥ 0.8 ? 5.0 : 0.0
    end

    F₂ = zeros(nv(sd))

    One = ones(nv(sd))

    constants_and_parameters = (
  fourfour = 4.4,
  threefour = 3.4,
  α = 0.001,
  F = t -> t ≥ 1.1 ? F₁ : F₂
  )

    u₀ = construct(PhysicsState, [VectorForm(U), VectorForm(V), VectorForm(One)],Float64[], [:U, :V, :One])
    tₑ = 100
    prob = ODEProblem(fₘ,u₀,(0, tₑ), constants_and_parameters)
    soln = solve(prob, Tsit5())
end

#function p_wedge_product(k, mesh)
#
#    # Gets a list of all of the 0 -> vertices, 1 -> edges, 2 -> triangles on mesh
#    simples = simplices(k, mesh)
#
#    #These are a memory killers!!
#
#    # For 1 -> edges, grabs the two dual edges that form the primal edge 
#    # For 2 -> triangles, grabs all of the edges that radiate from the triangle center 
#    subsimples = map(x -> subsimplices(k, mesh, x), simples)
#
#    # For 1 -> edges, gets the primal vertices of the dual edges 
#    primal_vertices = map(x -> primal_vertex(k, mesh, x), subsimples)
#
#    # Finding coeffs in wedge product is brutal on memory, around 345976 allocations for one map
#    #vols = map(x -> volume(k,mesh,x), simples)
#    vols = volume(k,mesh,simples)
#    dual_vols = map(y -> dual_volume(k,mesh,y), subsimples)
#    coeffs = dual_vols ./ vols
#    return (primal_vertices, coeffs)
#end
#
#function c_wedge_product(k, f, α, val_pack)
#    primal_vertices, coeffs = val_pack
#    f_terms = map(x -> f[x], primal_vertices)
#
#    lhs = dot.(coeffs, f_terms)
#    return (lhs .*  α) ./ factorial(k)
#end

fig, ax, ob = GLMakie.mesh(primal_earth, color = findnode(soln(0), :U))
for t in range(0.0, tₑ; length=150)
  sleep(0.05)
  ob.color = findnode(soln(t), :U)
end