<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calibration · Decapodes.jl</title><meta name="title" content="Calibration · Decapodes.jl"/><meta property="og:title" content="Calibration · Decapodes.jl"/><meta property="twitter:title" content="Calibration · Decapodes.jl"/><meta name="description" content="Documentation for Decapodes.jl."/><meta property="og:description" content="Documentation for Decapodes.jl."/><meta property="twitter:description" content="Documentation for Decapodes.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><script src="../../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Decapodes.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Decapodes.jl</a></li><li><a class="tocitem" href="../../overview/overview/">Overview</a></li><li><a class="tocitem" href="../../ice_dynamics/ice_dynamics/">Glacial Flow</a></li><li><span class="tocitem">Concepts</span><ul><li><a class="tocitem" href="../../concepts/equations/">Equations</a></li><li><a class="tocitem" href="../../concepts/composition/">Composition</a></li><li><a class="tocitem" href="../../concepts/meshes/">Meshes</a></li><li><a class="tocitem" href="../../concepts/generate/">Custom Operators</a></li></ul></li><li><span class="tocitem">Zoo</span><ul><li><a class="tocitem" href="../../navier_stokes/ns/">Vortices</a></li><li><a class="tocitem" href="../../harmonics/harmonics/">Harmonics</a></li><li><a class="tocitem" href="../../ch/cahn-hilliard/">Cahn-Hilliard</a></li><li><a class="tocitem" href="../../brussel/brussel/">Brusselator</a></li><li><a class="tocitem" href="../../klausmeier/klausmeier/">Klausmeier</a></li><li><a class="tocitem" href="../../pconv/porous_convection/">Porous Convection</a></li><li><a class="tocitem" href="../../cism/cism/">CISM v2.1</a></li><li><a class="tocitem" href="../../grigoriev/grigoriev/">Grigoriev Ice Cap</a></li><li><a class="tocitem" href="../../bsh/budyko_sellers_halfar/">Budyko-Sellers-Halfar</a></li><li><a class="tocitem" href="../../ebm_melt/ebm_melt/">Halfar-EBM-Water</a></li><li><a class="tocitem" href="../../halmo/halmo/">Halfar-NS</a></li><li><a class="tocitem" href="../../nhs/nhs_lite/">NHS</a></li><li><a class="tocitem" href="../../poiseuille/poiseuille/">Pipe Flow</a></li><li><a class="tocitem" href="../../fokker_planck/fokker_planck/">Fokker-Planck</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/chemistry/gray_scott/">Gray-Scott</a></li><li><a class="tocitem" href="../../examples/oncology/tumor_proliferation_invasion/">Oncology</a></li><li><a class="tocitem" href="../../examples/mhd/">MHD</a></li></ul></li><li class="is-active"><a class="tocitem" href>Calibration</a><ul class="internal"><li><a class="tocitem" href="#Sparsity-Detection-and-Jacobian-Coloring"><span>Sparsity Detection and Jacobian Coloring</span></a></li><li><a class="tocitem" href="#Calibration"><span>Calibration</span></a></li></ul></li><li><a class="tocitem" href="../../bc/bc_debug/">Misc Features</a></li><li><a class="tocitem" href="../../faq/faq/">FAQ</a></li><li><a class="tocitem" href="../../ascii/">ASCII Operators</a></li><li><a class="tocitem" href="../../canon/">Canonical Models</a></li><li><a class="tocitem" href="../../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Calibration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Calibration</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Decapodes.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AlgebraicJulia/Decapodes.jl/blob/main/docs/src/calibrate/calibration.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parameter-Calibration-for-Halfar&#39;s-Glacial-Flow-Model"><a class="docs-heading-anchor" href="#Parameter-Calibration-for-Halfar&#39;s-Glacial-Flow-Model">Parameter Calibration for Halfar&#39;s Glacial Flow Model</a><a id="Parameter-Calibration-for-Halfar&#39;s-Glacial-Flow-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Calibration-for-Halfar&#39;s-Glacial-Flow-Model" title="Permalink"></a></h1><p>Let&#39;s see how to calibrate a glacial flow Decapode model&#39;s parameters to fit some data. We want to solve the inverse problem, i.e. given a model and some data, find a set of parameters that causes the output of the model to match the given data as closely as possible. </p><p>We&#39;ll be using a 2D version of the Halfar glacial flow model, for more explanation see the <a href="../../ice_dynamics/ice_dynamics/">glacial flow docs page</a>.</p><p>In order to set up the inverse problem, we first need our model and some reference data. So, we&#39;ll set up the 2D glacial flow model and get some data from it. In this case we&#39;ll be fitting our model parameters to data from the model itself. In general the data we want to fit to will not be from the model, but for demonstration purposes this works well. </p><pre><code class="language-julia hljs">using Catlab
using CombinatorialSpaces
using DiagrammaticEquations
using Decapodes
using CairoMakie
using ComponentArrays
using GeometryBasics: Point2, Point3
using JLD2
using LinearAlgebra
using MLStyle
using OrdinaryDiffEq
using SparseArrays
using Statistics
using BenchmarkTools
using SparseConnectivityTracer
using SparseMatrixColorings
using ADTypes
using NaNMath
using Optimization
using SciMLSensitivity
using Optimization
using OptimizationOptimJL
using Optim
Point2D = Point2{Float64}
Point3D = Point3{Float64}

halfar_eq2 = @decapode begin
    h::Form0
    Γ::Form1
    n::Constant

    ḣ == ∂ₜ(h)
    ḣ == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯(d(h)))^(n - 1)) * avg₀₁(h^(n + 2)))
end

glens_law = @decapode begin
    #Γ::Form0
    Γ::Form1
    (A, ρ, g, n)::Constant

    Γ == (2 / (n + 2)) * A * (ρ * g)^n
end

ice_dynamics_composition_diagram = @relation () begin
    dynamics(Γ, n)
    stress(Γ, n)
end

ice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,
    [Open(halfar_eq2, [:Γ, :n]),
        Open(glens_law, [:Γ, :n])])

ice_dynamics = apex(ice_dynamics_cospan)

ice_dynamics2D = expand_operators(ice_dynamics)
infer_types!(ice_dynamics2D)
resolve_overloads!(ice_dynamics2D)

function generate(sd, my_symbol; hodge=GeometricHodge())
    op = @match my_symbol begin
        :♯ =&gt; begin
            sharp_mat = ♯_mat(sd, AltPPSharp())
            x -&gt; sharp_mat * x
        end
        :mag =&gt; x -&gt; norm.(x)
        x =&gt; error(&quot;Unmatched operator $my_symbol&quot;)
    end
    return (args...) -&gt; op(args...)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">generate (generic function with 1 method)</code></pre><p>Now we define the mesh and the dual mesh that the glacial flow equations will be solved on, along with initial conditions on the mesh and parameters for the model.</p><pre><code class="language-julia hljs">s2D = triangulated_grid(10_000, 10_000, 500, 500, Point3D)
sd2D = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3D}(s2D)
subdivide_duals!(sd2D, Barycenter())

h₀2D = map(point(s2D)) do (x, y)
    (7072 - ((x - 5000)^2 + (y - 5000)^2)^(1 / 2)) / 9e3 + 10
end

u02D = ComponentArray(dynamics_h=h₀2D)

n = 3
ρ = 910
g = 9.8
A = 1e-3

constants_and_parameters = ComponentArray(
    n=n,
    stress_ρ=ρ,
    stress_g=g,
    stress_A=A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float64}(n = 3.0, stress_ρ = 910.0, stress_g = 9.8, stress_A = 0.001)</code></pre><p>Now we have everything we need to generate the function that will be used in the ODE solver. Thinking ahead however, the optimization routines we want to use might try non-physical parameters, e.g. maybe a set of parameters the optimizer tries will cause the ice height solution to become complex. In this case, certain parameter sets might cause an error to occur, e.g. an out of domain error could be thrown if the square root function is called on a negative number. If an error occurs, the optimization process will stop. But we would like it if when a non-physical set of parameters is used, the optimization routine rejects it and keeps going. For that we can use the <a href="https://github.com/JuliaMath/NaNMath.jl"><code>NaNMath</code> library</a>. When functions in the <code>NaNMath</code> library are called with values that would usually produce an out of domain error, they return a <code>NaN</code> value instead. This allows for the optimization routine to continue, while disregarding that set of parameters. </p><pre><code class="language-julia hljs">decapode_code =
    quote
        let
            ^(x,y) = NaNMath.pow(x,y)
            sqrt(x) = NaNMath.sqrt(x)
            log(x) = NaNMath.log(x)

            $(gensim(ice_dynamics2D, dimension = 2, preallocate = false))
        end
    end

f_eval_2D = eval(decapode_code)

f_2D = f_eval_2D(sd2D,generate)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(::Main.var&quot;#f#17&quot;{Main.var&quot;#11#16&quot;{SparseArrays.SparseMatrixCSC{Float64, Int32}}, Decapodes.var&quot;#11#13&quot;{SparseArrays.SparseMatrixCSC{Float64, Int32}}, Decapodes.var&quot;#5#10&quot;{Decapodes.var&quot;#4#9&quot;}, Main.var&quot;#4#7&quot;{Main.var&quot;#2#5&quot;{SparseArrays.SparseMatrixCSC{GeometryBasics.Point{3, Float64}, Int64}}}, Decapodes.var&quot;#11#13&quot;{SparseArrays.SparseMatrixCSC{Int8, Int32}}, Main.var&quot;#^#12&quot;}) (generic function with 1 method)</code></pre><p>Now we can solve the problem and generate some reference data.</p><pre><code class="language-julia hljs">tₑ = 8e3

data_prob = ODEProblem{true,SciMLBase.FullSpecialize}(f_2D, u02D, (0, tₑ), constants_and_parameters)
decapode_sol = solve(data_prob, Rodas5P())

reference_dat = last(decapode_sol).dynamics_h</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">441-element view(::Vector{Float64}, 1:441) with eltype Float64:
 10.357794096943651
 10.35814333095639
 10.358849128291881
 10.359646648290578
 10.36048871724646
 10.36133326746714
 10.362147313157273
 10.362897856785002
 10.363548309877835
 10.36405031998834
  ⋮
 10.363812270459553
 10.363225192532727
 10.362516646193882
 10.36172755950842
 10.360892176930717
 10.360042933825643
 10.359218606604358
 10.358455280840818
 10.357942416576286</code></pre><p>In order to optimize the parameters of the model, we compare the output of the model with certain parameters against the reference data. When the output of the model is as close as possible to the reference data, we&#39;ll have a set of parameters that when used in the model will reproduce the reference data. The difference between the model output and the reference data can be calculated in many ways, in this case we&#39;ll use the sum of squares. </p><pre><code class="language-julia hljs">function loss(u) #only compares last time step
    newp = ComponentArray(n=n, stress_ρ=u[1], stress_g=g, stress_A=A)
    prob = remake(data_prob, p=newp)
    sol = solve(prob, Rodas5P(), sensealg=GaussAdjoint())
    current_dat = last(sol).dynamics_h
    sum(abs2, reference_dat .- current_dat)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">loss (generic function with 1 method)</code></pre><h2 id="Sparsity-Detection-and-Jacobian-Coloring"><a class="docs-heading-anchor" href="#Sparsity-Detection-and-Jacobian-Coloring">Sparsity Detection and Jacobian Coloring</a><a id="Sparsity-Detection-and-Jacobian-Coloring-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Detection-and-Jacobian-Coloring" title="Permalink"></a></h2><p>Before we get to setting up and solving the optimization problem, let&#39;s see if there are any easy things we can do to make sure we have good performance. The optimization routine will run the <code>loss</code> function with many different sets of parameters, each time checking to see how close the output of the model with that set of parameters is. If we want to speed up the optimization process, one way to do that is to speed up the solution of the ordinary differential equation involved. </p><p>Decapodes used a semi-discretization method to discretize the spatial variables of the model. This means that the system of ordinary differential equations that was generated has a state associated with every vertex of the mesh. We chose our mesh to be 21 by 21, so there are 441 vertices in our mesh, which means our ODE has 441 state variables. Since the system of equations might be <a href="https://en.wikipedia.org/wiki/Stiff_equation">stiff</a>, we want to use an implicit method, which means that for every time step the ODE solver takes, it needs to calculate the Jacobian of <code>f_2D</code> with respect to the state variables. Because we have have 441 inputs, and 441 outputs, the Jacobian matrix has a total of 194_481 entries. This seems like a lot, but actually, since not every output will depend on every input, the Jacobian will have many entries that will always be zero. In other words the Jacobian will be sparse. This means that only a few entries actually have to be calculated. We can use the package <code>SparseConnectivityTracer.jl</code> to find the sparsity pattern of the Jacobian.  </p><pre><code class="language-julia hljs">jac_sparsity_2D = jacobian_sparsity((du,u) -&gt; f_2D(du,u,constants_and_parameters,0.0),u02D, u02D, TracerLocalSparsityDetector())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">441×441 SparseArrays.SparseMatrixCSC{Bool, Int64} with 7597 stored entries:
⎡⠻⣦⡳⣄⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠙⢮⡻⣮⠻⣮⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠙⢦⡻⣦⡻⣮⡳⣌⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠙⢦⡙⢮⡻⣮⡻⣎⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠙⢮⡻⢮⡻⣮⡳⣌⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠙⢦⡙⢮⡻⢎⡻⣌⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡛⢮⡻⣮⡳⣬⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡙⣮⡻⣮⡳⣎⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡹⢮⡻⣮⡳⣬⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡙⣮⡻⣮⡻⣌⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡛⢮⡻⣮⡳⣮⡳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡹⣮⡻⣮⡳⣌⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡙⢮⡻⣮⡳⣮⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡹⣮⡻⣮⡳⣌⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡙⢮⡱⣮⡳⣎⡳⣄⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡹⢮⡻⣮⡳⣌⠳⣄⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⡙⢮⡻⣮⡻⣬⠳⣄⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡛⣮⡻⣮⠳⣌⠳⣄⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⡙⢦⡻⣮⡳⣆⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⠹⢮⠻⣦⎦</code></pre><p>We can see that only 7597 entries are actually ever non-zero. If we use a sparsity aware automatic differentiation system to calculate the Jacobian while solving the ODE, we can cut down the number of calculations needed by two orders of magnitude.  </p><p>There&#39;s another way we can speed up the calculation of the Jacobian. Forward mode automatic differentiation systems use the Jacobian vector product (JVP) as their base operation. Meaning that the Jacobian is built column by column using many JVP operations. One way to cut down on the number of JVP operations needed to get the full Jacobian is to use Jacobian coloring. In many cases, the sparse Jacobian will have many columns that do not share any non-zero entries. In that case the columns can be &quot;compressed&quot; in to one column. Now all of the original columns of the Jacobian that were compressed in to one column can be calculated using one JVP operation. This can dramatically cut down the number of operations needed to evaluate a Jacobian. It&#39;s called a Jacobian coloring because seperating a matrix in to columns that do not share a non-zero entry is equivalent to a graph coloring problem. Here we can see that using a greedy coloring algorithm from <code>SparseMatrixColorings.jl</code>, the Jacobian for our function only has 26 colors.  </p><pre><code class="language-julia hljs">col_prob = ColoringProblem()
algo = GreedyColoringAlgorithm()

jac_colors_2D = coloring(jac_sparsity_2D,col_prob,algo)

ncolors(jac_colors_2D)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">26</code></pre><p>Now we can take the coloring pattern we found and see what it looks like when it&#39;s applied to the sparsity pattern. </p><pre><code class="language-julia hljs">compress(jac_sparsity_2D,jac_colors_2D)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">441×26 SparseArrays.SparseMatrixCSC{Int64, Int64} with 7597 stored entries:
⎡⣿⡆⎤
⎢⣿⡇⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎢⣿⣿⎥
⎣⣿⣿⎦</code></pre><p>We can see that this matrix has only 26 columns. This means that when the ODE solver calculates the derivative of the function, it can do it in 26 JVP operations instead of 441, a huge difference! Once the Jacobian is calculated in this compressed form, it can then be &quot;decompressed&quot; using the original coloring pattern. </p><p>Now we can look at how much exactly this has sped up the solving process.</p><p>First, let&#39;s solve the ODE with sparsity not used.</p><pre><code class="language-julia hljs">no_sparse_prob_2D = ODEProblem(f_2D, u02D, (0, tₑ), constants_and_parameters)
no_sparse_soln_2D, exec_time_seconds, _, _, _ = @btimed solve(no_sparse_prob_2D, Rodas5P(autodiff = AutoForwardDiff()))
no_sparse_soln_2D.retcode, exec_time_seconds</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(SciMLBase.ReturnCode.Success, 56.53212086)</code></pre><p>Now the same problem but with the sparsity pattern and Jacobian coloring taken in to account. </p><pre><code class="language-julia hljs">sparse_f_2D = ODEFunction(f_2D, sparsity = jac_sparsity_2D, colorvec = column_colors(jac_colors_2D))
sparse_prob_2D = ODEProblem(sparse_f_2D,u02D,(0,tₑ), constants_and_parameters)
sparse_soln_2D, exec_time_seconds, _, _, _ = @btimed solve(sparse_prob_2D, Rodas5P(autodiff = AutoForwardDiff()))
sparse_soln_2D.retcode, exec_time_seconds</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(SciMLBase.ReturnCode.Success, 60.038345966)</code></pre><p>We can see quite a performance increase!</p><p>For more details on sparsity detection and Jacobian coloring, see the preprint <a href="https://arxiv.org/abs/2501.17737">Sparser, Better, Faster, Stronger: Efficient Automatic Differentiation for Sparse Jacobians and Hessians</a> from A. Hill and G. Dalle.</p><h2 id="Calibration"><a class="docs-heading-anchor" href="#Calibration">Calibration</a><a id="Calibration-1"></a><a class="docs-heading-anchor-permalink" href="#Calibration" title="Permalink"></a></h2><p>Now that we know we can take advantage of sparsity detection and Jacobian coloring, we actually have to tweak our loss function to use them.</p><pre><code class="language-julia hljs">function loss(u) #only compares last time step
    newp = ComponentArray(n=n, stress_ρ=u[1], stress_g=g, stress_A=A)
    prob = remake(sparse_prob_2D, p=newp)
    sol = solve(prob, Rodas5P())
    current_dat = last(sol).dynamics_h
    sum(abs2, reference_dat .- current_dat)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">loss (generic function with 1 method)</code></pre><p>And now to calibrate the <span>$\rho$</span> parameter, all we can use <code>Optimization.jl</code> to set up an <code>OptimizationFunction</code> with our loss function, and an <code>OptimizationProblem</code> where the initial guess is <code>100.0</code>. The specific optimization routine used is the <a href="https://julianlsolvers.github.io/Optim.jl/stable/algo/lbfgs/"><code>Optim.jl</code> LFBGS</a> routine with default settings. This is a gradient based quasi-Newton method that uses automatic differentiation to find the gradient, and uses it to estimate the Hessian. Forward mode automatic differentiation from <a href="https://juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff.jl</code></a> is used to differentiate the loss function to provide the gradients used by LFBGS. Keep in mind that the value of <span>$\rho$</span> used to generate the reference data was 910. If the optimization works we would expect to get a value very close to that.</p><pre><code class="language-julia hljs">optf = OptimizationFunction((x, p) -&gt; loss(x), AutoForwardDiff())
optprob = Optimization.OptimizationProblem(optf, [100.0])
optsol = Optimization.solve(optprob, LBFGS())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 1-element Vector{Float64}:
 910.0126146913435</code></pre><p>As we can see the optimization routine was able to find the parameter that produced the reference data quite closely. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/mhd/">« MHD</a><a class="docs-footer-nextpage" href="../../bc/bc_debug/">Misc Features »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Saturday 15 March 2025 01:44">Saturday 15 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
