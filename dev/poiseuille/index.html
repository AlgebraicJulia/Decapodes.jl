<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Poissuille Flow for Fluid Mechanics · Decapodes.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/analytics.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Decapodes.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Decapodes.jl</a></li><li><a class="tocitem" href="../ice_dynamics/">Glacial Flow</a></li><li><a class="tocitem" href="../api/">Library Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Poissuille Flow for Fluid Mechanics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Poissuille Flow for Fluid Mechanics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AlgebraicJulia/Decapodes.jl/blob/main/docs/src/poiseuille.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Poissuille-Flow-for-Fluid-Mechanics"><a class="docs-heading-anchor" href="#Poissuille-Flow-for-Fluid-Mechanics">Poissuille Flow for Fluid Mechanics</a><a id="Poissuille-Flow-for-Fluid-Mechanics-1"></a><a class="docs-heading-anchor-permalink" href="#Poissuille-Flow-for-Fluid-Mechanics" title="Permalink"></a></h1><p>When modeling a fluid flowing in pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The noslip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.</p><pre><code class="language- hljs">using CombinatorialSpaces
using CombinatorialSpaces.ExteriorCalculus
import Catlab.Theories: otimes, oplus, compose, ⊗, ⊕, ⋅, associate, associate_unit, Ob, Hom, dom, codom
using CombinatorialSpaces.DiscreteExteriorCalculus: ∧
using Catlab.Theories
using Catlab.Present
using Catlab.Graphics
using Catlab.Syntax
using Catlab.CategoricalAlgebra
using LinearAlgebra

using Decapodes.Simulations
using Decapodes.Examples
using Decapodes.Diagrams
using Decapodes.Schedules

# Julia community libraries

using CairoMakie
using Decapodes.Debug
using OrdinaryDiffEq


&quot;&quot;&quot; Decapodes1D
A schema which includes any homomorphisms that may be added by the @decapode
macro.

TODO: This should be chipped away at as more of this tooling takes advantage
of the Catlab GAT system
&quot;&quot;&quot;

@present Decapodes1D(FreeExtCalc1D) begin
  X::Space
  proj₁_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))
  proj₂_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))
  proj₁_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))
  proj₂_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))
  proj₁_⁰¹₀::Hom(Form0(X)⊗Form1(X),Form0(X))
  proj₂_⁰¹₁::Hom(Form0(X)⊗Form1(X),Form1(X))
  proj₁_⁰¹₀⁺::Hom(Form0(X)⊕Form1(X),Form0(X))
  proj₂_⁰¹₁⁺::Hom(Form0(X)⊕Form1(X),Form1(X))
  proj₁_⁰⁰̃₀::Hom(Form0(X)⊗DualForm0(X),Form0(X))
  proj₂_⁰⁰̃₀̃::Hom(Form0(X)⊗DualForm0(X),DualForm0(X))
  proj₁_⁰⁰̃₀⁺::Hom(Form0(X)⊕DualForm0(X),Form0(X))
  proj₂_⁰⁰̃₀̃⁺::Hom(Form0(X)⊕DualForm0(X),DualForm0(X))
  proj₁_⁰¹̃₀::Hom(Form0(X)⊗DualForm1(X),Form0(X))
  proj₂_⁰¹̃₁̃::Hom(Form0(X)⊗DualForm1(X),DualForm1(X))
  proj₁_⁰¹̃₀⁺::Hom(Form0(X)⊕DualForm1(X),Form0(X))
  proj₂_⁰¹̃₁̃⁺::Hom(Form0(X)⊕DualForm1(X),DualForm1(X))
  proj₁_¹⁰₁::Hom(Form1(X)⊗Form0(X),Form1(X))
  proj₂_¹⁰₀::Hom(Form1(X)⊗Form0(X),Form0(X))
  proj₁_¹⁰₁⁺::Hom(Form1(X)⊕Form0(X),Form1(X))
  proj₂_¹⁰₀⁺::Hom(Form1(X)⊕Form0(X),Form0(X))
  proj₁_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))
  proj₂_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))
  proj₁_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))
  proj₂_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))
  proj₁_¹⁰̃₁::Hom(Form1(X)⊗DualForm0(X),Form1(X))
  proj₂_¹⁰̃₀̃::Hom(Form1(X)⊗DualForm0(X),DualForm0(X))
  proj₁_¹⁰̃₁⁺::Hom(Form1(X)⊕DualForm0(X),Form1(X))
  proj₂_¹⁰̃₀̃⁺::Hom(Form1(X)⊕DualForm0(X),DualForm0(X))
  proj₁_¹¹̃₁::Hom(Form1(X)⊗DualForm1(X),Form1(X))
  proj₂_¹¹̃₁̃::Hom(Form1(X)⊗DualForm1(X),DualForm1(X))
  proj₁_¹¹̃₁⁺::Hom(Form1(X)⊕DualForm1(X),Form1(X))
  proj₂_¹¹̃₁̃⁺::Hom(Form1(X)⊕DualForm1(X),DualForm1(X))
  proj₁_⁰̃⁰₀̃::Hom(DualForm0(X)⊗Form0(X),DualForm0(X))
  proj₂_⁰̃⁰₀::Hom(DualForm0(X)⊗Form0(X),Form0(X))
  proj₁_⁰̃⁰₀̃⁺::Hom(DualForm0(X)⊕Form0(X),DualForm0(X))
  proj₂_⁰̃⁰₀⁺::Hom(DualForm0(X)⊕Form0(X),Form0(X))
  proj₁_⁰̃¹₀̃::Hom(DualForm0(X)⊗Form1(X),DualForm0(X))
  proj₂_⁰̃¹₁::Hom(DualForm0(X)⊗Form1(X),Form1(X))
  proj₁_⁰̃¹₀̃⁺::Hom(DualForm0(X)⊕Form1(X),DualForm0(X))
  proj₂_⁰̃¹₁⁺::Hom(DualForm0(X)⊕Form1(X),Form1(X))
  proj₁_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))
  proj₂_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))
  proj₁_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))
  proj₂_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))
  proj₁_⁰̃¹̃₀̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm0(X))
  proj₂_⁰̃¹̃₁̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm1(X))
  proj₁_⁰̃¹̃₀̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm0(X))
  proj₂_⁰̃¹̃₁̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm1(X))
  proj₁_¹̃⁰₁̃::Hom(DualForm1(X)⊗Form0(X),DualForm1(X))
  proj₂_¹̃⁰₀::Hom(DualForm1(X)⊗Form0(X),Form0(X))
  proj₁_¹̃⁰₁̃⁺::Hom(DualForm1(X)⊕Form0(X),DualForm1(X))
  proj₂_¹̃⁰₀⁺::Hom(DualForm1(X)⊕Form0(X),Form0(X))
  proj₁_¹̃¹₁̃::Hom(DualForm1(X)⊗Form1(X),DualForm1(X))
  proj₂_¹̃¹₁::Hom(DualForm1(X)⊗Form1(X),Form1(X))
  proj₁_¹̃¹₁̃⁺::Hom(DualForm1(X)⊕Form1(X),DualForm1(X))
  proj₂_¹̃¹₁⁺::Hom(DualForm1(X)⊕Form1(X),Form1(X))
  proj₁_¹̃⁰̃₁̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm1(X))
  proj₂_¹̃⁰̃₀̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm0(X))
  proj₁_¹̃⁰̃₁̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm1(X))
  proj₂_¹̃⁰̃₀̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm0(X))
  proj₁_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))
  proj₂_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))
  proj₁_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))
  proj₂_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))
  sum₀::Hom(Form0(X)⊗Form0(X),Form0(X))
  sum₁::Hom(Form1(X)⊗Form1(X),Form1(X))
  sum₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))
  sum₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))
end</code></pre><h1 id="Creating-the-Poiseuille-Equations"><a class="docs-heading-anchor" href="#Creating-the-Poiseuille-Equations">Creating the Poiseuille Equations</a><a id="Creating-the-Poiseuille-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-the-Poiseuille-Equations" title="Permalink"></a></h1><p>The first step is to present an extension of the generic Decapodes1D presentation with specific named linear operators for the viscosity effect and the drag effect. This is purely syntactic, we will add the corresponding matrices later. </p><p>The <code>@decapode</code> macro creates the data structure representing the equations of Poiseuille flow. The first block declares variables, the second block defines intermediate terms and the last block is the core equation.</p><pre><code class="language- hljs">@present Poiseuille &lt;: Decapodes1D begin
  (R, μ̃)::Hom(Form1(X), Form1(X))
  # μ̃ = negative viscosity per unit area
  # R = drag of pipe boundary
end;

Poise = @decapode Poiseuille begin
  (∇P)::Form1{X}
  (q, q̇, Δq)::Form1{X}
  P::Form0{X}

  # Laplacian of q for the viscous effect
  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))
  # Gradient of P for the pressure driving force
  ∇P == d₀{X}(P)
  # definition of time derivative of q
  ∂ₜ{Form1{X}}(q) == q̇

  # the core equation
  q̇ == sum₁(sum₁(μ̃(Δq), ∇P),R(q))
end;</code></pre><h1 id="Defining-the-Semantics"><a class="docs-heading-anchor" href="#Defining-the-Semantics">Defining the Semantics</a><a id="Defining-the-Semantics-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-Semantics" title="Permalink"></a></h1><p>In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The operator funcs code below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. </p><pre><code class="language-julia hljs">&quot;&quot;&quot;    boundary_edges(ds)

Compute the edges of a 1D simplicial set that are either incident to in-degree 1 or out-degree 1 nodes.
For a graph, these are boundary vertices meaning leaf nodes. For our pipeflow problems,
these are the edges where material can enter the pipe network.
&quot;&quot;&quot;
function boundary_edges(ds)
  out_degree(x) = length(incident(ds, x, :∂v1))
  in_degree(x) = length(incident(ds, x, :∂v0))
  bpoints = findall(x -&gt; out_degree(x) == 0 || in_degree(x) == 0, 1:nv(ds))
  sedges = vcat(incident(ds,bpoints,:∂v0)...)
  tedges = vcat(incident(ds,bpoints,:∂v1)...)
  bedges = collect(union(sedges, tedges))
  return bedges
end

&quot;&quot;&quot;    mask_boundary_edges(ds)

Provides the `boundary_edges(ds)` as a vector of 0/1 entries to use as a mask.
&quot;&quot;&quot;
function mask_boundary_edges(ds)
  D = ones(Int, ne(ds))
  D[boundary_edges(ds)] .= 0
  return D
end


opbind(f, T) = Dict(:operator=&gt;f, :type=&gt;T)

function create_funcs(ds, hodge=DiagonalHodge())
  funcs = Dict{Symbol, Dict}()
  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())
  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())
  funcs[:⋆₀] = opbind(⋆(Val{0}, ds, hodge=hodge), MatrixFunc())
  funcs[:⋆₀⁻¹] = opbind(inv(⋆(Val{0}, ds, hodge=hodge)), MatrixFunc())
  funcs[:⋆₁⁻¹] = opbind(inv(⋆(Val{1}, ds, hodge=hodge)), MatrixFunc())
  funcs[:d₀] = opbind(d(Val{0}, ds), MatrixFunc())
  funcs[:dual_d₀] = opbind(dual_derivative(Val{0}, ds), MatrixFunc());
  funcs[:sum₁] = opbind((x′, x, y)-&gt;(x′ .= x .+ y), InPlaceFunc())
  funcs[:∧₀₁] = opbind((r, c, v) -&gt; r .= -∧(Tuple{0,1}, ds, c, v), InPlaceFunc())
  return funcs
end

##
function create_funcs(ds, operators, boundaries, hodge=DiagonalHodge())
  funcs = create_funcs(ds, hodge)
  merge!(funcs, operators, boundaries)
  return funcs
end

function operator_funcs(ds)
  F = Dict(
    :μ̃ =&gt; opbind(0.5 *  Diagonal(mask_boundary_edges(ds)), MatrixFunc()),
    :R =&gt; opbind(-0.1 * I(ne(ds)), MatrixFunc()),
    :¬ =&gt; opbind(-I(ne(ds)), MatrixFunc()),
    :k =&gt; opbind(1.0 * I(nv(ds)), MatrixFunc()))
  B = Dict(
    :∂ρ =&gt; opbind((ρᵇ, ρ) -&gt; begin ρᵇ .= ρ; ρᵇ[1] = 0; ρᵇ[end] = 0; return ρᵇ end, InPlaceFunc())
  )
  create_funcs(ds, F, B)
end
form2dim = Dict(:Scalar =&gt; x-&gt;1,
                :Form0 =&gt; nv,
                :Form1 =&gt; ne,
                :DualForm1 =&gt; nv,
                :DualForm0 =&gt; ne)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Function} with 5 entries:
  :Scalar    =&gt; #11
  :DualForm0 =&gt; ne
  :DualForm1 =&gt; nv
  :Form0     =&gt; nv
  :Form1     =&gt; ne</code></pre><h2 id="A-Single-Pipe-Segment"><a class="docs-heading-anchor" href="#A-Single-Pipe-Segment">A Single Pipe Segment</a><a id="A-Single-Pipe-Segment-1"></a><a class="docs-heading-anchor-permalink" href="#A-Single-Pipe-Segment" title="Permalink"></a></h2><p>We create a mesh with one pipe segment to see if we get the right answer. This simulation can be validated with the Poiseuille equation for a single pipe. First we create the mesh.</p><pre><code class="language- hljs">Point3D = Point3{Float64}
s = EmbeddedDeltaSet1D{Bool,Point3D}()
add_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])
add_edge!(s, 1, 2, edge_orientation=true)

ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)
subdivide_duals!(ds, Circumcenter())
ds</code></pre><p>Then we solve the equations.</p><pre><code class="language- hljs">funcs = operator_funcs(ds)
func, code = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P]);
prob = ODEProblem(func, [2.], (0.0, 10000.0), [1.,11.])
sol = solve(prob, Tsit5(); progress=true);
sol.u</code></pre><h2 id="A-Linear-Pipe-with-Multiple-Segments"><a class="docs-heading-anchor" href="#A-Linear-Pipe-with-Multiple-Segments">A Linear Pipe with Multiple Segments</a><a id="A-Linear-Pipe-with-Multiple-Segments-1"></a><a class="docs-heading-anchor-permalink" href="#A-Linear-Pipe-with-Multiple-Segments" title="Permalink"></a></h2><p>We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into <code>n</code> segments. First we define the mesh:</p><pre><code class="language- hljs">function linear_pipe(n::Int)
  s = EmbeddedDeltaSet1D{Bool,Point3D}()
  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])
  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)
  orient!(s)
  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)
  subdivide_duals!(ds, Circumcenter())
  funcs = operator_funcs(ds)
  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])
  return ds, func, funcs
end

ds, func, funcs = linear_pipe(10)
ds</code></pre><p>Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.</p><pre><code class="language- hljs">prob = ODEProblem(func, [5,3,4,2,5,2,8,4,3], (0.0, 10000.0), [10. *i for i in 1:10])
sol = solve(prob, Tsit5(); progress=true);
sol.u</code></pre><h2 id="A-Distribution-Network"><a class="docs-heading-anchor" href="#A-Distribution-Network">A Distribution Network</a><a id="A-Distribution-Network-1"></a><a class="docs-heading-anchor-permalink" href="#A-Distribution-Network" title="Permalink"></a></h2><p>To model a distribution network such as residential drinking water or natural gas, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.</p><pre><code class="language- hljs">function binary_pipe(depth::Int)
  s = EmbeddedDeltaSet1D{Bool,Point3D}()
  add_vertex!(s, point=Point3D(0, 0, 0))
  for n in 1:depth
    for prev_v in vertices(s)[end-2^(n-1)+1:end]
      x, y, _ = s[:point][prev_v]
      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)
                                 for sgn in [1,-1]])
      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)
    end
  end
  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))
  add_edge!(s, 1, v, edge_orientation=true)
  orient!(s)
  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)
  subdivide_duals!(ds, Circumcenter())
  funcs = operator_funcs(ds)
  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])
  return ds, func, funcs
end
ds, func, funcs = binary_pipe(2);
ds</code></pre><p>Then we solve the equations.</p><pre><code class="language- hljs">prob = ODEProblem(func,
                 [5. for _ in 1:ne(ds)],
                 (0.0, 10000.0),
                 Float64[2^(7-p[2]) for p in ds[:point]])

sol = solve(prob, Tsit5(); progress=true);
sol.u</code></pre><h2 id="Multiphysics"><a class="docs-heading-anchor" href="#Multiphysics">Multiphysics</a><a id="Multiphysics-1"></a><a class="docs-heading-anchor-permalink" href="#Multiphysics" title="Permalink"></a></h2><p>Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!</p><p>Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow (q) and the pressure (P) to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.</p><p>The Decapode can be visualized with graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper [PBHF22]. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.</p><pre><code class="language- hljs">@present Poiseuille &lt;: Decapodes1D begin
  (R, μ̃, ¬)::Hom(Form1(X), Form1(X))
  k::Hom(Form0(X), Form0(X))
  # μ̃ = negative viscosity per unit area
  # R = drag of pipe boundary
  # k = pressure as a function of density
  # boundary conditions
  ∂ρ::Hom(Form0(X), Form0(X))
end;

Poise = @decapode Poiseuille begin
  (∇P)::Form1{X}
  (q, q̇, Δq)::Form1{X}
  (P, ρ, ρ̇)::Form0{X}

  # Poiseuille Flow
  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))
  ∂ₜ{Form1{X}}(q) == q̇
  ∇P == d₀{X}(P)
  q̇ == sum₁(sum₁(μ̃(Δq), ¬(∇P)),R(q))
  
  # Pressure/Density Coupling
  P == k(ρ)
  ∂ₜ{Form0{X}}(ρ) == ρ̇
  ρ̇ == ⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(∧₀₁{X}(ρ,q)))) # advection
  
  # Boundary conditions
  ρᵇ::Form0{X}
  ∂ρ(ρ̇) == ρᵇ
end;

to_graphviz(Poise, node_labels=true, prog=&quot;neato&quot;, node_attrs=Dict(:shape=&gt;&quot;oval&quot;))</code></pre><p>Then we can create the mesh and solve the equation.</p><pre><code class="language- hljs">function linear_pipe(n::Int)
  s = EmbeddedDeltaSet1D{Bool,Point3D}()
  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])
  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)
  orient!(s)
  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)
  subdivide_duals!(ds, Circumcenter())
  funcs = operator_funcs(ds)
  func, _ = gen_sim(diag2dwd(Poise, in_vars=[:q, :ρ]), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])
  return ds, func, funcs
end

ds, func, funcs = linear_pipe(10)

prob = ODEProblem(func, [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5], (0.0, 10000.0), [10. *i for i in 1:10])
sol = solve(prob, Tsit5(); progress=true);
sol.u</code></pre><p>Notice that the solution contains both a vector of flows and a vector of pressures.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 20 July 2023 03:35">Thursday 20 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
