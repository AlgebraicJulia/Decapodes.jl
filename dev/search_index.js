var documenterSearchIndex = {"docs":
[{"location":"bc_debug/#Simulation-Setup","page":"Misc Features","title":"Simulation Setup","text":"","category":"section"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"This tutorial showcases some of the other features included in the Decapodes.jl package. Currently, these features are the treatment of boundary conditions and the simulation debugger interface. To begin, we set up the same advection-diffusion problem presented in the Overview section. As before, we define the Diffusion, Advection, and Superposition components, and now include a BC (Bounday Condition) component. Decapodes.jl interprets any Hom which begins with a ∂ as a boundary condition. These boundary conditions recieve special treatment at the scheduling step. Below we show the graphical rendering of this boundary condition diagram, which we will use to impose a Dirichlet condition on the time derivative of concentration at the mesh boundary.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Catlab\nusing Catlab.Graphics\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\n\nDiffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Constant\n\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, C_up)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  C_up == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\nend\n\nBoundaryConditions = @decapode begin\n  (C, C_up)::Form0\n\n  # Temporal boundary\n  ∂ₜ(C) == Ċ\n\n  # Spatial boundary\n  Ċ == ∂C(C_up)\nend\n\nto_graphviz(BoundaryConditions)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"As before, we compose these physics components over our wiring diagram.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  bc(C, C_up)\n  superposition(ϕ₁, ϕ₂, ϕ, C_up, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(BoundaryConditions, [:C, :C_up]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C_up, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"When this is scheduled, Decapodes will apply any boundary conditions immediately after the impacted value is computed. This implementation choice ensures that this boundary condition holds true for any variables dependent on this variable, though also means that the boundary conditions on a variable have no immediate impact on the variables this variable is dependent on.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"In the visualization below, wee see that the final operation executed on the data is the boundary condition we are enforcing on the change in concentration.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"to_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Next we import the mesh we will use. In this case, we are wanting to impose boundary conditions and so we will use the plot_mesh from the previous example instead of the mesh with periodic boundary conditions. Because the mesh is only a primal mesh, we also generate and subdivide the dual mesh.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Rectangle_30x10 is a default mesh that is downloaded via Artifacts.jl when a user installs Decapodes. Via CombinatorialSpaces.jl, we can instantiate any .obj file of triangulated faces as a simplicial set.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\n\n# Generate the dual mesh\nplot_mesh_dual = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(plot_mesh)\n# Calculate distances and subdivisions for the dual mesh\nsubdivide_duals!(plot_mesh_dual, Circumcenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nwireframe!(ax, plot_mesh)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Finally, we define our operators, generate the simulation function, and compute the simulation. Note that when we define the boundary condition operator, we hardcode the boundary indices and values into the operator itself. We also move the initial concentration to the left, so that we are able to see a constant concentration on the left boundary which will act as a source in the flow. The modified initial condition is shown below:","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using LinearAlgebra\nusing ComponentArrays\nusing MLStyle\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\ninclude(\"../../examples/boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    :∂C => x -> begin\n      boundary = boundary_inds(Val{0}, sd)\n      x[boundary] .= 0\n      x\n    end\n    :∧₀₁ => (x,y) -> begin\n      ∧(Tuple{0,1}, sd, x,y)\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend\n\nusing Distributions\nc_dist = MvNormal([1, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in plot_mesh_dual[:point]]\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nmesh!(ax, plot_mesh; color=c[1:nv(plot_mesh)])\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"And the simulation result is then computed and visualized below.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using OrdinaryDiffEq\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(plot_mesh_dual, generate)\n\nvelocity(p) = [-0.5, 0.0, 0.0]\nv = ♭(plot_mesh_dual, DualVectorField(velocity.(plot_mesh_dual[triangle_center(plot_mesh_dual),:dual_point]))).data\n\nu₀ = ComponentArray(C=c)\nparams = (V = v,)\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0), params)\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t).C for t in times]\nextrema\n# Initial frame\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, plot_mesh; color=colors[1], colorrange = extrema(vcat(colors...)))\nColorbar(fig[1,2], pmsh)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv_right.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\n  pmsh.color = sol(t).C\nend","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"(Image: )","category":"page"},{"location":"cism/#Replicating-the-Community-Ice-Sheet-Model-v2.1-Halfar-Dome-Benchmark-with-Decapodes","page":"CISM v2.1","title":"Replicating the Community Ice Sheet Model v2.1 Halfar Dome Benchmark with Decapodes","text":"","category":"section"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The Decapodes framework takes high-level representations of physics equations and automatically generates solvers.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We do so by translating equations from vector calculus notation to the \"discrete exterior calculus\" (DEC). This process is roughly about recognizing whether physical quantities represent scalar or vector quantities, and recognizing whether differential operators represent gradient, divergence, and so on.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In this benchmark, we will implement the \"small slope approximation\" of glacial dynamics used by P. Halfar in his 1981 work \"On the dynamics of the ice sheets\" by taking his original formulation, translating it into the DEC, then providing a mesh and initial conditions.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The initial conditions used here are exactly those considered by W. H. Lipscomb et al. in \"Description And Evaluation of the Community Ice Sheet Model (CISM) v2.1\" (2019).","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\n\n# External Dependencies\nusing ComponentArrays\nusing MLStyle\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing SparseArrays\nusing Statistics\nusing CairoMakie\nusing BenchmarkTools\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}; # hide","category":"page"},{"location":"cism/#Specifying-and-Composing-Physics","page":"CISM v2.1","title":"Specifying and Composing Physics","text":"","category":"section"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Halfar Equation 2\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We will translate Halfar's equation into the DEC below. Although the equation given by Halfar is dense, this notation does not allow you to see which operators represent divergence, which components represent diffusivity constants, and so on. In the DEC, there is a small pool of operators, ⋆, d, ∧, ♯, and ♭, which combine according to set rules to encode all of these notions.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In the DEC, gradients are generalized by the exterior derivative \"d\". Given scalar-data, d gives the slope along edges in our mesh. Similarly, the operator (⋆, d, ⋆) generalizes divergence.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In Halfar's equation there is a term corresponding to the magnitude of the slope, but it is not clear where this quantity is to be defined. Is it a scalar-like quantity, or a vector-like quantity? In the DEC translation, we take the gradient of h, d(h), and use the \"sharp\" operator to define it on points in the domain, where we then take its magnitude. The \"wedge product\", ∧, takes care of multiplying a scalar-like quantity by a vector-like quantity.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Halfar's equation looks a little disjoint. It seems that the front most terms are responsible for computing some parameter, while the remaining terms on the right encode something about the dynamics. This is because Halfar's equation is actually describing two equations in one. The front-most term defines a quantity - depending on the strain of the ice - that controls the rate at which ice diffuses. Since this computation is rather separate from the rest of the computations involving our differential operators, we will call it \"Gamma\" here, and define it in a later component Decapode.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Equation 2 from Halfar, P. ON THE DYNAMICS OF THE ICE SHEETS. (1981),\n# translated into the exterior calculus.\nhalfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form1\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == ∘(⋆, d, ⋆)(Γ  * d(h) ∧ (mag(♯(d(h)))^(n-1)) ∧ (h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Glen's Law\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Here, we recognize that Gamma is in fact what glaciologists call \"Glen's Flow Law.\" It states that the strain rate of a sheet of ice can be related to applied stress via a power law. Below, we encode the formulation as it is usually given in the literature, depending explicitly on the gravitational constant, g.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Equation 1 from Glen, J. W. THE FLOW LAW OF ICE: A discussion of the\n# assumptions made in glacier theory, their experimental foundations and\n# consequences. (1958)\nglens_law = @decapode begin\n  Γ::Form1\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We now need some way to compose these physics equations together. Since this physics is rather small, and there are no naming conflicts of physical quantities, this composition is also rather simple.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"#####################\n# Compose the model #\n#####################\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\nto_graphviz(ice_dynamics_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plug in our Decapodes to the composition pattern.\nice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n   Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics, verbose=false)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We have a representation of our composed physics. Now, we need to specify that these dynamics occur in 2 dimensions.","category":"page"},{"location":"cism/#Providing-a-Semantics","page":"CISM v2.1","title":"Providing a Semantics","text":"","category":"section"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Interpret this multiphysics diagram in the 2D exterior calculus.\n\nice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\nto_graphviz(ice_dynamics2D, verbose=false)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We are done encoding our dynamics. Now, we need to provide a mesh,  initial data to use for our quantities, and what functions to use for our differential operators.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Our mesh library, CombinatorialSpaces, can interpret arbitrary .OBJ files to run our dynamics on. Here, we use a script that generates a triangulated grid of the resolution used in the CISM benchmark. Note though that the \"resolution\" of a triangulated and non-triangulated grid is difficult to directly compare.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"s′ = triangulated_grid(60_000,100_000,2_000,2_000,Point3D)\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nx̄ = mean(p -> p[1], point(s))\nȳ = mean(p -> p[2], point(s))\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nwf = wireframe!(ax, s)\nsave(\"ice_mesh.png\", fig)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Wireframe of the Domain\")","category":"page"},{"location":"cism/#Defining-input-data","page":"CISM v2.1","title":"Defining input data","text":"","category":"section"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We replicate the initial conditions and parameter values used in the CISM benchmark.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# These are the initial conditions to the Halfar Dome test case that the\n# Community Ice Sheet Model uses.\nR₀ = 60_000 * sqrt(0.125)\nH = 2_000 * sqrt(0.125)\n\nn = 3\ng = 9.8101\nρ = 910\nalpha = 1/9\nbeta = 1/18\nflwa = 1e-16\nA = fill(1e-16, ne(s))\n\nGamma = 2.0/(n+2) * flwa * (ρ * g)^n\nt0 = (beta/Gamma) * (7.0/4.0)^3 * (R₀^4 / H^7)\n\n# This is the analytic solution for comparison.\n# It is ported over from the CISM code for comparison's sake,\n# and we will use it to set initial conditions.\nfunction height_at_p(x,y,t)\n  tr = (t + t0) / t0\n  r = sqrt((x - x̄)^2 + (y - ȳ)^2)\n  r = r/R₀\n  inside = max(0.0, 1.0 - (r / tr^beta)^((n+1.0) / n))\n  H * inside^(n / (2*n + 1)) / tr^alpha\nend\n\n# Set the initial conditions for ice sheet height:\n# Ice height is a primal 0-form. i.e. valued at vertices.\nh₀ = map(x -> height_at_p(x[1], x[2], 0), point(s′))\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nmsh = mesh!(ax, s′, color=h₀, colormap=:jet)\nsave(\"ice_initial_conditions.png\", fig)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Initial Conditions\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Store these values to be passed to the solver.\nu₀ = ComponentArray(dynamics_h = h₀)\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We provide here the mapping from symbols to differential operators. As more of the differential operators of the DEC are implemented, they are upstreamed to the Decapodes and CombinatorialSpaces libraries. Of course, users can also provide their own implementations of these operators and others as they see fit.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"#############################################\n# Define how symbols map to Julia functions #\n#############################################\n\n# This sharp operator, ♯, is scheduled to be upstreamed.\ninclude(\"sharp_op.jl\")\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  # We pre-allocate matrices that encode differential operators.\n  ♯_m = ♯_mat(sd)\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      ♯_m * x\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :^ => (x,y) -> begin\n      x .^ y\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The gensim function takes our high-level representation of the physics equations and produces compiled simulation code. It performs optimizations such as allocating memory for intermediate variables, and so on.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"#######################\n# Generate simulation #\n#######################\n\nsim = eval(gensim(ice_dynamics2D))\nfₘ = sim(s, generate)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Julia is a \"Just-In-Time\" compiled language. That means that functions are compiled the first time they are called, and later calls to those functions skip this step. To get a feel for just how fast this simulation is, we will run the dynamics twice, once for a very short timespan to trigger pre-compilation, and then again for the actual dynamics.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Pre-compile simulation\n\n# Julia will pre-compile the generated simulation the first time it is run.\n@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Run simulation\ntₑ = 200\n\n# This next run should be fast.\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We can benchmark the compiled simulation with @benchmarkable. This macro runs many samples of the simulation function so we get an accurate estimate of the simulation time. The simulation time is quite fast compared to the CISM benchmarks. These results are run automatically via GitHub Actions as part of our docs build, which is not optimized for numerical simulations.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Time the simulation\n\nb = @benchmarkable solve(prob, Tsit5())\nc = run(b)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Save the solution information to a file.\n@save \"ice_dynamics2D.jld2\" soln","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We recall that these dynamics are of the \"shallow slope\" and \"shallow ice\" approximations. So, at the edge of our parabolic dome of ice, we expect increased error as the slope increases. On the interior of the dome, we expect the dynamics to match more closely that given by the analytic model. We will see that the CISM results likewise accumulate error in the same neighborhood.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Halfar Small Ice Approximation Quote\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the final conditions\nfunction plot_final_conditions()\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Modeled thickness (m) at time 200.0\",\n    aspect=0.6)\n  msh = mesh!(ax, s′, color=soln(200.0).dynamics_h, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_final_conditions()\nsave(\"ice_numeric_solution.png\", fig)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Numerical Solution\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the final conditions according to the analytic solution.\nfunction plot_analytic()\n  hₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s′))\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Analytic thickness (m) at time 200.0\",\n    aspect=0.6)\n  msh = mesh!(ax, s′, color=hₐ, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_analytic()\nsave(\"ice_analytic_solution.png\", fig)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Analytic Solution)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the error.\nfunction plot_error()\n  hₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s′))\n  h_diff = soln(tₑ).dynamics_h - hₐ\n  extrema(h_diff)\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Modeled thickness - Analytic thickness at time 200.0\",\n    aspect=0.6)\n  msh = mesh!(ax, s′, color=h_diff, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_error()\nsave(\"ice_error.png\", fig)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Numeric Solution - Analytic Solution\")","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We compute below that the maximum absolute error is approximately 89 meters. We observe that this error occurs exactly on the edge of the dome, which we expect given that this is where the \"shallow slope approximation\" breaks down, and the updates to our physical quantities should become more unstable. This pattern likewise occurs in the CISM benchmarks.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute max absolute error:\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s′))\nh_diff = soln(tₑ).dynamics_h - hₐ\nmaximum(abs.(h_diff))","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We compute root meand square error (RMSE) as well, both over the entire domain, and excluding where the ice distribution is 0 in the analytic solution. (Considering the entire domain decreases the RMSE, while not telling you much about the dynamics in the area of interest.) Note that the official CISM benchmark reports 6.43 and 9.06 RMSE for their two solver implementations.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute RMSE not considering the \"outside\".\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s′))\nnonzeros = findall(!=(0), hₐ)\nh_diff = soln(tₑ).dynamics_h - hₐ\nrmse = sqrt(sum(map(x -> x*x, h_diff[nonzeros])) / length(nonzeros))","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute RMSE of the entire domain.\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s′))\nh_diff = soln(tₑ).dynamics_h - hₐ\nrmse = sqrt(sum(map(x -> x*x, h_diff)) / length(h_diff))","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Create a gif\nbegin\n  frames = 100\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1])\n  msh = mesh!(ax, s′, color=soln(0).dynamics_h, colormap=:jet, colorrange=extrema(soln(tₑ).dynamics_h))\n  Colorbar(fig[1,2], msh)\n  record(fig, \"ice_dynamics_cism.gif\", range(0.0, tₑ; length=frames); framerate = 30) do t\n    msh.color = soln(t).dynamics_h\n  end\nend","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Ice Dynamics)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"For comparison's sake, we paste the results produced by CISM below. We observe that the error likewise accumulates around the edge of the dome, with more accurate predictions on the interior. We note that our simulation produces slight over-estimates on the interior, but there are further strategies that one can employ to increase accuracy, such as tweaking the error tolerance of the solver, and so on.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Not that since the DEC is based on triangulated meshes, the \"resolution\" of the CISM benchmark and the Decapodes implementation cannot be directly compared. An advantage of the DEC is that we do not need to operate on uniform grids. For example, you could construct a mesh that is finer along the dome edge, where you need more resolution, and coarser as you are farther away from the reach of the ice.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: CISM Results)","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We saw in this document how to create performant and accurate simulations in the Decapodes framework, and compared against the CISM library . Although we do not expect to be both more performant and accurate compared to every hand-crafted simulation, Decapodes makes up for this difference in terms of development time, flexibility, and composition. For example, the original implementation of the Decapodes shallow ice model took place over a couple of afternoons during a hackathon.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Since Decapodes targets high-level representations of physics, it is uniquely suited to incorporating knowledge from subject matter experts to increase simulation accuracy. This process does not require an ice dynamics expert to edit physics equations that have already been weaved into solver code.","category":"page"},{"location":"cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Further improvements to the Decapodes library are made continuously. We are creating implementations of DEC operators that are constructed and execute faster. And we are in the beginning stages of 3D simulations using the DEC.","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Decapodes","page":"Library Reference","title":"Decapodes","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.CartesianPoint","page":"Library Reference","title":"Decapodes.CartesianPoint","text":"CartesianPoint{T}(p)\n\na point in cartesian coordinates, intended as a wrapper around Point3 from GeometryBasics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.SpherePoint","page":"Library Reference","title":"Decapodes.SpherePoint","text":"SpherePoint{T}(p)\n\na point in spherical coordinates, intended as a wrapper around Point3 from GeometryBasics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.TangentBasis-Tuple{Any}","page":"Library Reference","title":"Decapodes.TangentBasis","text":"tb(w)\n\nTake a linear combinations of the tangent vectors at the base point.  Use this to get a vector tangent to the sphere in the coordinate system of the base point. If the base point is in spherical coordinates, this is the identity, if the base point is in cartesian coordinates, it returns the tangent vector in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.gensim-Tuple{DiagrammaticEquations.decapodeacset.AbstractNamedDecapode}","page":"Library Reference","title":"Decapodes.gensim","text":"function gensim(d::AbstractNamedDecapode; dimension::Int=2)\n\nGenerate a simulation function from the given Decapode. The returned function can then be combined with a mesh and a function describing function mappings to return a simulator to be passed to solve.\n\n\n\n\n\n","category":"method"},{"location":"equations/#Simple-Equations","page":"Equations","title":"Simple Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"This tutorial shows how to use Decapodes to represent simple equations. These aren't using any of the Discrete Exterior Calculus or CombinatorialSpaces features of Decapodes. They just are a reference for how to build equations with the @decapodes macro and see how they are stored as ACSets.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"using Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The harmonic oscillator can be written in Decapodes in at least three different ways.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The default representation is a tabular output as an ACSet. The tables are Var for storing variables (X) and their types (Form0). TVar for identifying a subset of variables that are the tangent variables of the dynamics (Ẋ). The unary operators are stored in Op1 and binary operators stored in Op2. If a table is empty, it doesn't get printed.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Even though a diagrammatic equation is like a graph, there are no edge tables, because the arity (number of inputs) and coarity (number of outputs) is baked into the operator definitions.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"You can also see the output as a directed graph. The input arrows point to the state variables of the system and the output variables point from the tangent variables. You can see that I have done the differential degree reduction from  x'' = -kx by introducing a velocity term v. Decapodes has some support for derivatives in the visualization layer, so it knows that dX/dt should be called Ẋ and that dẊ/dt should be called Ẋ̇.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"In the previous example, we viewed negation and transformation by k as operators. Notice that k appears as an edge in the graph and not as a vertex. You can also use a 2 argument function like multiplication (*). With a constant value for k::Constant. In this case you will see k enter the diagram as a vertex and multiplication with * as a binary operator.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"This gives you a different graphical representation as well. Now we have the cartesian product objects which represent a tupling of two values.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"You can also represent negation as a multiplication by a literal -1.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Notice that the type bubble for the literal one is ΩL. This means that it is a literal. The literal is also used as the variable name.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"We can allow the material properties to vary over time by changing Constant to Parameter. This is how we tell the simulator that it needs to call k(t) at each time step to get the updated value for k or if it can just reuse that constant k from the initial time step.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Parameter\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Often you will have a linear material where you are scaling by a constant, and a nonlinear version of that material where that scaling is replaced by a generic nonlinear function. This is why we allow Decapodes to represent both of these types of equations.","category":"page"},{"location":"ice_dynamics/#Halfar's-model-of-glacial-flow","page":"Glacial Flow","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\n\n# External Dependencies\nusing MLStyle\nusing ComponentArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing SparseArrays\nusing Statistics\nusing CairoMakie\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64};\nPoint3D = Point3{Float64};","category":"page"},{"location":"ice_dynamics/#Defining-the-models","page":"Glacial Flow","title":"Defining the models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first step is to find a suitable equation for our model, and translate it into the Discrete Exterior Calculus. The Exterior Calculus is a generalization of vector calculus, so for low-dimensional spaces, this translation is straightforward. For example, divergence is typically written as (⋆, d, ⋆). Scalar fields are typically interpreted as \"0Forms\", i.e. values assigned to vertices of a mesh.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We use the @decapode macro to interpret the equations. Here, we have equation 2 from Halfar:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fracpartial hpartial t = frac2n + 2 (fracrho gA)^n fracpartialpartial x(fracpartial hpartial x fracpartial hpartial x ^n-1 h^n+2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll change the term out front to Γ so we can demonstrate composition in a moment.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In the exterior calculus, we could write the above equations like so:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"partial_t(h) = circ(star d star)(Gammaquad d(h)quad textavg_01d(h)^sharp^n-1 quad textavg_01(h^n+2))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"avg here is an operator that performs the midpoint rule, setting the value at an edge to be the average of the values at its two vertices.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form1\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯(d(h)))^(n-1)) * avg₀₁(h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"And here, a formulation of Glen's law from J.W. Glen's 1958 \"The flow law of ice\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"glens_law = @decapode begin\n  #Γ::Form0\n  Γ::Form1\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"ice_dynamics/#Composing-models","page":"Glacial Flow","title":"Composing models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can use operadic composition to specify how our models come together. In this example, we have two Decapodes, and two quantities that are shared between them.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\nto_graphviz(ice_dynamics_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To a apply a composition, we specify which Decapodes to plug into those boxes, and what each calls the corresponding shared variables internally.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"ice_dynamics/#Provide-a-semantics","page":"Glacial Flow","title":"Provide a semantics","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To interpret our composed Decapode, we need to specify what Discrete Exterior Calculus to interpret our quantities in. Let's choose the 1D Discrete Exterior Calculus:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics1D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics1D, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(ice_dynamics1D, op1_res_rules_1D, op2_res_rules_1D)\n\nto_graphviz(ice_dynamics1D)","category":"page"},{"location":"ice_dynamics/#Define-a-mesh","page":"Glacial Flow","title":"Define a mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll need a mesh to simulate on. Since this is a 1D mesh, we can go ahead and make one right now:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# This is a 1D mesh, consisting of edges and vertices.\ns′ = EmbeddedDeltaSet1D{Bool, Point2D}()\n# 20 hundred vertices along a line, connected by edges.\nadd_vertices!(s′, 20, point=Point2D.(range(0, 10_000, length=20), 0))\nadd_edges!(s′, 1:nv(s′)-1, 2:nv(s′))\norient!(s′)\ns = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s′)\nsubdivide_duals!(s, Circumcenter())","category":"page"},{"location":"ice_dynamics/#Define-input-data","page":"Glacial Flow","title":"Define input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need initial conditions to use for our simulation.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\n# We choose a distribution that obeys the shallow height and shallow slope conditions.\nh₀ = map(point(s′)) do (x,_)\n  ((7072-((x-5000)^2))/9e3+2777)/2777e-1\nend\n\n# Visualize initial conditions for ice sheet height.\nlines(map(x -> x[1], point(s′)), h₀, linewidth=5)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need to tell our Decapode which data maps to which symbols. We can wrap up our data like so:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-functions","page":"Glacial Flow","title":"Define functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. In the DEC, there are a handful of operators that one uses to construct all the usual vector calculus operations, namely: ♯, ♭, ∧, d, ⋆. The CombinatorialSpaces.jl library specifies many of these for us.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-the-simulation","page":"Glacial Flow","title":"Generate the simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Now, we have everything we need to generate our simulation:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics1D, dimension=1))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first time that you run a function, Julia will pre-compile it, so that later runs will be fast. We'll solve our simulation for a short time span, to trigger this pre-compilation, and then run it.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\ntₑ = 8e3\n\n# This next run should be fast.\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can save our solution file in case we want to examine its contents when this Julia session ends.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics1D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's examine the final conditions:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig,ax,ob = lines(map(x -> x[1], point(s′)), soln(tₑ).dynamics_h, linewidth=5)\nylims!(ax, extrema(h₀))\ndisplay(fig)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We see that our distribution converges to a more uniform ice height across our domain, which matches our physical intuition.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's create a GIF to examine an animation of these dynamics:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Create a gif\nbegin\n  frames = 100\n  fig, ax, ob = lines(map(x -> x[1], point(s′)), soln(0).dynamics_h)\n  ylims!(ax, extrema(h₀))\n  record(fig, \"ice_dynamics1D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    lines!(map(x -> x[1], point(s′)), soln(t).dynamics_h)\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics1D)","category":"page"},{"location":"ice_dynamics/#2D-Re-interpretation","page":"Glacial Flow","title":"2D Re-interpretation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first, one-dimensional, semantics that we provided to our Decapode restricted the kinds of glacial sheets that we could model. (i.e. We could only look at glacial sheets which were constant along y). We can give our Decapode an alternate semantics, as some physics on a 2-dimensional manifold.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Note that for these physics, we make no adjustments to the underlying \"dimension-agnostic\" Decapode, we only provide a different set of rules for inferring what the type of each quantity is.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\n\nto_graphviz(ice_dynamics2D)","category":"page"},{"location":"ice_dynamics/#Store-as-JSON","page":"Glacial Flow","title":"Store as JSON","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We quickly demonstrate how to serialize a Decapode to JSON and read it back in:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"write_json_acset(ice_dynamics2D, \"ice_dynamics2D.json\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# When reading back in, we specify that all attributes are \"Symbol\"s.\nice_dynamics2 = read_json_acset(SummationDecapode{Symbol,Symbol,Symbol}, \"ice_dynamics2D.json\")\n# Or, you could choose to interpret the data as \"String\"s.\nice_dynamics3 = read_json_acset(SummationDecapode{String,String,String}, \"ice_dynamics2D.json\")\n\nto_graphviz(ice_dynamics3)","category":"page"},{"location":"ice_dynamics/#Define-our-mesh","page":"Glacial Flow","title":"Define our mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s′ = triangulated_grid(10_000,10_000,800,800,Point3D)\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nwf = wireframe!(ax, s′)\nfig","category":"page"},{"location":"ice_dynamics/#Define-our-input-data","page":"Glacial Flow","title":"Define our input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y)\n  (7072-((x-5000)^2 + (y-5000)^2)^(1/2))/9e3+10\nend\n\n# Visualize initial condition for ice sheet height.\nmesh(s′, color=h₀, colormap=:jet)\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nmsh = mesh!(ax, s′, color=h₀, colormap=:jet)\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-our-functions","page":"Glacial Flow","title":"Define our functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      ♯(sd, EForm(x))\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      @show length(x)\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-simulation","page":"Glacial Flow","title":"Generate simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run-2","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"tₑ = 5e13\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics2D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize-2","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Final conditions:\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nmsh = mesh!(ax, s′, color=soln(tₑ).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 100\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1])\n  msh = CairoMakie.mesh!(ax, s′, color=soln(0).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\n  Colorbar(fig[1,2], msh)\n  record(fig, \"ice_dynamics2D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    msh.color = soln(t).dynamics_h\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2D)","category":"page"},{"location":"ice_dynamics/#2-Manifold-in-3D","page":"Glacial Flow","title":"2-Manifold in 3D","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We note that just because our physics is happening on a 2-manifold, (a surface), this doesn't restrict us to the 2D plane. In fact, we can \"embed\" our 2-manifold in 3D space to simulate a glacial sheets spread across the globe.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s′ = loadmesh(Icosphere(3, 10_000))\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nwireframe(s)\n","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y,z)\n  (z*z)/(10_000*10_000)\nend\n\n# Visualize initial condition for ice sheet height.\n# There is lots of ice at the poles, and no ice at the equator.\nfig = Figure()\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s′, color=h₀, colormap=:jet)\ndisplay(fig)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# For brevity's sake, we'll skip the pre-compilation cell.\n\ntₑ = 5e25\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\n# Compare the extrema of the initial and final conditions of ice height.\nextrema(soln(0).dynamics_h), extrema(soln(tₑ).dynamics_h)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig = Figure()\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s′, color=soln(tₑ).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\ndisplay(fig)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 200\n  fig = Figure()\n  ax = LScene(fig[1,1], scenekw=(lights=[],))\n  msh = CairoMakie.mesh!(ax, s′, color=soln(0).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\n\n  Colorbar(fig[1,2], msh)\n  # These particular initial conditions diffuse quite quickly, so let's just look at\n  # the first moments of those dynamics.\n  record(fig, \"ice_dynamics2D_sphere.gif\", range(0.0, tₑ/64; length=frames); framerate = 20) do t\n    msh.color = soln(t).dynamics_h\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2DSphere)","category":"page"},{"location":"klausmeier/#Klausmeier","page":"Klausmeier","title":"Klausmeier","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"<figure>\n    <img src=\"https://www.cise.ufl.edu/~luke.morris/imgs/somaliland_vegetation.png\"\n         alt=\"Somaliland Vegetation\">\n    <figcaption>One of the first aerial photographs of British Somaliland (now Somaliland) investigated by W.A. Macfadyen in his 1950 \"Vegetation Patterns in the Semi-Desert Plains of British Somaliland\"\\[1\\]. From this point of view, Macfadyen's \"vegetation arcs\" are plainly visible.</figcaption>\n</figure>","category":"page"},{"location":"klausmeier/#Background","page":"Klausmeier","title":"Background","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"From aerial photographs in the late 1940s, British ecologist W.A. Macfadyen discovered that vegetation in semi-arid environments often grows in striping patterns, but was unaware of the exact mechanism that causes them. What is especially striking about these \"vegetation arcs\" is that these stripes appear to climb uphill, with denser plant growth at the leading edge of these traveling waves. Much like how the Mandelbrot set and other interesting fractal patterns can arise from simple sets of rules, these vegetation dynamics can be explained by simple sets of partial differential equations.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The Klausmeier model, given by Christopher Klausmeier in his 1999 paper \"Regular and Irregular Patterns in Semiarid Vegetation\"[2], models such dynamics. Although Macfadyen had discovered these vegetation patterns 50s years prior[1,3], defining these dynamics through accessible and physically-meaningful PDEs proved a catalyst for further research. At the time of writing, Klausmeier's paper has been cited 594 times.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"In this document, we will use Decapodes to formally represent these equations. Moreover, we will demonstrate how one can automatically generate simulation that reproduces the dynamics given by a scientist, simply by reading in the equations given in their original publication.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The lofty goal of this document, and of Decapodes itself, is that through both explicitly representing a model - such as Klausmeier's - and handling the generation of simulation code, we can amplify its accessibility and composability, and ultimately spur further research. Lets start by using Decapodes.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"(Image: Klausmeier GIF)","category":"page"},{"location":"klausmeier/#using-Decapodes","page":"Klausmeier","title":"using Decapodes","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Load Dependencies\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\nusing Catlab\nusing CombinatorialSpaces\n\nusing Distributions\nusing CairoMakie\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing ComponentArrays\nusing OrdinaryDiffEq\nusing GeometryBasics: Point2\nPoint2D = Point2{Float64}","category":"page"},{"location":"klausmeier/#Model-Representation","page":"Klausmeier","title":"Model Representation","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The Klausmeier model consists of two parts: one governing plant growth (phytodynamics), and one governing hydrodynamics. The differential operator Δ represents the diffusion of vegetation, and the \"Lie derivative\" operator ℒ represents the change of water in a direction. In this case, the flow of water downhill, \"dX\".","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Decapodes are written in the language of the Exterior Calculus, which generalizes Vector Calculus. For us, that means that we get to specify whether a physical quantity should valued at points in our domain (i.e. primal and dual Form0s), or whether they are more vector-like quantities, that should be valued along edges in our domain (i.e. primal and dual Form1s). In this case, water density w and vegetation density n are both Form0s, while dX, the gradient of our hill, is a Form1.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# See Klausmeier Equation 2.a\nHydrodynamics = @decapode begin\n  (n,w)::DualForm0\n  dX::Form1\n  (a,ν)::Constant\n\n  ∂ₜ(w) == a - w - w * n^2 + ν * ℒ(dX, w)\nend\n\n# See Klausmeier Equation 2.b\nPhytodynamics = @decapode begin\n  (n,w)::DualForm0\n  m::Constant\n\n  ∂ₜ(n) == w * n^2 - m*n + Δ(n)\nend # hide","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Now that we have our two component models, we can specify a means of composing them via a composition pattern.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Specify Composition\ncompose_klausmeier = @relation () begin\n  phyto(N, W)\n  hydro(N, W)\nend\n\nto_graphviz(compose_klausmeier, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We apply our composition pattern by plugging in component Decapodes, and specifying which internal quantities to share along edges. Decapodes are formalized via the field of Applied Category Theory. A practical consequence here is that we can view a Decapode as a sort of computation graph.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Apply Composition\nklausmeier_cospan = oapply(compose_klausmeier,\n                           [Open(Phytodynamics, [:n, :w]),\n                            Open(Hydrodynamics, [:n, :w])])\nKlausmeier = apex(klausmeier_cospan)\nto_graphviz(Klausmeier)","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"With our model now explicitly represented, we have everything we need to automatically generate simulation code. We could write this to an intermediate file and use it later, or we can go ahead and evaluate the code in this session.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"sim = eval(gensim(Klausmeier, dimension=1))","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We discretize our differential operators using the Discrete Exterior Calculus. The DEC is an elegant way of building up more complex differential operators from simpler ones. To demonstrate, we will define the Δ operator by building it up with matrix multiplication of simpler operators. Since most operators in the DEC are matrices, most simulations consist mainly of matrix-vector multiplications, and are thus very fast. We can also cache these ","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"If this code seems too low level, do not worry. Decapodes defines and caches for you many differential operators behind the scenes, so you do not have to worry about defining your own.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"function generate(sd, my_symbol; hodge=DiagonalHodge())\n  lap_mat = hodge_star(1,sd) * d(0,sd) * inv_hodge_star(0,sd) * dual_derivative(0,sd)\n  dd_mat = dual_derivative(0,sd)\n  ih_mat = inv_hodge_star(0,sd)\n  h_mat = hodge_star(1,sd)\n  ih_dd_mat = ih_mat * dd_mat\n  op = @match my_symbol begin\n    :Δ => x -> begin\n      lap_mat * x\n    end\n    :ℒ => (x,y) -> begin\n      h_mat * ∧(0,1,sd, ih_dd_mat * y, x)\n    end\n    :^ => (x,y) -> begin\n      x .^ y\n    end\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We now need a mesh to define our domain. In the 2D case, our CombinatorialSpaces library can read in arbitrary .OBJ files. In 1D, it is often simpler to just generate a mesh on the fly. Since we are running our physics on a circle - i.e periodic boundaries - we will use a simple function that generates it.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We will visualize the mesh embedded in two dimensions here, but in later visualizations, we can represent it as a periodic line.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Define Mesh\nfunction circle(n, c)\n  s = EmbeddedDeltaSet1D{Bool, Point2D}()\n  map(range(0, 2pi - (pi/(2^(n-1))); step=pi/(2^(n-1)))) do t\n    add_vertex!(s, point=Point2D(cos(t),sin(t))*(c/2pi))\n  end\n  add_edges!(s, 1:(nv(s)-1), 2:nv(s))\n  add_edge!(s, nv(s), 1)\n  sd = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  s,sd\nend\ns,sd = circle(7, 500)\n\nscatter(sd[:point])","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's pass our mesh and methods of generating operators to our simulation code.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Instantiate Simulation\nfₘ = sim(sd, generate, DiagonalHodge())","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"With our simulation now ready, let's specify initial data to pass to it. We'll define them with plain Julia code.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The most interesting parameter here is our \"downhill gradient\" dX. This parameter defines how steep our slope is. Since our mesh is a circle, and we are setting dX to a constant value, this means that \"downhill\" always points counter-clockwise. Essentially, this is an elegant way of encoding an infinite hill.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Define Initial Conditions\nn_dist = Normal(pi)\nn = [pdf(n_dist, t)*(√(2pi))*7.2 + 0.08 - 5e-2 for t in range(0,2pi; length=ne(sd))]\n\nw_dist = Normal(pi, 20)\nw = [pdf(w_dist, t) for t in range(0,2pi; length=ne(sd))]\n\ndX = sd[:length]\n\nu₀ = ComponentArray(N = n, W = w, hydro_dX = dX)\n\ncs_ps = (phyto_m = 0.45,\n         hydro_a = 0.94,\n         hydro_ν = 182.5)","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's execute our simulation.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Run Simulation\ntₑ = 600.0\nprob = ODEProblem(fₘ, u₀, (0.0, tₑ), cs_ps)\nsol = solve(prob, Tsit5())\nsol.retcode","category":"page"},{"location":"klausmeier/#Animation","page":"Klausmeier","title":"Animation","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's perform some basic visualization and analysis of our results to verify our dynamics.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"n = sol(0).N\nnₑ = sol(tₑ).N\nw = sol(0).W\nwₑ = sol(tₑ).W # hide","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Animate dynamics\nfunction save_dynamics(form_name, framerate, filename)\n  time = Observable(0.0)\n  ys = @lift(getproperty(sol($time), form_name))\n  xcoords = [0, accumulate(+, sd[:length])[1:end-1]...]\n  fig = lines(xcoords, ys, color=:green, linewidth=4.0,\n    colorrange=extrema(getproperty(sol(0), form_name));\n    axis = (; title = @lift(\"Klausmeier $(String(form_name)) at $($time)\")))\n  timestamps = range(0, tₑ, step=1)\n  record(fig, filename, timestamps; framerate=framerate) do t\n    time[] = t\n  end\nend\nsave_dynamics(:N, 20, \"klausmeier.gif\")","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"(Image: Klausmeier)","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We can observe a few interesting phenomena that we wanted to capture:","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The vegetation density bands move uphill in traveling waves.\nThe leading edge of the waves is denser than the rest of the band.\nOver time, the periodicity of the vegetation bands stabilizes.\nThe distribution naturally emerges, despite the initial distribution is a simple normal distribution.\nThis is evidence against the real-world theory that these vegetation contours are the result of an initial (man-made) distribution.","category":"page"},{"location":"klausmeier/#Conclusion","page":"Klausmeier","title":"Conclusion","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Due to the ease of composition of Decapodes, representing the Klausmeier model opens up many areas for future work. For example, we can now compose these dynamics with a model of temperature dynamics informed by the Budyko-Sellers model. We can take advantage of the fact that the Lie derivative generalizes partial derivatives, and model the flow of water according to any vector field. Or, we can extend this model by composing it with a model that can recreate the so-called \"leopard pattern\" of vegetation, such as an \"Interaction-Dispersion\" model of vegetation dynamics given by Lejeune et al[4].","category":"page"},{"location":"klausmeier/#References","page":"Klausmeier","title":"References","text":"","category":"section"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[1] W. A. Macfadyen, “Vegetation Patterns in the Semi-Desert Plains of British Somaliland,” The Geographical Journal, vol. 116, no. 4/6, p. 199, Oct. 1950, doi: 10.2307/1789384.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[2] C. A. Klausmeier, “Regular and Irregular Patterns in Semiarid Vegetation,” Science, vol. 284, no. 5421, pp. 1826–1828, Jun. 1999, doi: 10.1126/science.284.5421.1826.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[3] W. A. Macfadyen, “Soil and Vegetation in British Somaliland,” Nature, vol. 165, no. 4186, Art. no. 4186, Jan. 1950, doi: 10.1038/165121a0.","category":"page"},{"location":"klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[4] O. Lejeune and M. Tlidi, “A Model for the Explanation of Vegetation Stripes (Tiger Bush),” Journal of Vegetation Science, vol. 10, no. 2, pp. 201–208, 1999, doi: 10.2307/3237141.","category":"page"},{"location":"grigoriev/#Halfar's-model-of-glacial-flow","page":"Grigoriev Ice Cap","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's run the Halfar shallow ice/ shallow slope model on some \"real world\" data for ice thickness. Van Tricht et al. in their 2023 communication Measuring and modelling the ice thickness of the Grigoriev ice cap (Kyrgyzstan) and comparison with global dataset published ice thickness data on an ice cap and stored their data in a TIF. In this document, we will demonstrate how to parse such data and execute a Decapodes model on these initial conditions.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"For the parameters to Glen's law, we will use those used in the Community Ice Sheet Model benchmark. Of course, the parameters of this Kyrgyzstani ice cap likely differ from these by quite some amount, but they are a good place to start. Further, this ice cap does not satisfy the \"shallow slope\" assumption across the entire domain.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\n\n# External Dependencies\nusing FileIO  \nusing Interpolations\nusing MLStyle\nusing ComponentArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing SparseArrays\nusing CairoMakie\nusing GeometryBasics: Point2\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}; # hide","category":"page"},{"location":"grigoriev/#Loading-a-Scientific-Dataset","page":"Grigoriev Ice Cap","title":"Loading a Scientific Dataset","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"The ice thickness data is stored in a TIF. We have downloaded it locally, and load it using basic FileIO.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"file_name = \"Icethickness_Grigoriev_ice_cap_2021.tif\"\nice_thickness_tif = load(file_name)","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"This data may appear to be a simple binary mask, but that is only because values with no ice are set to -Inf. We will account for this we interpolate our data.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"We use the Interpolations.jl library to interpolate this dataset:","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Taking the coordinates to be from the extrema of the measured points:\nconst MIN_X = 4648894.5\nconst MAX_X = 4652179.7\nconst MIN_Y = 243504.5\nconst MAX_Y = 245599.8\nice_coords = (range(MIN_X, MAX_X, length=size(ice_thickness_tif,1)),\n              range(MIN_Y, MAX_Y, length=size(ice_thickness_tif,2)))\n# Note that the tif is set to -floatmax(Float32) where there is no ice.\n# For our purposes, this is equivalent to 0.0.\nice_interp = LinearInterpolation(ice_coords, Float32.(ice_thickness_tif))","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"To use this interpolating object ice_interp, we can simply query it for the value at some coordinates: ice_interp(x,y).","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's generate a triangulated grid located at the appropriate coordinates:","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Specify a resolution:\nRES_Y = (MAX_Y-MIN_Y)/30.0\nRES_X = RES_Y\n# Generate the mesh with appropriate dimensions and resolution:\ns′ = triangulated_grid(\n                       MAX_X-MIN_X, MAX_Y-MIN_Y,\n                       RES_X, RES_Y, Point3D)\n# Shift it into place:\ns′[:point] = map(x -> x + Point3D(MIN_X, MIN_Y, 0), s′[:point])\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nwf = wireframe!(ax, s)\ndisplay(fig)","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"The coordinates of a vertex are stored in s[:point]. Let's use our interpolator to assign ice thickness values to each vertex in the mesh:","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# These are the values used by the CISM benchmark:\nn = 3\nρ = 910\ng = 9.8101\nA = fill(1e-16, ne(s))\n\nh₀ = map(s[:point]) do (x,y,_)\n  tif_val = ice_interp(x,y)\n  # Accommodate for the -∞'s that encode \"no ice\".\n  tif_val < 0.0 ? 0.0 : tif_val\nend\n\n# Store these values to be passed to the solver.\nu₀ = ComponentArray(h=h₀, stress_A=A)\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"grigoriev/#Defining-and-Composing-Models","page":"Grigoriev Ice Cap","title":"Defining and Composing Models","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"For exposition on this Halfar Decapode, see our Glacial Flow docs page. You can skip ahead to the next section.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form1\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯(d(h)))^(n-1)) * avg₀₁(h^(n+2)))\nend\n\nglens_law = @decapode begin\n  Γ::Form1\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(h,Γ,n)\n  stress(Γ,n)\nend\n\nice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:h,:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"grigoriev/#Define-our-functions","page":"Grigoriev Ice Cap","title":"Define our functions","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"include(\"sharp_op.jl\")\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  ♯_m = ♯_mat(sd)\n  I = Vector{Int64}()\n  J = Vector{Int64}()\n  V = Vector{Float64}()\n  for e in 1:ne(s)\n      append!(J, [s[e,:∂v0],s[e,:∂v1]])\n      append!(I, [e,e])\n      append!(V, [0.5, 0.5])\n  end\n  avg_mat = sparse(I,J,V)\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      ♯(sd, EForm(x))\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :abs => x -> abs.(x)\n    :show => x -> begin\n      println(x)\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"grigoriev/#Generate-simulation","page":"Grigoriev Ice Cap","title":"Generate simulation","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"sim = eval(gensim(ice_dynamics, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"grigoriev/#Run","page":"Grigoriev Ice Cap","title":"Run","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"tₑ = 1e1\n\n@info(\"Solving Grigoriev Ice Cap\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n@save \"grigoriev.jld2\" soln","category":"page"},{"location":"grigoriev/#Results-and-Discussion","page":"Grigoriev Ice Cap","title":"Results and Discussion","text":"","category":"section"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Visualize the initial conditions.\nfunction plot_ic()\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1],\n            title=\"Grigoriev Ice Cap Initial Thickness [m]\",\n            xticks = range(MIN_X, MAX_X; length=5),\n            yticks = range(MIN_Y, MAX_Y; length=5))\n  msh = mesh!(ax, s′, color=soln(0.0).h, colormap=:jet)\n  Colorbar(f[1,2], msh)\n  f\nend\nf = plot_ic()\nsave(\"grigoriev_ic.png\", f)\n\n# Visualize the final conditions.\nfunction plot_fc()\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1],\n            title=\"Grigoriev Ice Cap Final Thickness [m]\",\n            xticks = range(MIN_X, MAX_X; length=5),\n            yticks = range(MIN_Y, MAX_Y; length=5))\n  msh = mesh!(ax, s′, color=soln(tₑ).h, colormap=:jet)\n  Colorbar(f[1,2], msh)\n  f\nend\nf = plot_fc()\nsave(\"grigoriev_fc.png\", f)\n\n# Create a gif\nfunction save_dynamics(save_file_name)\n  time = Observable(0.0)\n  h = @lift(soln($time).h)\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1], title = @lift(\"Grigoriev Ice Cap Dynamic Thickness [m] at time $($time)\"))\n  gmsh = mesh!(ax, s′, color=h, colormap=:jet,\n               colorrange=extrema(soln(tₑ).h))\n  #Colorbar(f[1,2], gmsh, limits=extrema(soln(tₑ).h))\n  Colorbar(f[1,2], gmsh)\n  timestamps = range(0, tₑ, step=1e-1)\n  record(f, save_file_name, timestamps; framerate = 15) do t\n    time[] = t\n  end\nend\nsave_dynamics(\"grigoriev.gif\")","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"We observe the usual Halfar model phenomena of ice \"melting\". Note that since the \"shallow slope\" approximation does not hold on the boundaries (due to the so-called \"ice cliffs\" described in the Van Tricht et al. paper), we do not expect the \"creep\" effect to be physical in this region of the domain. Rather, the Halfar model's predictive power is tuned for the interiors of ice caps and glaciers. Note that we also assume here that the bedrock that the ice rests on is flat. We may in further documents demonstrate how to use topographic data from Digital Elevation Models to inform the elevation of points in the mesh itself.","category":"page"},{"location":"grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"(Image: Grigoriev_ICs) (Image: Grigoriev_FCs) (Image: Grigoriev_Dynamics)","category":"page"},{"location":"budyko_sellers_halfar/#Budko-Sellers-Halfar","page":"Budyko-Sellers-Halfar","title":"Budko-Sellers-Halfar","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"In this example, we will compose the Budyko-Sellers 1D energy balance model of the Earth's surface temperature with the Halfar model of glacial dynamics. Note that each of these components models is itself a composition of smaller physical models. In this walkthrough, we will compose them together using the same techniques.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\n\n# External Dependencies\nusing MLStyle\nusing ComponentArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing CairoMakie\nusing GeometryBasics: Point2\nPoint2D = Point2{Float64};","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We defined the Budyko-Sellers and Halfar models in example scripts (soon to be turned into Docs pages) in the examples/climate folder of the main repository. We recall them here.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"include(\"../../examples/climate/budyko_sellers.jl\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"include(\"../../examples/climate/shallow_ice.jl\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers = apex(budyko_sellers_cospan)\nhalfar = apex(ice_dynamics_cospan)\ntrue # hide","category":"page"},{"location":"budyko_sellers_halfar/#Budyko-Sellers","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"to_graphviz(budyko_sellers)","category":"page"},{"location":"budyko_sellers_halfar/#Halfar","page":"Budyko-Sellers-Halfar","title":"Halfar","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"to_graphviz(halfar)","category":"page"},{"location":"budyko_sellers_halfar/#Warming","page":"Budyko-Sellers-Halfar","title":"Warming","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"This is a formula that computes A for use in the Halfar glacial dynamics, given T from the Budyko-Sellers model.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# Tₛ(ϕ,t) := Surface temperature\n# A(ϕ) := Longwave emissions at 0°C\nwarming = @decapode begin\n  (Tₛ)::Form0\n  (A)::Form1\n\n  A == avg₀₁(5.8282*10^(-0.236 * Tₛ)*1.65e7)\n\nend\nto_graphviz(warming)","category":"page"},{"location":"budyko_sellers_halfar/#Composition","page":"Budyko-Sellers-Halfar","title":"Composition","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Observe that this composition technique is the same as that used in composing each of the Budyko-Sellers and Halfar models.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_composition_diagram = @relation () begin\n  budyko_sellers(Tₛ)\n\n  warming(A, Tₛ)\n\n  halfar(A)\nend\nto_graphviz(budyko_sellers_halfar_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We apply a composition by plugging in a Decapode for each component. We also specify the internal name of the variables to be used in combining.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_cospan = oapply(budyko_sellers_halfar_composition_diagram,\n  [Open(budyko_sellers, [:Tₛ]),\n   Open(warming, [:A, :Tₛ]),\n   Open(halfar, [:stress_A])])\nbudyko_sellers_halfar = apex(budyko_sellers_halfar_cospan)\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can perform type inference to determine what kind of differential form each of our variables are.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar = expand_operators(budyko_sellers_halfar)\ninfer_types!(budyko_sellers_halfar, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(budyko_sellers_halfar, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"budyko_sellers_halfar/#Defining-the-mesh","page":"Budyko-Sellers-Halfar","title":"Defining the mesh","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"These dynamics will occur on a 1-D manifold (a line). Points near +-π/2 will represent points near the North/ South poles. Points near 0 represent those at the equator.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"s′ = EmbeddedDeltaSet1D{Bool, Point2D}()\n#add_vertices!(s′, 30, point=Point2D.(range(-π/2 + π/32, π/2 - π/32, length=30), 0))\nadd_vertices!(s′, 100, point=Point2D.(range(-π/2 + π/32, π/2 - π/32, length=100), 0))\nadd_edges!(s′, 1:nv(s′)-1, 2:nv(s′))\norient!(s′)\ns = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s′)\nsubdivide_duals!(s, Circumcenter())","category":"page"},{"location":"budyko_sellers_halfar/#Define-input-data","page":"Budyko-Sellers-Halfar","title":"Define input data","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We need to supply initial conditions to our model. We create synthetic data here, although one may imagine that they could source this from their data repo of choice.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# This is a primal 0-form, with values at vertices.\ncosϕᵖ = map(x -> cos(x[1]), point(s′))\n# This is a dual 0-form, with values at edge centers.\ncosϕᵈ = map(edges(s′)) do e\n  (cos(point(s′, src(s′, e))[1]) + cos(point(s′, tgt(s′, e))[1])) / 2\nend\n\nα₀ = 0.354\nα₂ = 0.25\nα = map(point(s′)) do ϕ\n  α₀ + α₂*((1/2)*(3*ϕ[1]^2 - 1))\nend\nA = 210\nB = 2\nf = 0.70\nρ = 1025\ncw = 4186\nH = 70\nC = map(point(s′)) do ϕ\n  f * ρ * cw * H\nend\nD = 0.6\n\n# Isothermal initial conditions:\nTₛ₀ = map(point(s′)) do ϕ\n  15\nend\n\n# Visualize initial condition for temperature.\nlines(map(x -> x[1], point(s′)), Tₛ₀)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"n = 3\nρ = 910\ng = 9.8\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,_)\n  (((x)^2)+2.5) / 1e3\nend\n\n# Visualize initial condition for ice sheet height.\nlines(map(x -> x[1], point(s′)), h₀)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# Store these values to be passed to the solver.\nu₀ = ComponentArray(Tₛ=Tₛ₀,halfar_h=h₀)\n\nconstants_and_parameters = (\n  budyko_sellers_absorbed_radiation_α = α,\n  budyko_sellers_outgoing_radiation_A = A,\n  budyko_sellers_outgoing_radiation_B = B,\n  budyko_sellers_energy_C = C,\n  budyko_sellers_diffusion_D = D,\n  budyko_sellers_cosϕᵖ = cosϕᵖ,\n  budyko_sellers_diffusion_cosϕᵈ = cosϕᵈ,\n  halfar_n = n,\n  halfar_stress_ρ = ρ,\n  halfar_stress_g = g)","category":"page"},{"location":"budyko_sellers_halfar/#Symbols-to-functions","page":"Budyko-Sellers-Halfar","title":"Symbols to functions","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"The symbols along edges in our Decapode must be mapped to executable functions. In the Discrete Exterior Calculus, all our operators are defined as relations bewteen points, lines, and triangles on meshes known as simplicial sets. Thus, DEC operators are re-usable across any simplicial set.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"budyko_sellers_halfar/#Simulation-generation","page":"Budyko-Sellers-Halfar","title":"Simulation generation","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"From our Decapode, we automatically generate a finite difference method solver that performs explicit time-stepping to solve our system of multiphysics equations.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"sim = eval(gensim(budyko_sellers_halfar, dimension=1))\nfₘ = sim(s, generate)","category":"page"},{"location":"budyko_sellers_halfar/#Run-simulation","page":"Budyko-Sellers-Halfar","title":"Run simulation","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We wrap our simulator and initial conditions and solve them with the stability-detection and time-stepping methods provided by DifferentialEquations.jl .","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"tₑ = 1e6\n\n# Julia will pre-compile the generated simulation the first time it is run.\n@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-4), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can save the solution file to examine later.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"@save \"budyko_sellers_halfar.jld2\" soln","category":"page"},{"location":"budyko_sellers_halfar/#Visualize","page":"Budyko-Sellers-Halfar","title":"Visualize","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for temperature.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s′)), soln(tₑ).Tₛ)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for ice height.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s′)), soln(tₑ).halfar_h)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Create animated GIFs of the temperature and ice height dynamics.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"begin\n# Initial frame\nframes = 100\nfig = Figure(; size = (800, 800))\nax1 = CairoMakie.Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s′))))\nylims!(ax1, extrema(soln(tₑ).Tₛ))\nLabel(fig[1,1,Top()], \"Surface temperature, Tₛ, [C°]\")\nLabel(fig[2,1,Top()], \"Line plot of temperature from North to South pole, every $(tₑ/frames) time units\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_T.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s′)), soln(t).Tₛ)\nend\nend\n\nbegin\n# Initial frame\nframes = 100\nfig = Figure(; size = (800, 800))\nax1 = CairoMakie.Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s′))))\nylims!(ax1, extrema(soln(tₑ).halfar_h))\nLabel(fig[1,1,Top()], \"Ice height, h\")\nLabel(fig[2,1,Top()], \"Line plot of ice height from North to South pole, every $(tₑ/frames) time units\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_h.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s′)), soln(t).halfar_h)\nend\nend","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_Temperature)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_IceHeight)","category":"page"},{"location":"overview/#Introduction-to-Decapodes","page":"Overview","title":"Introduction to Decapodes","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (Decapodes) is a diagrammatic language used to express systems of ordinary and partial differential equations. The Decapode provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how Decapodes can be generated and interpreted.","category":"page"},{"location":"overview/#Your-First-Decapode","page":"Overview","title":"Your First Decapode","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin with the most basic Decapode, one which only includes a single variable. In the Decapode graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since the Decapode applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0 will be the 0-dimensional data points on some space, or in a discrete context, the values defined on points of a mesh. Similarly, Form1 will be values stored on edges of the mesh, and Form2 will be values stored on the surfaces of the mesh. Below, we provide a very simple Decapode with just a single variable C. and define a convenience function for visualization in later examples.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\nusing Catlab, Catlab.Graphics\n\nVariable = @decapode begin\n  C::Form0\nend;\n\nto_graphviz(Variable)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting diagram contains a single node, showing the single variable in this system. We can then add a second variable:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"TwoVariables = @decapode begin\n  C::Form0\n  dC::Form1\nend;\n\nto_graphviz(TwoVariables)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"And then can add some relationship between them. In this case, we make an equation which states that dC is the discrete derivative of C:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Equation = @decapode begin\n  C::Form0\n  dC::Form1\n\n  dC == d₀(C)\nend;\n\nto_graphviz(Equation)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the discrete derivative.","category":"page"},{"location":"overview/#A-Little-More-Complicated","page":"Overview","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  (C, Ċ)::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\nend;\n\nto_graphviz(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting Decapode shows the relationships between the three variables with the triangle diagram. Note that these diagrams are automatically layed-out by Graphviz.","category":"page"},{"location":"overview/#Bring-in-the-Dynamics","page":"Overview","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using DifferentialEquations.jl to handle time-stepping and instability detection).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin this process by importing a mesh. The mesh has been pre-generated within CombinatorialSpaces, and is generated such that it has periodic boundary conditions. We will also upload a non-periodic mesh for the sake of visualization, as well as a mapping between the points on the periodic and non-periodic meshes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See CombinatorialSpaces.jl for mesh construction and importing utilities.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\nperiodic_mesh = loadmesh(Torus_30x10())\npoint_map = loadmesh(Point_Map())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nwireframe!(ax, plot_mesh)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With the mesh uploaded, we also need to convert the Decapode into something which can be scheduled with explicit time stepping. In order to do this, we take every variable which is the time derivative of another variable and trace back the operations needed to compute this. This process essentially generates a computation graph in the form of a directed wiring diagram.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Since our diagram is already defined, we just need to define a function which implements each of these symbolic operators and pass them to a scheduler for generating the function.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that we chose to define k as a function that multiplies by a value k. We could have alternately chosen to represent k as a Constant that we multiply by in the Decapode itself.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using MLStyle\n\nfunction generate(sd, my_symbol; hodge=DiagonalHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we generate the simulation function using gen_sim and set up our initial conditions for this problem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"sim = eval(gensim(Diffusion))\nfₘ = sim(periodic_mesh, generate, DiagonalHodge())\n\nusing Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in periodic_mesh[:point]]\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nmesh!(ax, plot_mesh; color=c[point_map])\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we solve this PDE problem using the Tsit5() solver and generate an animation of the result!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing ComponentArrays\nusing OrdinaryDiffEq\n\nu₀ = ComponentArray(C=c)\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t).C[point_map] for t in times]\n\n# Initial frame\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, plot_mesh; color=colors[1], colorrange = extrema(vcat(colors...)))\nColorbar(fig[1,2], pmsh)\nframerate = 30\n\n# Animation\nrecord(fig, \"diffusion.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\n  pmsh.color = sol(t).C[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"overview/#Merging-Multiple-Physics","page":"Overview","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Form1\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, Ċ)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\nend\ntrue # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Advection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Superposition)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After this, the physics can be composed as follows:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Similar to before, this physics can be compiled and executed. Note that this process now requires another value to be defined, namely the velocity vector field. We do this using a custom operator called flat_op. This operator is basically the flat operator from CombinatorialSpaces.jl, but specialized to account for the periodic mesh.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We could instead represent the domain as the surface of an object with equivalent boundaries in 3D.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"function closest_point(p1, p2, dims)\n    p_res = collect(p2)\n    for i in 1:length(dims)\n        if dims[i] != Inf\n            p = p1[i] - p2[i]\n            f, n = modf(p / dims[i])\n            p_res[i] += dims[i] * n\n            if abs(f) > 0.5\n                p_res[i] += sign(f) * dims[i]\n            end\n        end\n    end\n    Point3{Float64}(p_res...)\nend\n\nfunction flat_op(s::AbstractDeltaDualComplex2D, X::AbstractVector; dims=[Inf, Inf, Inf])\n  tri_map = Dict{Int,Int}(triangle_center(s,t) => t for t in triangles(s))\n\n  map(edges(s)) do e\n    p = closest_point(point(s, tgt(s,e)), point(s, src(s,e)), dims)\n    e_vec = (point(s, tgt(s,e)) - p) * sign(1,s,e)\n    dual_edges = elementary_duals(1,s,e)\n    dual_lengths = dual_volume(1, s, dual_edges)\n    mapreduce(+, dual_edges, dual_lengths) do dual_e, dual_length\n      X_vec = X[tri_map[s[dual_e, :D_∂v0]]]\n      dual_length * dot(X_vec, e_vec)\n    end / sum(dual_lengths)\n  end\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing MLStyle\n\nfunction generate(sd, my_symbol; hodge=DiagonalHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    :∧₀₁ => (x,y) -> begin\n      ∧(Tuple{0,1}, sd, x,y)\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(periodic_mesh, generate, DiagonalHodge())\n\nvelocity(p) = [-0.5, -0.5, 0.0]\nv = flat_op(periodic_mesh, DualVectorField(velocity.(periodic_mesh[triangle_center(periodic_mesh),:dual_point])); dims=[30, 10, Inf])\n\nu₀ = ComponentArray(C=c,V=v)\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t).C[point_map] for t in times]\n\n# Initial frame\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, plot_mesh; color=colors[1], colorrange = extrema(vcat(colors...)))\nColorbar(fig[1,2], pmsh)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\n  pmsh.color = sol(t).C[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: ) ```","category":"page"},{"location":"ascii/#ASCII-and-Vector-Calculus-Operators","page":"ASCII Operators","title":"ASCII and Vector Calculus Operators","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Some users may have trouble entering unicode characters like ⋆ or ∂ in their development environment. So, we offer the following ASCII equivalents. Further, some users may like to use vector calculus symbols instead of exterior calculus symbols where possible. We offer support for such symbols as well.","category":"page"},{"location":"ascii/#ASCII-Equivalents","page":"ASCII Operators","title":"ASCII Equivalents","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Unicode ASCII Meaning\n∂ₜ dt derivative w.r.t. time\n⋆ star Hodge star, generalizing transpose\nΔ lapl laplacian\n∧ wedge wedge product, generalizing the cross product\n⋆⁻¹ star_inv Hodge star, generalizing transpose\n∘(⋆,d,⋆) div divergence, a.k.a. ∇⋅","category":"page"},{"location":"ascii/#Vector-Calculus-Equivalents","page":"ASCII Operators","title":"Vector Calculus Equivalents","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Vec DEC How to enter\ngrad d grad\ndiv ∘(⋆,d,⋆) div\ncurl ∘(d,⋆) curl\n∇ d \\nabla\n∇ᵈ ∘(⋆,d,⋆) \\nabla \\<tab\\> \\^d \\<tab\\>\n∇x ∘(d,⋆) \\nabla \\<tab\\> x\nadv(X,Y) ∘(⋆,d,⋆)(X∧Y) adv","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes are a graphical tool for the composition of physical systems. Ultimately, this library will include tooling which takes advantage of the formalization of physical theories described by DEC provided by CombinatorialSpaces.jl.","category":"page"},{"location":"#Getting-started","page":"Decapodes.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Walkthroughs creating, composing, and solving Decapodes are available in the side-bar of this documentation page. Further example scripts are avaiable in the examples folder of the Decapodes.jl GitHub repo, and will be added to this documentation site soon.","category":"page"},{"location":"#NOTE","page":"Decapodes.jl","title":"NOTE","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"This library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"},{"location":"poiseuille/#Poissuille-Flow-for-Fluid-Mechanics","page":"Pipe Flow","title":"Poissuille Flow for Fluid Mechanics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"When modeling a fluid flowing in a pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The noslip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using Catlab\nusing CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Decapodes\n\n# Julia community libraries\nusing CairoMakie\nusing GeometryBasics\nusing LinearAlgebra\nusing OrdinaryDiffEq","category":"page"},{"location":"poiseuille/#Creating-the-Poiseuille-Equations","page":"Pipe Flow","title":"Creating the Poiseuille Equations","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The @decapode macro creates the data structure representing the equations of Poiseuille flow. The first block declares variables, the second block defines intermediate terms and the last block is the core equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# μ̃ = negative viscosity per unit area\n# R = drag of pipe boundary\n\nPoise = @decapode begin\n  P::Form0\n  q::Form1\n  (R, μ̃ )::Constant\n\n  # Laplacian of q for the viscous effect\n  Δq == Δ(q)\n  # Gradient of P for the pressure driving force\n  ∇P == d(P)\n\n  # Definition of the time derivative of q\n  ∂ₜ(q) == q̇\n\n  # The core equation\n  q̇ == μ̃  * ∂q(Δq) + ∇P + R * q\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/#Defining-the-Semantics","page":"Pipe Flow","title":"Defining the Semantics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The generate function below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. ","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using MLStyle\ninclude(\"../../examples/boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :∂q => x -> begin\n      x[boundary_edges(sd)] .= 0\n      x\n    end\n    :∧₀₁ => (x,y) -> begin\n      ∧(0,1, sd, x,y)\n    end\n    :∂ρ => ρ -> begin\n      ρ[1] = 0\n      ρ[end] = 0\n      ρ\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"poiseuille/#A-Single-Pipe-Segment","page":"Pipe Flow","title":"A Single Pipe Segment","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We create a mesh with one pipe segment to see if we get the right answer. This simulation can be validated with the Poiseuille equation for a single pipe. First we create the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Point3D = Point3{Float64}\ns = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])\nadd_edge!(s, 1, 2, edge_orientation=true)\n\nsd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(sd, Circumcenter())\nsd","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using ComponentArrays\nsim = eval(gensim(Poise, dimension=1))\nfₘ = sim(sd, generate)\nq = [2.0]\nP = [10.0, 5.0]\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/#A-Linear-Pipe-with-Multiple-Segments","page":"Pipe Flow","title":"A Linear Pipe with Multiple Segments","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into n segments. First we define the mesh:","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\n\nsd = linear_pipe(10)\ntrue # hide","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Note that we do not generate new simulation code for Poiseuille flow with gensim again. We provide our new mesh so that our discrete differential operators can be instantiated.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nP = [9,8,7,6,5,4,3,2,1,0]\nq = [5,3,4,2,5,2,8,4,3]\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5());\nsol.u","category":"page"},{"location":"poiseuille/#A-Distribution-Network","page":"Pipe Flow","title":"A Distribution Network","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"To model a distribution network such as residential drinking water or natural gas, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function binary_pipe(depth::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertex!(s, point=Point3D(0, 0, 0))\n  for n in 1:depth\n    for prev_v in vertices(s)[end-2^(n-1)+1:end]\n      x, y, _ = s[:point][prev_v]\n      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)\n                                 for sgn in [1,-1]])\n      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)\n    end\n  end\n  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))\n  add_edge!(s, 1, v, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\nsd = binary_pipe(2)\ntrue # hide","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nP = collect(1.0:nv(sd))\nq = fill(5.0, ne(sd))\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/#Multiphysics","page":"Pipe Flow","title":"Multiphysics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow (q) and the pressure (P) to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The Decapode can be visualized with graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper [PBHF22]. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# μ̃ = negative viscosity per unit area\n# R = drag of pipe boundary\n# k = pressure as a function of density\nPoise = @decapode begin\n  q::Form1\n  (P, ρ)::Form0\n  (k, R, μ̃ )::Constant\n\n  # Poiseuille Flow\n  ∂ₜ(q) == q̇\n  ∇P == d(P)\n  q̇ == μ̃ * ∂q(Δ(q)) - ∇P + R * q\n  \n  # Pressure/Density Coupling\n  P == k * ρ\n  ∂ₜ(ρ) == ρ̇\n  ρ_up == ∘(⋆, d, ⋆)(-1 * ∧₀₁(ρ,q)) # advection\n  \n  # Boundary conditions\n  ρ̇ == ∂ρ(ρ_up)\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we can create the mesh and solve the equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"sd = linear_pipe(20)\n\nsim = eval(gensim(Poise, dimension=1))\nfunc = sim(sd, generate)\n\nq = [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5]\nρ = [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5,5]\nu = ComponentArray(q=q,ρ=ρ)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\n\nprob = ODEProblem(func, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Notice that the solution contains both a vector of flows and a vector of pressures.","category":"page"}]
}
