var documenterSearchIndex = {"docs":
[{"location":"concepts/meshes/#Mesh-Generation","page":"Meshes","title":"Mesh Generation","text":"","category":"section"},{"location":"concepts/meshes/","page":"Meshes","title":"Meshes","text":"For information on how to generate meshes, please consult the Meshes page of the CombinatorialSpaces.jl docs, and see the following examples:","category":"page"},{"location":"concepts/meshes/","page":"Meshes","title":"Meshes","text":"Imperative Grids\nImperative Spherical Meshes\nBy Gluing Triangles to the ACSet\nFrom an OBJ downloaded remotely\nFrom a serialized JSON ACSet","category":"page"},{"location":"pconv/porous_convection/#Porous-Convection","page":"Porous Convection","title":"Porous Convection","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"This Porous Convection model is based on the equations, constants and mesh structure given by ETH Zurich's course on Solving Partial Differential Equations in Parallel on GPUs Lecture 4.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"include(joinpath(Base.@__DIR__, \"..\" , \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"pconv/porous_convection/#Dependencies","page":"Porous Convection","title":"Dependencies","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"using CairoMakie\nusing Catlab\nusing CombinatorialSpaces\nusing ComponentArrays\nusing Decapodes\nusing DiagrammaticEquations\nusing Distributions\nusing GeometryBasics: Point2, Point3\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing SparseArrays\nusing StaticArrays\nusing StatsBase\n\nimport CombinatorialSpaces.DiscreteExteriorCalculus: eval_constant_primal_form","category":"page"},{"location":"pconv/porous_convection/#Porous-Convection-Decapode","page":"Porous Convection","title":"Porous Convection Decapode","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"The overall physics the model wishes to capture here are those of a fluid at different temperatures. Differences in the temperature of the fluid led to differences in the densities of that fluid which leads to convection of the fluid.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"To drive the convection, the model has a cooling element at the top and a heating element at the bottom of our mesh. To avoid the need to determine the density of the fluid, the Boussinesq approximation is used.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"The model generates a divergence-free pressure field by solving  Poisson's equation and the Darcy flux is a combination of the forces caused by pressure differences and buoyant forces. This Darcy flux leads to advection of the fluid and along with some heat diffusion, the overall change in temperature is captured.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Finer details of the physics can be found at the source listed above.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Porous_Convection = @decapode begin\n  (λ_ρ₀Cp, αρ₀, k_ηf, ϕ)::Constant\n  (P, T, Adv, bound_T, bound_Ṫ)::Form0\n  (g, qD)::Form1\n\n  bound_T == adiabatic(T)\n\n  # Darcy flux\n  ρ == g ∧ (αρ₀ * bound_T)\n  P == Δ⁻¹(δ(ρ))\n  qD == -k_ηf * (d(P) - ρ)\n\n  Adv == ⋆(interpolate(∧ᵈᵖ₁₁(⋆(d(bound_T)), qD)))\n  Ṫ == -1/ϕ * Adv + λ_ρ₀Cp * Δ(bound_T)\n\n  bound_Ṫ == tb_bc(Ṫ)\n\n  ∂ₜ(T) == bound_Ṫ\nend\ninfer_types!(Porous_Convection)\nresolve_overloads!(Porous_Convection)\nto_graphviz(Porous_Convection)","category":"page"},{"location":"pconv/porous_convection/#The-Mesh","page":"Porous Convection","title":"The Mesh","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Our mesh will be a triangulated grid mesh of width 40 units and height 20. We ues the circumcenter subdivision method as the triangulated grid's triangles are well-behaved and thus we can enjoy faster solve times.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"lx, ly = 40.0, 20.0\ndx = dy = 0.4\ns = triangulated_grid(lx, ly, dx, dy, Point3{Float64});\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point2{Float64}}(s);\nsubdivide_duals!(sd, Circumcenter());\n\nfig = Figure() # hide\nax = CairoMakie.Axis(fig[1,1], aspect=2) # hide\nwf = wireframe!(ax, s; linewidth=1) # hide\nresize_to_layout!(fig) # hide\nfig # hide","category":"page"},{"location":"pconv/porous_convection/#Operators-and-Boundary-Conditions","page":"Porous Convection","title":"Operators and Boundary Conditions","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"We set up our custom operators first. Since our system is fairly small, we can directly factorize our Laplacian to make solve the Poisson Equation fast and accurate.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"As you may have noticed, all of our data is located on the primal mesh, including our temperature. While this means we can keep the Darcy flux on the primal elements, the Lie derivative needs to compute the advection is slightly complicated now. However, we can employ interpolation to faithfully map data from primal to dual triangle elements to sidestep this problem. For fine enough meshes, the error in doing so in negligible.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Along with our operators, we implement adiabatic conditions on the side of our mesh as well as no-change conditions on the top/bottom of our mesh, where our cooling/heating elements reside. The adiabatic condition works by giving the boundary the values of the appropriate horizontal neighbor, which easy to do on the triangulated grid as its structure allows for easy lookup of this neighbor.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Δ0 = Δ(0,sd);\nfΔ0 = LinearAlgebra.factorize(Δ0);\n\nmat = p2_d2_interpolation(sd)\n\nleft_wall_idxs = findall(p -> p[1] < dx, s[:point]);\nright_wall_idxs = findall(p -> p[1] > lx - dx, s[:point]);\n\n# For adiabatic conditions:\nnext_left_wall_idxs = left_wall_idxs .+ 1;\nnext_right_wall_idxs = right_wall_idxs .- 1;\n\n# For no-change conditions\nbottom_wall_idxs= findall(p -> p[2] == 0, s[:point]);\ntop_wall_idxs = findall(p -> p[2] == ly, s[:point]);\n\napply_tb_bc(x) = begin x[bottom_wall_idxs] .= 0; x[top_wall_idxs] .= 0; return x; end\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :Δ⁻¹ => x -> begin\n      y = fΔ0 \\ x\n      # Constant changes in solution are valid\n      y .-= minimum(y)\n    end\n    :adiabatic => x -> begin\n      x[left_wall_idxs] .= x[next_left_wall_idxs]\n      x[right_wall_idxs] .= x[next_right_wall_idxs]\n      return x\n    end\n    :tb_bc => apply_tb_bc\n    :interpolate => x -> mat * x\n    _ => error(\"No operator $my_symbol found.\")\n  end\n  return op\nend\n\nsim = eval(gensim(Porous_Convection))\nf = sim(sd, generate, DiagonalHodge())\nnothing # hide","category":"page"},{"location":"pconv/porous_convection/#Initial-Conditions","page":"Porous Convection","title":"Initial Conditions","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"We set up a Gaussian heat disturbance at the center of our mesh to produce interesting convective behavior. We also set the cooling/heating elements.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"ΔT = 200.0\n\nT_dist = MvNormal([lx/2.0, ly/2.0], [1/sqrt(2), 1/sqrt(2)])\nT = [2 * ΔT * pdf(T_dist, [p[1], p[2]]) for p in sd[:point]]\nT[top_wall_idxs] .= -ΔT/2\nT[bottom_wall_idxs] .= ΔT/2\n\nfig = Figure() # hide\nax = CairoMakie.Axis(fig[1,1], aspect=2) # hide\nmsh = mesh!(ax, s; color = T, colormap=:jet, colorrange=(-ΔT/2, ΔT/2)) # hide\nColorbar(fig[1,2], msh) # hide\ncolsize!(fig.layout, 1, Aspect(1, 2.0)) # hide\nresize_to_layout!(fig) # hide\nfig # hide","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Since we depend on gravity to drive the convection, as this is why lower densities rise against higher densities, we define gravity as a force moving in the downward y-direction and use eval_constant_primal_form to generate the appropriate 1-Form to represent this force.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"Afterwards we establish a variety of physical constants.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"# Gravity\naccl_g = 9.81\ngrav = SVector{3}([0.0, -accl_g, 0.0])\ng = eval_constant_primal_form(sd, grav)\n\n# Physical constants\nRa = 750\nk_ηf = 1.0\nαρ₀ = (1.0/accl_g)\nϕ = 0.1\nλ_ρ₀Cp = 1/Ra*(accl_g*αρ₀*k_ηf*ΔT*ly/ϕ)\n\nu₀ = ComponentArray(T=T, g=g)\nconstants = (k_ηf = k_ηf, αρ₀ = αρ₀, ϕ = ϕ, λ_ρ₀Cp = λ_ρ₀Cp)","category":"page"},{"location":"pconv/porous_convection/#Solving-the-Porous-Convection-Equations","page":"Porous Convection","title":"Solving the Porous Convection Equations","text":"","category":"section"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"We simply plug in our initial conditions and generate simulation code and solve it using Tsit5(). Below is an output of the full simulation.","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"tₑ = 0.7\nprob = ODEProblem(f, u₀, (0, tₑ), constants)\nsoln = solve(prob, Tsit5(); saveat = 0.005)\nsoln.retcode","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"wdg10 = dec_wedge_product(Tuple{1, 0}, sd)\ncodif_1 = δ(1, sd)\nd0 = dec_differential(0, sd)\n\nhdg_1 = dec_hodge_star(1, sd)\ndp_wdg_11 = dec_wedge_product_dp(Tuple{1,1}, sd)\ninv_hdg_0 = dec_inv_hodge_star(0, sd)\n\nfunction calculate_pressure(T, constants)\n  fΔ0 \\ (codif_1 * wdg10(g, constants.αρ₀ * T))\nend\n\nfunction calculate_advection(T, P, constants)\n  darcy_flux = -constants.k_ηf * (d0 * P - wdg10(g, constants.αρ₀ * T))\n  apply_tb_bc(-1/constants.ϕ *  inv_hdg_0 * mat * dp_wdg_11(hdg_1 * d0 * T, darcy_flux))\nend\n\nfunction calculate_diffusion(T, constants)\n  apply_tb_bc(constants.λ_ρ₀Cp * Δ0 * T)\nend\n\nfunction compute_colorranges(length)\n  values = hcat(map(range(0, soln.t[end], length=length)) do t\n    T = soln(t).T\n    P = calculate_pressure(T, constants)\n    Adv = calculate_advection(T, P, constants)\n    Diff = calculate_diffusion(T, constants)\n\n    [minimum(P), maximum(P), minimum(Adv), maximum(Adv), minimum(Diff), maximum(Diff)]\n  end...)\n\n  percentile(values[1, :], 90), percentile(values[2, :], 90), # Pressure\n  percentile(values[3, :], 90), percentile(values[4, :], 90), # Advection\n  percentile(values[5, :], 75), percentile(values[6, :], 75) # Diffusion\nend\n\nfunction save_dynamics(save_file_name, video_length = 30)\n  time = Observable(0.0)\n\n  T = @lift(soln($time).T)\n  P = @lift(calculate_pressure($T, constants))\n  Adv = @lift(calculate_advection($T, $P, constants))\n  Diff = @lift(calculate_diffusion($T, constants))\n\n  colorranges = compute_colorranges(video_length)\n  P_range = colorranges[1], colorranges[2]\n  Adv_range = colorranges[3], colorranges[4]\n  Diff_range = colorranges[5], colorranges[6]\n\n  f = Figure()\n\n  ax_T = CairoMakie.Axis(f[1,1], title = @lift(\"Temperature at Time $(round($time, digits=3))\"))\n  msh_T = mesh!(ax_T, s; color=T, colormap=:jet, colorrange=(-ΔT/2, ΔT/2))\n  Colorbar(f[1,2], msh_T)\n\n  ax_P = CairoMakie.Axis(f[2,1], title = @lift(\"Pressure at Time $(round($time, digits=3))\"))\n  msh_P = mesh!(ax_P, s; color=P, colormap=:jet, colorrange=P_range)\n  Colorbar(f[2,2], msh_P)\n\n  ax_Adv = CairoMakie.Axis(f[1,3], title = @lift(\"Advection at Time $(round($time, digits=3))\"))\n  msh_Adv = mesh!(ax_Adv, s; color=Adv, colormap=:jet, colorrange=Adv_range)\n  Colorbar(f[1,4], msh_Adv)\n\n  ax_Diff = CairoMakie.Axis(f[2,3], title = @lift(\"Diffusion at Time $(round($time, digits=3))\"))\n  msh_Diff = mesh!(ax_Diff, s; color=Diff, colormap=:jet, colorrange=Diff_range)\n  Colorbar(f[2,4], msh_Diff)\n\n  timestamps = range(0, soln.t[end], length=video_length)\n  record(f, save_file_name, timestamps; framerate = 15) do t\n    time[] = t\n  end\nend","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"save_dynamics(\"Porous_Convection.mp4\", 120)","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"(Image: \"Porous Convection Result\")","category":"page"},{"location":"pconv/porous_convection/","page":"Porous Convection","title":"Porous Convection","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"EditURL = \"../../literate/mhd.jl\"","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"The model in this file is copied from the stream function formulation introduced here: https://algebraicjulia.github.io/Decapodes.jl/dev/navier_stokes/ns/ , but updated with terms representing β being advected by the fluid. The initial conditions setup code is copied outright.","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"The main reference used for developing this model is: \"Magnetohydrodynamics Simulation via Discrete Exterior Calculus\", Gillespie, M. https://markjgillespie.com/Research/MHD/MHDSimulationwith_DEC.pdf Note that the Gillespie paper does not use a stream function-vorticity formulation.","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"@info \"Loading Dependencies\"","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Dependencies can be installed with the following command:","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using Pkg","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Pkg.add([\"ACSets\", \"CairoMakie\", \"CombinatorialSpaces\", \"ComponentArrays\",   \"CoordRefSystems\", \"DiagrammaticEquations\", \"GeometryBasics\", \"JLD2\",   \"LinearAlgebra\", \"Logging\", \"LoggingExtras\", \"OrdinaryDiffEq\", \"SparseArrays\",   \"StaticArrays\", \"TerminalLoggers\"])","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Saving","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using JLD2","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"other dependencies","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using MLStyle\nusing Statistics: mean","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"AlgebraicJulia","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using ACSets\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Meshing","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using CoordRefSystems\nusing GeometryBasics: Point3\nPoint3D = Point3{Float64};\nnothing #hide","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Visualization","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using CairoMakie","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Simulation","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using ComponentArrays\nusing LinearAlgebra\nusing LinearAlgebra: factorize\nusing Logging: global_logger\nusing LoggingExtras\nusing OrdinaryDiffEq\nusing SparseArrays\nusing StaticArrays","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Saving","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using JLD2","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"other dependencies","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"using MLStyle\nusing Statistics: mean\n\n@info \"Defining models\"","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Beta is out-of-plane:","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"mhd_out_of_plane = @decapode begin\n    ψ::Form0\n    η::DualForm1\n    (dη,β)::DualForm2\n\n    ∂ₜ(dη) == -1*(∘(⋆₁, dual_d₁)((⋆(dη) ∧₀₁ ♭♯(η)) + (⋆(β) ∧₀₁ ♭♯(∘(⋆, d, ⋆)(β)))))\n    ∂ₜ(β) == -1*(∘(⋆₁, dual_d₁)(⋆(β) ∧₀₁ ♭♯(η)))\n\n    ψ == ∘(⋆, Δ⁻¹)(dη)\n    η == ⋆(d(ψ))\nend;\nnothing #hide","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Beta lies in-plane:","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"mhd = @decapode begin\n    ψ::Form0\n    (η,β)::DualForm1\n    dη::DualForm2\n\n    ∂ₜ(dη) == -1*(∘(⋆₁, dual_d₁)((⋆(dη) ∧₀₁ ♭♯(η)) + (♭♯(⋆(β)) ∧ᵈᵈ₁₀ ∘(⋆, d, ⋆)(β))))\n    ∂ₜ(β) == -1*(∘(⋆₂, dual_d₀)(⋆(β) ∧ᵖᵈ₁₁ η))\n\n    ψ == ∘(⋆, Δ⁻¹)(dη)\n    η == ⋆(d(ψ))\nend;\n\n@info \"Allocating Mesh and Operators\"\nconst RADIUS = 1.0;\nsphere = :ICO7;\ns = @match sphere begin\n    :ICO5 => loadmesh(Icosphere(4, RADIUS));\n    :ICO6 => loadmesh(Icosphere(6, RADIUS));\n    :ICO7 => loadmesh(Icosphere(7, RADIUS));\n    :ICO8 => loadmesh(Icosphere(8, RADIUS));\n    :flat => triangulated_grid(10, 10, 0.2, 0.2, Point3D)\n    :UV => begin\n        s, _, _ = makeSphere(0, 180, 2.5, 0, 360, 2.5, RADIUS);\n        s;\n    end\nend;\ndualmesh = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3D}(s);\nsubdivide_duals!(dualmesh, Circumcenter());\n\nΔ0 = Δ(0,dualmesh);\nfΔ0 = factorize(Δ0);\nd0 = dec_differential(0,dualmesh);\nd1 = dec_differential(1,dualmesh);\ndd0 = dec_dual_derivative(0,dualmesh);\ndd1 = dec_dual_derivative(1,dualmesh);\nδ1 = δ(1,dualmesh);\ns0 = dec_hodge_star(0,dualmesh,GeometricHodge());\ns1 = dec_hodge_star(1,dualmesh,GeometricHodge());\ns2 = dec_hodge_star(2, dualmesh);\ns0inv = dec_inv_hodge_star(0,dualmesh,GeometricHodge());\n♭♯_m = ♭♯_mat(dualmesh);\n\nfunction generate(dualmesh, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :Δ⁻¹ => x -> begin\n      y = fΔ0 \\ x\n      y .- minimum(y)\n    end\n    _ => default_dec_matrix_generate(dualmesh, my_symbol, hodge)\n  end\n  return (args...) -> op(args...)\nend;\n\nsim = evalsim(mhd);\nf = sim(dualmesh, generate);\n\nconstants_and_parameters = (μ = 0.001,)\n\n@info \"Setting Initial Conditions\"\n\n\"\"\"    function great_circle_dist(pnt,G,a,cntr)\nCompute the length of the shortest path along a sphere, given Cartesian coordinates.\n\"\"\"\nfunction great_circle_dist(pnt1::Point3D, pnt2::Point3D)\n  RADIUS * acos(dot(pnt1,pnt2))\nend\n\nabstract type AbstractVortexParams end\n\nstruct TaylorVortexParams <: AbstractVortexParams\n  G::Real\n  a::Real\nend\n\nstruct PointVortexParams <: AbstractVortexParams\n  τ::Real\n  a::Real\nend\n\n\"\"\"    function taylor_vortex(pnt::Point3D, cntr::Point3D, p::TaylorVortexParams)\nCompute the value of a Taylor vortex at the given point.\n\"\"\"\nfunction taylor_vortex(pnt::Point3D, cntr::Point3D, p::TaylorVortexParams)\n  gcd = great_circle_dist(pnt,cntr)\n  (p.G/p.a) * (2 - (gcd/p.a)^2) * exp(0.5 * (1 - (gcd/p.a)^2))\nend\n\n\"\"\"    function point_vortex(pnt::Point3D, cntr::Point3D, p::PointVortexParams)\nCompute the value of a smoothed point vortex at the given point.\n\"\"\"\nfunction point_vortex(pnt::Point3D, cntr::Point3D, p::PointVortexParams)\n  gcd = great_circle_dist(pnt,cntr)\n  p.τ / (cosh(3gcd/p.a)^2)\nend\n\ntaylor_vortex(dualmesh::HasDeltaSet, cntr::Point3D, p::TaylorVortexParams) =\n  map(x -> taylor_vortex(x, cntr, p), point(dualmesh))\npoint_vortex(dualmesh::HasDeltaSet, cntr::Point3D, p::PointVortexParams) =\n  map(x -> point_vortex(x, cntr, p), point(dualmesh))\n\n\"\"\"    function ring_centers(lat, n)\nFind n equispaced points at the given latitude.\n\"\"\"\nfunction ring_centers(lat, n)\n  ϕs = range(0.0, 2π; length=n+1)[1:n]\n  map(ϕs) do ϕ\n    v_sph = Spherical(RADIUS, lat, ϕ)\n    v_crt = convert(Cartesian, v_sph)\n    Point3D(v_crt.x.val, v_crt.y.val, v_crt.z.val)\n  end\nend\n\n\"\"\"    function vort_ring(lat, n_vorts, p::T, formula) where {T<:AbstractVortexParams}\nCompute vorticity as primal 0-forms for a ring of vortices.\nSpecify the latitude, number of vortices, and a formula for computing vortex strength centered at a point.\n\"\"\"\nfunction vort_ring(lat, n_vorts, p::T, formula) where {T<:AbstractVortexParams}\n  sum(map(x -> formula(dualmesh, x, p), ring_centers(lat, n_vorts)))\nend\n\n\"\"\"    function vort_ring(lat, n_vorts, p::PointVortexParams, formula)\nCompute vorticity as primal 0-forms for a ring of vortices.\nSpecify the latitude, number of vortices, and a formula for computing vortex strength centered at a point.\nAdditionally, place a counter-balance vortex at the South Pole such that the integral of vorticity is 0.\n\"\"\"\nfunction vort_ring(lat, n_vorts, p::PointVortexParams, formula)\n  Xs = sum(map(x -> formula(dualmesh, x, p), ring_centers(lat, n_vorts)))\n  Xsp = point_vortex(dualmesh, Point3D(0.0, 0.0, -1.0), PointVortexParams(-1*n_vorts*p.τ, p.a))\n  Xs + Xsp\nend","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Six equidistant points at latitude θ=0.4. \"... an additional vortex, with strength τ=-18 and a radius a=0.15, is placed at the south pole (θ=π).\"","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"X = vort_ring(0.4, 6, PointVortexParams(3.0, 0.15), point_vortex)\n\n\"\"\"    function solve_poisson(vort::VForm)\nCompute the stream function by solving the Poisson equation.\n\"\"\"\nfunction solve_poisson(vort::VForm)\n  ψ = fΔ0 \\ vort.data\n  ψ = ψ .- minimum(ψ)\nend\nsolve_poisson(vort::DualForm{2}) =\n  solve_poisson(VForm(s0inv * vort.data))\n\nψ = solve_poisson(VForm(X))","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Compute velocity as curl (⋆d) of the stream function.","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"curl_stream(ψ) = s1 * d0 * ψ\ndivergence(u) = s2 * d1 * (s1 \\ u)\nRMS(x) = √(mean(x' * x))\n\nintegral_of_curl(curl::DualForm{2}) = sum(curl.data)","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"Recall that s0 effectively multiplies each entry by a solid angle. i.e. (sum ∘ ⋆₀) computes a Riemann sum.","category":"page"},{"location":"examples/mhd/","page":"MHD","title":"MHD","text":"integral_of_curl(curl::VForm) = integral_of_curl(DualForm{2}(s0*curl.data))\n\nu₀ = ComponentArray(dη = s0*X, β = zeros(ne(dualmesh)))\n\nconstants_and_parameters = (μ = 0.0,)\n\n\n@info(\"Solving\")\ntₑ = 1.0;\n\nprob = ODEProblem(f, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob,\n  Tsit5(),\n  dtmax = 1e-3,\n  dense=false,\n  progress=true, progress_steps=1);\n\nfunction visualize_dynamics(file_name, soln)\n    time = Observable(0.0)\n    fig = Figure()\n    Label(fig[1, 1, Top()], @lift(\"...at $($time)\"), padding = (0, 0, 5, 0))\n    ax = CairoMakie.Axis(fig[1,1])\n    msh = CairoMakie.mesh!(ax, s,\n      color=@lift(s0inv*soln($time).dη),\n      colormap=Reverse(:redsblues))\n    Colorbar(fig[1,2], msh)\n    record(fig, file_name, soln.t[1:10:end]; framerate = 10) do t\n      time[] = t\n    end\nend\nvisualize_dynamics(\"mhd.mp4\", soln)","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"using Decapodes\nimport MLStyle: @match","category":"page"},{"location":"concepts/generate/#Custom-Operators","page":"Custom Operators","title":"Custom Operators","text":"","category":"section"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"Decapodes.jl already defines a suite of operators from the Discrete Exterior Calculus. However it is often the case that an implementation requires custom operators. Sometimes, this is just matter of building operators through composition, however Decapodes accepts a lookup table of functions which are included when parsing a Decapodes expression. This allows for new operators with their own symbols to be defined.","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"On this page, we will give an overview of the Decapodes generate function. ","category":"page"},{"location":"concepts/generate/#The-generate-function","page":"Custom Operators","title":"The generate function","text":"","category":"section"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"The gensim function optionally accepts a callable object like a function to act as a lookup table for new operators. In general practice, this function is called generate, but this is not necessary. It just requires as arguments the dual mesh dualmesh, the function symbol, and optionally the hodge operator.","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"Let's examine this generate function from the MHD example. Here this system introduces two operators, an inverse Laplacian and a flat-sharp operator. ","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"function generate(dualmesh, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :Δ⁻¹ => x -> begin\n      y = fΔ0 \\ x\n      y .- minimum(y)\n    end\n    :♭♯ => x -> ♭♯_m * x\n    _ => default_dec_matrix_generate(dualmesh, my_symbol, hodge)\n  end\n  return (args...) -> op(args...)\nend;","category":"page"},{"location":"concepts/generate/#Composing-Operators","page":"Custom Operators","title":"Composing Operators","text":"","category":"section"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"Decapodes uses the Discrete Exterior Calculus to discretize our differential operators. The DEC is an elegant way of building up more complex differential operators from simpler ones. To demonstrate, we will define the Δ operator by building it up with matrix multiplication of simpler operators. Since most operators in the DEC are matrices, most simulations consist mainly of matrix-vector multiplications, and are thus very fast.","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"If this code seems too low level, do not worry. Decapodes defines and caches for you many differential operators behind the scenes, so you do not have to worry about defining your own.","category":"page"},{"location":"concepts/generate/","page":"Custom Operators","title":"Custom Operators","text":"lap_mat = dec_hodge_star(1,dualmesh) * dec_differential(0,dualmesh) * dec_inv_hodge_star(0,dualmesh) * dec_dual_derivative(0,dualmesh)\n\nfunction generate(dualmesh, my_symbol; hodge=DiagonalHodge())\n  op = @match my_symbol begin\n    :Δ => x -> begin\n      lap_mat * x\n    end\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"fokker_planck/fokker_planck/#Fokker-Planck","page":"Fokker-Planck","title":"Fokker-Planck","text":"","category":"section"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"using Catlab, CombinatorialSpaces, Decapodes, DiagrammaticEquations\nusing CairoMakie, ComponentArrays, LinearAlgebra, MLStyle, ComponentArrays\nusing OrdinaryDiffEq\nusing GeometryBasics: Point3\nPoint3D = Point3{Float64}\nusing Arpack","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Let's specify physics","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Fokker_Planck = @decapode begin\n  (ρ,Ψ)::Form0\n  β⁻¹::Constant\n  ∂ₜ(ρ) == ∘(⋆,d,⋆)(d(Ψ)∧ρ) + β⁻¹*Δ(ρ)\nend","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Specify the domain","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"spheremesh = loadmesh(Icosphere(6))\ndualmesh = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(spheremesh);\nsubdivide_duals!(dualmesh, Barycenter())","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Compile the simulation","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"simulation = eval(gensim(Fokker_Planck))\nf = simulation(dualmesh, nothing)","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Specify initial conditions. Ψ must be a smooth function. Choose an interesting eigenfunction. We require that ρ integrated over the surface is 1, since it is a PDF. On a sphere where ρ(x,y,z) is proportional to the x-coordinate, that means divide by 2π.","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Δ0 = Δ(0, dualmesh)\nΨ = real.(eigs(Δ0, nev=32, which=:LR)[2][:,32])\nρ = map(point(dualmesh)) do (x,y,z)\n  abs(x)\nend / 2π","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Let's define the structures which hold the constants and state variables for the simulation, respectively.","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"constants_and_parameters = (β⁻¹ = 1e-2,)\nu0 = ComponentArray(Ψ=Ψ, ρ=ρ)","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Run the simulation.","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"tₑ= 20.0\nproblem = ODEProblem(f, u0, (0, tₑ), constants_and_parameters);\nsolution = solve(problem, Tsit5(), progress=true, progress_steps=1);","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Verify that the probability distribbution function is still a probability distribution. We'll show that the sum of the values on the dual 2-form integrate (sum to) unity,","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"s0 = dec_hodge_star(0, dualmesh)\n@info sum(s0 * solution(tₑ).ρ)\n@info any(solution(tₑ).ρ .≤ 0)","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"Now we will create a GIF.","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"function save_gif(file_name, soln)\n  time = Observable(0.0)\n  fig = Figure()\n  Label(fig[1, 1, Top()], @lift(\"ρ at $($time)\"), padding = (0, 0, 5, 0))\n  ax = LScene(fig[1,1], scenekw=(lights=[],))\n  msh = CairoMakie.mesh!(ax, spheremesh,\n    color=@lift(soln($time).ρ),\n    colorrange=(0,1),\n    colormap=:jet)\n\n  Colorbar(fig[1,2], msh)\n  frames = range(0.0, tₑ; length=21)\n  record(fig, file_name, frames; framerate = 10) do t\n    time[] = t\n  end\nend\ngif = save_gif(\"fokker_planck.gif\", solution)","category":"page"},{"location":"fokker_planck/fokker_planck/","page":"Fokker-Planck","title":"Fokker-Planck","text":"(Image: \"FokkerPlanck\")","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"EditURL = \"../../../literate/chemistry/gray_scott.jl\"","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"using Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\nusing MLStyle\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing CairoMakie\nimport CairoMakie: wireframe, mesh, Figure, Axis\nusing ComponentArrays\n\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"We use the model equations as stated here: https://github.com/JuliaParallel/julia-hpc-tutorial-sc24/blob/main/parts/gpu/gray-scott.ipynb Initial conditions were based off those given here: https://itp.uni-frankfurt.de/~gros/StudentProjects/Projects2020/projektschulz_kaefer/#header","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"GrayScott = @decapode begin\n  (U, V)::Form0\n  (UV2)::Form0\n  (U̇, V̇)::Form0\n  (f, k, rᵤ, rᵥ)::Constant\n  B::Constant\n\n  UV2 == (U .* (V .* V))\n  lap_U == mask(Δ(U), B)\n  lap_V == mask(Δ(V), B)\n\n  U̇ == rᵤ * lap_U - UV2 + f * (1 .- U)\n  V̇ == rᵥ * lap_V + UV2 - (f + k) .* V\n  ∂ₜ(U) == U̇\n  ∂ₜ(V) == V̇\nend\n\nn = 100\nh = 1\n\ns = triangulated_grid(n,n,h,h,Point3D);\nsd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point2D}(s);\nsubdivide_duals!(sd, Circumcenter());\n\nsim = eval(gensim(GrayScott))\n\nleft_wall_idxs = findall(x -> x[1] <= h, s[:point])\nright_wall_idxs = findall(x -> x[1] >= n - h, s[:point])\ntop_wall_idxs = findall(y -> y[2] == 0.0, s[:point])\nbot_wall_idxs = findall(y -> y[2] == n, s[:point])\n\nwall_idxs = unique(vcat(left_wall_idxs, right_wall_idxs, top_wall_idxs, bot_wall_idxs))\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :mask => (x,y) -> begin\n      x[wall_idxs] .= y\n      x\n    end\n    _ => error(\"Unmatched operator $my_symbol\")\n  end\nend\n\nfₘ = sim(sd, generate, DiagonalHodge())\n\ninit_multi = 0.5\n\nU = rand(0.0:0.001:0.1, nv(sd))\nV = zeros(nv(sd))\n\nmid = div(n, 2)\n\nmid_p = Point2D(mid, mid)\n\ninit = map(p -> if norm(p - mid_p, Inf) <= 5; 1.0 .* init_multi; else 0.0; end, sd[:point])","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"Set up an initial small disturbance","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"U .+= init\nV .+= 0.5 * init\n\nu₀ = ComponentArray(U=U,V=V)\n\nf = 0.055\nk = 0.062\nconstants_and_parameters = (\n  rᵤ = 0.16,\n  rᵥ = 0.08,\n  f = f,\n  k = k,\n  B = 0)","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"fig = Figure(); ax = CairoMakie.Axis(fig[1,1], aspect=1, title = \"Initial value of U\") msh = CairoMakie.mesh!(ax, s, color=U, colormap=:jet, colorrange=(extrema(U))) Colorbar(fig[1,2], msh) display(fig)","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"fig = Figure() ax = CairoMakie.Axis(fig[1,1], aspect=1, title = \"Initial value of V\") # hide msh = CairoMakie.mesh!(ax, s, color=V, colormap=:jet, colorrange=extrema(V)) # hide Colorbar(fig[1,2], msh) fig","category":"page"},{"location":"examples/chemistry/gray_scott/","page":"Gray-Scott","title":"Gray-Scott","text":"tₑ = 10_000\n\n@info(\"Solving\")\nproblem = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsolution = solve(problem, Tsit5())\n@info(\"Done\")\n\nfunction save_dynamics(save_file_name)\n  time = Observable(0.0)\n  u = @lift(solution($time).U)\n  f = Figure()\n  ax_U = CairoMakie.Axis(f[1,1], title = @lift(\"Concentration of U at Time $($time)\"))\n\n  msh_U = mesh!(ax_U, s, color=u, colormap=:jet, colorrange=(0, 1.1))\n  Colorbar(f[1,2], msh_U)\n\n  timestamps = range(0, tₑ, step=50)\n  record(f, save_file_name, timestamps; framerate = 30) do t\n    time[] = t\n  end\nend\n\nsave_dynamics(\"gs_f=$(f)_k=$(k).mp4\")","category":"page"},{"location":"bc/bc_debug/#Simulation-Setup","page":"Misc Features","title":"Simulation Setup","text":"","category":"section"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"This tutorial showcases some of the other features included in the Decapodes.jl package. Currently, these features are the treatment of boundary conditions and the simulation debugger interface. To begin, we set up the same advection-diffusion problem presented in the Overview section. As before, we define the Diffusion, Advection, and Superposition components, and now include a Boundary Condition (BC) component. By convention, BCs are encoded in Decapodes by using a ∂ symbol. Below we show the graphical rendering of this boundary condition diagram, which we will use to impose a Dirichlet condition on the time derivative of concentration at the mesh boundary.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Catlab\nusing DiagrammaticEquations\nusing Decapodes\n\nDiffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Constant\n\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, C_up)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  C_up == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\nend\n\nBoundaryConditions = @decapode begin\n  (C, C_up)::Form0\n\n  # Temporal boundary\n  ∂ₜ(C) == Ċ\n\n  # Spatial boundary\n  Ċ == ∂C(C_up)\nend\n\nto_graphviz(BoundaryConditions)","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"As before, we compose these physics components over our wiring diagram.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  bc(C, C_up)\n  superposition(ϕ₁, ϕ₂, ϕ, C_up, C)\nend\n\ndraw_composition(compose_diff_adv)","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(BoundaryConditions, [:C, :C_up]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C_up, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"When this is scheduled, Decapodes will apply any boundary conditions immediately after the impacted value is computed. This implementation choice ensures that this boundary condition holds true for any variables dependent on this variable, though also means that the boundary conditions on a variable have no immediate impact on the variables this variable is dependent on.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"In the visualization below, we see that the final operation executed on the data is the boundary condition we are enforcing on the change in concentration.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"to_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"Next we import the mesh we will use. In this case, we are wanting to impose boundary conditions and so we will use the plot_mesh from the previous example instead of the mesh with periodic boundary conditions. Because the mesh is only a primal mesh, we also generate and subdivide the dual mesh.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"using CombinatorialSpaces\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\n\n# Generate the dual mesh\nplot_mesh_dual = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(plot_mesh)\n\n# Calculate distances and subdivisions for the dual mesh\nsubdivide_duals!(plot_mesh_dual, Circumcenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nwireframe!(ax, plot_mesh)\nfig","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"Finally, we define our operators, generate the simulation function, and compute the simulation. Note that when we define the boundary condition operator, we hardcode the boundary indices and values into the operator itself. We also move the initial concentration to the left, so that we are able to see a constant concentration on the left boundary which will act as a source in the flow. You can find the file for boundary conditions here. The modified initial condition is shown below:","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"using LinearAlgebra\nusing ComponentArrays\nusing MLStyle\ninclude(\"../boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    :∂C => x -> begin\n      boundary = boundary_inds(Val{0}, sd)\n      x[boundary] .= 0\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return op\nend\n\nusing Distributions\nc_dist = MvNormal([1, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in plot_mesh_dual[:point]]\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nmesh!(ax, plot_mesh; color=c[1:nv(plot_mesh)])\nfig","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"And the simulation result is then computed and visualized below.","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"using OrdinaryDiffEq\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(plot_mesh_dual, generate)\n\nvelocity(p) = [-0.5, 0.0, 0.0]\nv = ♭(plot_mesh_dual, DualVectorField(velocity.(plot_mesh_dual[triangle_center(plot_mesh_dual),:dual_point]))).data\n\nu₀ = ComponentArray(C=c)\nparams = (V = v,)\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0), params)\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t).C for t in times]\nextrema\n# Initial frame\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, plot_mesh; color=colors[1], colorrange = extrema(vcat(colors...)))\nColorbar(fig[1,2], pmsh)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv_right.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\n  pmsh.color = sol(t).C\nend","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"(Image: Diffusion-Advection result and your first BC Decapode!)","category":"page"},{"location":"bc/bc_debug/","page":"Misc Features","title":"Misc Features","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"faq/faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/faq/#1.-How-do-I-incorporate-scalar-or-vector-field-input-data-where-you-have-a-function-of-the-embedded-coordinates?","page":"FAQ","title":"1. How do I incorporate scalar or vector field input data where you have a function of the embedded coordinates?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"We can take a look at the Brusselator page which sets the values of each point on its mesh to a value as determined by some function. This can be done in a similar manner in both 1D and 2D. ","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"The Brusselator also demonstrates, with the variable F, how one can go about changing the function by which these values are set over time.","category":"page"},{"location":"faq/faq/#2.-How-do-I-incorporate-input-data-from-a-file-with-linear-interpolation?","page":"FAQ","title":"2. How do I incorporate input data from a file with linear interpolation?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"The Grigoriev Ice Cap model has a section where after the initial data is loaded from a TIF and the data is interpolated so that it may fit over a discrete mesh of our choosing. You may view that here.","category":"page"},{"location":"faq/faq/#3.-How-do-I-set-boundary-conditions-like-fixed-value,-no-flux,-and-no-slip?","page":"FAQ","title":"3. How do I set boundary conditions like fixed value, no-flux, and no-slip?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"Boundary conditions can be set by using \"collages\", which can take two variables among two different Decapodes and apply a function on the first. ","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"A general workflow would be to have the first Decapode encode the physics and have a second Decapode encode values for the boundary conditions. They can be related by a function that will mask the first variable and replace the desired values with those of the second's. An example of applying fixed boundary conditions would be in the Brusselator page.","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"A similar workflow can be used for \"no-flux\" and \"no-slip\" conditions by fixing the value of the appropriate variable to be 0. ","category":"page"},{"location":"faq/faq/#4.-How-do-I-plot-derived-quantities?","page":"FAQ","title":"4. How do I plot derived quantities?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"Plotting in DECAPODES is commonly done with the Makie package in Julia. Makie allows for creating both still images, which are useful for visualizing the mesh itself and initial/final conditions, and videos, which can capture the full simulation from start to end.","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"For 1D visualization\nFor 2D visualization\nFor 3D visualization","category":"page"},{"location":"faq/faq/#5.-How-do-I-add-artificial-diffusion-for-0-or-1-forms?","page":"FAQ","title":"5. How do I add artificial diffusion for 0- or 1-forms?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"Without viscosity - i.e. when μ = 0 - the incompressible (inviscid) Navier-Stokes equations can be formulated like so:","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"eq11_inviscid_poisson = @decapode begin\n  d𝐮::DualForm2\n  𝐮::DualForm1\n  ψ::Form0\n\n  ψ == Δ⁻¹(⋆(d𝐮))\n  𝐮 == ⋆(d(ψ))\n\n  ∂ₜ(d𝐮) ==  (-1) * ∘(♭♯, ⋆₁, d̃₁)(∧ᵈᵖ₁₀(𝐮, ⋆(d𝐮)))\nend","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"Adding a viscosity term can be accomplished by simply added the appropriate term, and declaring the μ constant:","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"eq11_viscid_poisson = @decapode begin\n  d𝐮::DualForm2\n  𝐮::DualForm1\n  ψ::Form0\n  μ::Constant\n\n  ψ == Δ⁻¹(⋆(d𝐮))\n  𝐮 == ⋆(d(ψ))\n\n  ∂ₜ(d𝐮) ==  μ * ∘(⋆, d, ⋆, d)(d𝐮) + (-1) * ∘(♭♯, ⋆₁, d̃₁)(∧ᵈᵖ₁₀(𝐮, ⋆(d𝐮)))\nend","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"More demonstrations on how to iterate between formulations of the same physics (the incompressible Navier-Stokes equations) is available in further detail on the Vortices docs page and in the script available there.","category":"page"},{"location":"faq/faq/#6.-How-do-I-use-multigrid-methods?","page":"FAQ","title":"6. How do I use multigrid methods?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"To use multigrid methods in the Laplacian solver, you need to create a PrimalGeometricMapSeries that will take a coarse mesh and apply a subdivision method to it some number of times. After that, just use this result as you would a regular mesh for simulation.","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"s = triangulated_grid(100,100,10,10,Point3D)\n\n# Binary subdivide 4 times\nseries = PrimalGeometricMapSeries(s, binary_subdivision_map, 4);\n\n# Retrieve highest resolution mesh\nsd = finest_mesh(series)\n\n  ...\n\nf_mg = sim_mg(series, generate);","category":"page"},{"location":"faq/faq/#7.-What-are-general-workflows-for-DECAPODES?","page":"FAQ","title":"7. What are general workflows for DECAPODES?","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"A common workflow is to iterate through multiple different models as is done in the Vorticity Model page. A formulation is first done with a direct vorticity formulation but a quick run finds that this setup is unstable. A second formulation introduces a Laplacian solve which produces nice results.","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"Similar workflows may retain the same model but may iterate on the types of meshes/initial conditions used. An excellent example of this is found in the Glacial Flow page where the model is first run in a 1D setting and then quickly promoted to both 2D and 3D. This allows either running some dynamics in a more complicated setting, as just discussed, or allows for simplifying higher dimensional models by some sort of symmetry.","category":"page"},{"location":"faq/faq/#Troubleshooting","page":"FAQ","title":"Troubleshooting","text":"","category":"section"},{"location":"faq/faq/#Debugging-Generated-Simulations","page":"FAQ","title":"Debugging Generated Simulations","text":"","category":"section"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"The Decapodes workflow requires generating the simulation function by evaluating the output of gensim. However this simulation code can be saved to a file and edited directly, allowing for full control over the simulation. By this same token, reading the simulation code from a file allows for line numbers to be associated to buggy lines!","category":"page"},{"location":"faq/faq/","page":"FAQ","title":"FAQ","text":"open(\"filename.jl\" \"w\") do f\n    write(f, string(gensim(your_decapode)))\nend\nsimulator = include(\"filename.jl\")","category":"page"},{"location":"navier_stokes/ns/#Navier-Stokes-Vorticity-Model","page":"Vortices","title":"Navier Stokes Vorticity Model","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Rotating point vortices)","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Repelling Taylor vortices)","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"This docs page demonstrates a discretization of the invisicd incompressible Navier Stokes equations using the Discrete Exterior Calculus.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"The formulations are based on those given by Mohamed, Hirani, Samtaney (in turn from Marsden, Ratiu, Abraham).","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"However, a new discretization is produced for purposes of brevity, to demonstrate novel discretizations of certain operators, and to demonstrate the automated Decapodes workflow.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"The full code that generated these results is available in a julia script.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"Let's first demonstrate an (incorrect) formulation of the equations to demonstrate how one can iteratively develop a Decapodes model. This is intended to show how easy it is to edit a Decapodes model to improve the quality of the physical formulation.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"This approach can be combined with the multiphysics described in other pages to improve the quality of other fluid mechanics simulations.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"An initial attempt at solving the vorticity formulation of the inviscid incompressible Navier-Stokes momentum equation could be:","category":"page"},{"location":"navier_stokes/ns/#Vorticity-Formulation-(Incorrect)","page":"Vortices","title":"Vorticity Formulation (Incorrect)","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"eq11_incorrect = @decapode begin\n  d𝐮::DualForm2\n  𝐮::DualForm1\n\n  𝐮 == d₁⁻¹(d𝐮)\n\n  ∂ₜ(d𝐮) ==  (-1) * ∘(♭♯, ⋆₁, d̃₁)(∧ᵈᵖ₁₀(𝐮, ⋆(d𝐮)))\nend\nnothing # hide","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"This incorrect formulation does not use a stream function, but rather tries to compute the velocity field via a linear solve of the exterior derivative d₁. In other words, the velocity field is computed as the pseudo-inverse of the differential operation that computes curl.","category":"page"},{"location":"navier_stokes/ns/#Initial-Conditions","page":"Vortices","title":"Initial Conditions","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"We can check these dynamics on a couple of test cases on the sphere with well-known analytic solutions. In the case of dual Taylor vortices, we expect the vortices to repel one another, and in the case of a ring of (smoothed) point vortices, we should expect the vortices to rotate along the initial line of latitude. See \"Wave and vortex dynamics on the surface of a sphere\" (1993) from Polvani and Dritschel for analysis.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"The following plots are shown from directly above the north pole of the sphere.","category":"page"},{"location":"navier_stokes/ns/#Point-Vortices","page":"Vortices","title":"Point Vortices","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Plot of point Vortex initial conditions)","category":"page"},{"location":"navier_stokes/ns/#Taylor-Vortices","page":"Vortices","title":"Taylor Vortices","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Plot of Taylor Vortex initial conditions)","category":"page"},{"location":"navier_stokes/ns/#Numerical-Solutions-(Incorrect-Formulation)","page":"Vortices","title":"Numerical Solutions (Incorrect Formulation)","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"This formulation is very unstable for both sets of initial conditions, failing approximately 0.4% of the way into the simulation.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"max u=NaN\n│   progress = 0.004\n└ @ OrdinaryDiffEqCore /blue/fairbanksj/luke.morris/julia/packages/OrdinaryDiffEqCore/H25Bn/src/integrators/integrator_utils.jl:283\n┌ Warning: Instability detected. Aborting","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"max u=NaN\n│   progress = 0.005\n└ @ OrdinaryDiffEqCore /blue/fairbanksj/luke.morris/julia/packages/OrdinaryDiffEqCore/H25Bn/src/integrators/integrator_utils.jl:283\n┌ Warning: Instability detected. Aborting","category":"page"},{"location":"navier_stokes/ns/#Stream-Function-/-Poisson-Problem-Formulation-(Correct)","page":"Vortices","title":"Stream Function / Poisson Problem Formulation (Correct)","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"There are cohomological reasons why the above model formulation produces low-quality simulations. The variable of interest is physically required to be in the kernel of Delta, but that isn't guaranteed by the model formulation above. To fix this, you can use the solve for the stream function by introducing a Laplacian solve as part of the update law.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"Due to the equation du = -Deltapsi we can solve for the stream function with a linear solve of the Laplacian.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"This transformation can be implemented by editing the Decapode formulation and regenerating the simulator.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"eq11_inviscid_poisson = @decapode begin\n  d𝐮::DualForm2\n  𝐮::DualForm1\n  ψ::Form0\n\n  ψ == Δ⁻¹(⋆(d𝐮))\n  𝐮 == ⋆(d(ψ))\n\n  ∂ₜ(d𝐮) ==  (-1) * ∘(♭♯, ⋆₁, d̃₁)(∧ᵈᵖ₁₀(𝐮, ⋆(d𝐮)))\nend","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"With this formulation, we achieve these numerical results:","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Rotating point vortices)","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Repelling Taylor vortices)","category":"page"},{"location":"navier_stokes/ns/#Phenominological-Assessment","page":"Vortices","title":"Phenominological Assessment","text":"","category":"section"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"These scenarios are used to test that a simulator achieves the correct phenomenology. In the rotating point vortices case, we are looking for periodicity in the solution for vorticity. As the vortices advect around the sphere, they return to their original locations. This can be seen on the azimuthal profile. The original formulation does not exhibit this phenomenon, since it is unstable, but the corrected formulation does.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"We can visualize the distribution of vorticity at the theta = 04 latitude. The difference between the distributions at t=0 and t=12 is accumulated error.","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"(Image: Azimuthal profile)","category":"page"},{"location":"navier_stokes/ns/","page":"Vortices","title":"Vortices","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"ebm_melt/ebm_melt/#Halfar-EBM-Water","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"This docs page demonsrates a composition of the Halfar model of ice dynamics with the Budyko-Sellers energy-balance model (EBM) defining temperature dynamics. Surface temperature affects the rate at which ice diffuses, and melts ice into a water density term. This water density then diffuses across the domain.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"We execute these dynamics on real sea ice thickness data provided by the Polar Science Center.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"# Import Dependencies \n\n# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\n\n# External Dependencies\nusing ComponentArrays\nusing CoordRefSystems\nusing CairoMakie\nusing LinearAlgebra\nusing MLStyle\nusing NearestNeighbors\nusing NetCDF\nusing OrdinaryDiffEq\nPoint3D = Point3{Float64}","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"First, we load a mesh. We will execute these dynamics on the sphere:","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"# Load a mesh\ns_plots = loadmesh(Icosphere(7));\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s_plots);\nsubdivide_duals!(s, Barycenter());\nwireframe(s_plots)","category":"page"},{"location":"ebm_melt/ebm_melt/#Load-data","page":"Halfar-EBM-Water","title":"Load data","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"The data provided by the Polar Science Center is given as a NetCDF file. Ice thickness is a matrix with the same dimensions as a matrix provided Latitude and Longitude of the associated point on the Earth's surface. We need to convert between polar and Cartesian coordinates to use this data on our mesh.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"# This data can be downloaded from source here:\n# https://pscfiles.apl.uw.edu/axel/piomas20c/v1.0/monthly/piomas20c.heff.1901.2010.v1.0.nc\nice_thickness_file = \"piomas20c.heff.1901.2010.v1.0.nc\"\nrun(`curl -o $ice_thickness_file https://cise.ufl.edu/\"~\"luke.morris/piomas20c.heff.1901.2010.v1.0.nc`)\n\n# Use ncinfo(ice_thickness_file) to interactively get information on variables.\n# Sea ice thickness (\"sit\") has dimensions of [y, x, time].\n# y,x index into \"Latitude\" and \"Longitude\" variables.\n# Time is in units of days since 1901-01-01.\nlat = ncread(ice_thickness_file, \"Latitude\")\nlon = ncread(ice_thickness_file, \"Longitude\")\nsit = ncread(ice_thickness_file, \"sit\")\n\n# Convert latitude from [90, -90] to [0, 180] for convenience.\nlat .= -lat .+ 90\n\n# Convert mesh points from Cartesian to spherical coordinates.\np_sph = map(point(s)) do p\n  p = convert(Spherical, Cartesian(p...))\n  [rad2deg(p.θ).val, rad2deg(p.ϕ).val]\nend\n\n# Note: You can instead use an algebraic parameterization, rather than nearest-neighbor interpolation.\nlat, lon = lat[:], lon[:]\nll = hcat(lat, lon)'\nkdt = KDTree(ll)\nsit_sph_idxs = map(p_sph) do p\n  nn(kdt, p)[1]\nend\n\nsit_sph = map(sit_sph_idxs, p_sph) do i, p\n  ((p[1] > maximum(lat)) || isnan(sit[i])) ? 0.0f0 : sit[i]\nend\n\nf = Figure()\nax = LScene(f[1,1], scenekw=(lights=[],))\nupdate_cam!(ax.scene, Vec3f(0,0,0.8), Vec3f(0,0,0), Vec3f(0, 1, 1))\nmsh = mesh!(ax, s_plots, color=sit_sph, colormap=Reverse(:redsblues))\nColorbar(f[1,2], msh)\nf","category":"page"},{"location":"ebm_melt/ebm_melt/#Define-the-model","page":"Halfar-EBM-Water","title":"Define the model","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"Here, the Halfar model of ice dynamics is recalled, as well as the Budyko-Sellers EBM. These these models are composed individually. They are then coupled together via warming and melting components.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"halfar_eq2 = @decapode begin\n  (h, melt)::Form0\n  Γ::Form1\n  n::Constant\n\n  ∂ₜ(h)  == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯ᵖᵖ(d(h)))^(n-1)) * avg₀₁(h^(n+2))) - melt\nend\n\nglens_law = @decapode begin\n  (A,Γ)::Form1\n  (ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\nice_dynamics = apex(oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n   Open(glens_law, [:Γ,:n])]))\n\ndraw_composition(ice_dynamics_composition_diagram)","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"The composition pattern tells you how to couple the variables and introduces namespaces that we will use later when supplying initial conditions.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"The following code creates the Budyko-Sellers model as a composite of individual terms.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"\nenergy_balance = @decapode begin\n  (Tₛ, ASR, OLR, HT)::Form0\n  C::Constant\n\n  ∂ₜ(Tₛ) == (ASR - OLR + HT) ./ C\nend\n\nabsorbed_shortwave_radiation = @decapode begin\n  (Q, ASR)::Form0\n  α::Constant\n\n  ASR == (1 .- α) .* Q\nend\n\noutgoing_longwave_radiation = @decapode begin\n  (Tₛ, OLR)::Form0\n  (A,B)::Constant\n\n  OLR == A .+ (B .* Tₛ)\nend\n\nheat_transfer = @decapode begin\n  (HT, Tₛ)::Form0\n  (D,cosϕᵖ,cosϕᵈ)::Constant\n\n  HT == (D ./ cosϕᵖ) .* ⋆(d(cosϕᵈ .* ⋆(d(Tₛ))))\nend\n\ninsolation = @decapode begin\n  Q::Form0\n  cosϕᵖ::Constant\n\n  Q == 450 * cosϕᵖ\nend\n\nbudyko_sellers_composition_diagram = @relation () begin\n  energy(Tₛ, ASR, OLR, HT)\n  absorbed_radiation(Q, ASR)\n  outgoing_radiation(Tₛ, OLR)\n  diffusion(Tₛ, HT, cosϕᵖ)\n  insolation(Q, cosϕᵖ)\nend\n\nbudyko_sellers = apex(oapply(budyko_sellers_composition_diagram,\n  [Open(energy_balance, [:Tₛ, :ASR, :OLR, :HT]),\n   Open(absorbed_shortwave_radiation, [:Q, :ASR]),\n   Open(outgoing_longwave_radiation, [:Tₛ, :OLR]),\n   Open(heat_transfer, [:Tₛ, :HT, :cosϕᵖ]),\n   Open(insolation, [:Q, :cosϕᵖ])]))\n\ndraw_composition(budyko_sellers_composition_diagram)","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"Our full model can then be composed by adding terms for melting of water. We will assume that the meltwater is transported by diffusion because the transport of meltwater is so much faster than the melting process itself. If you wanted to increase the physical realism of this model, using a different model of melting and water transport would be a good place to start.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"warming = @decapode begin\n  Tₛ::Form0\n  A::Form1\n\n  A == avg₀₁(5.8282*10^(-0.236 * Tₛ)*1.01e-19)\nend\n\nmelting = @decapode begin\n  (Tₛ, h, melt, water)::Form0\n  Dₕ₂ₒ::Constant\n\n  melt == (Tₛ - 15)*1e-16*h\n  ∂ₜ(water) == melt + Dₕ₂ₒ*Δ(water)\nend\n\nbudyko_sellers_halfar_water_composition_diagram = @relation () begin\n  budyko_sellers(Tₛ)\n  warming(A, Tₛ)\n  melting(Tₛ, h, melt)\n  halfar(A, h, melt)\nend\n\ndraw_composition(budyko_sellers_halfar_water_composition_diagram)","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"budyko_sellers_halfar_water = apex(oapply(budyko_sellers_halfar_water_composition_diagram,\n  [Open(budyko_sellers, [:Tₛ]),\n   Open(warming, [:A, :Tₛ]),\n   Open(melting, [:Tₛ, :h, :melt]),\n   Open(ice_dynamics, [:stress_A, :dynamics_h, :dynamics_melt])]))\nnothing # hide","category":"page"},{"location":"ebm_melt/ebm_melt/#Define-initial-conditions","page":"Halfar-EBM-Water","title":"Define initial conditions","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"The initial data must be specified for state variables, as well as constants and parameters.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"# This is a primal 0-form, with values at vertices.\ncosϕᵖ = map(x -> cos(x[1]), point(s))\n# This is a dual 0-form, with values at edge centers.\ncosϕᵈ = map(edges(s)) do e\n  (cos(point(s, src(s, e))[1]) + cos(point(s, tgt(s, e))[1])) / 2\nend\n\nα₀ = 0.354\nα₂ = 0.25\nα = map(point(s)) do ϕ\n  α₀ + α₂*((1/2)*(3*ϕ[1]^2 - 1))\nend\nA = 210\nB = 2\nf = 0.70\nρ = 1025\ncw = 4186\nH = 70\nC = map(point(s)) do ϕ\n  f * ρ * cw * H\nend\nD = 0.6\n\n# Isothermal initial conditions:\nTₛ₀ = map(point(s)) do ϕ\n  15.0\nend\n\nwater = map(point(s)) do _\n  0.0\nend\n\nDₕ₂ₒ = 1e-16\n\nn = 3\nhalfar_ρ = 910\ng = 9.8\n\nh₀ = sit_sph\n# Store these values to be passed to the solver.\nu₀ = ComponentArray(\n  Tₛ = Tₛ₀,\n  h = h₀,\n  melting_water = water)\n\n# The underscore-separated words are the namespaces that were introduced by oapply.\nconstants_and_parameters = (\n  budyko_sellers_absorbed_radiation_α = α,\n  budyko_sellers_outgoing_radiation_A = A,\n  budyko_sellers_outgoing_radiation_B = B,\n  budyko_sellers_energy_C = C,\n  budyko_sellers_diffusion_D = D,\n  budyko_sellers_cosϕᵖ = cosϕᵖ,\n  budyko_sellers_diffusion_cosϕᵈ = cosϕᵈ,\n  halfar_n = n,\n  halfar_stress_ρ = halfar_ρ,\n  halfar_stress_g = g,\n  melting_Dₕ₂ₒ = Dₕ₂ₒ)","category":"page"},{"location":"ebm_melt/ebm_melt/#Generate-and-run-simulation","page":"Halfar-EBM-Water","title":"Generate and run simulation","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"The composed model is generated and executed for 100 years. The model is run twice to demonstrate the speed of the model after the simulation code is precompiled by the first run.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"We will save the final ice thickness data in a .jld2 file, an HDF5-compatible file format. We will also save the latitude and longitude of the points on the sphere.","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"sim = eval(gensim(budyko_sellers_halfar_water))\nfₘ = sim(s, nothing, DiagonalHodge())\n\ntₑ = 100.0\n\n@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-4), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\nsave(\"ice.jld2\",\n  Dict(\"lat\" => map(x -> x[1], p_sph), \"lon\" => map(x -> x[2], p_sph), \"ice\" => soln(tₑ).h))\n\n(extrema(soln(0.0).h), extrema(soln(tₑ).h))","category":"page"},{"location":"ebm_melt/ebm_melt/#Visualize","page":"Halfar-EBM-Water","title":"Visualize","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"Let's visualize the initial conditions for ice height and the ice height after 100 years.","category":"page"},{"location":"ebm_melt/ebm_melt/#Initial-ice-height","page":"Halfar-EBM-Water","title":"Initial ice height","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"f = Figure()\nax = LScene(f[1,1], scenekw=(lights=[],))\nupdate_cam!(ax.scene, Vec3f(0,0,0.8), Vec3f(0,0,0), Vec3f(0, 1, 1))\nmsh = mesh!(ax, s_plots, color=soln.u[begin].h, colormap=Reverse(:redsblues))\nColorbar(f[1,2], msh)\nf","category":"page"},{"location":"ebm_melt/ebm_melt/#Ice-height-after-100-years","page":"Halfar-EBM-Water","title":"Ice height after 100 years","text":"","category":"section"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"f = Figure()\nax = LScene(f[1,1], scenekw=(lights=[],))\nupdate_cam!(ax.scene, Vec3f(0,0,0.8), Vec3f(0,0,0), Vec3f(0, 1, 1))\nmsh = mesh!(ax, s_plots, color=soln.u[end].h, colorrange=extrema(soln.u[begin].h), colormap=Reverse(:redsblues))\nColorbar(f[1,2], msh)\nf","category":"page"},{"location":"ebm_melt/ebm_melt/","page":"Halfar-EBM-Water","title":"Halfar-EBM-Water","text":"run(`rm $ice_thickness_file`) # hide","category":"page"},{"location":"canon/#Canon","page":"Canonical Models","title":"Canon","text":"","category":"section"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"include(joinpath(Base.@__DIR__, \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"canon/#Physics","page":"Canonical Models","title":"Physics","text":"","category":"section"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"Modules = [ Decapodes.Canon.Physics ]\nPrivate = false","category":"page"},{"location":"canon/#Decapodes.Canon.Physics.:heat_transfer","page":"Canonical Models","title":"Decapodes.Canon.Physics.:heat_transfer","text":"Heat Transfer\n\nSource\n\nModel \n\n(HT, Tₛ)::Form0\n              \n(D, cosϕᵖ, cosϕᵈ)::Constant\n              \nHT == (D ./ cosϕᵖ) .* (⋆)(d(cosϕᵈ .* (⋆)(d(Tₛ))))\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.:outgoing_longwave_radiation","page":"Canonical Models","title":"Decapodes.Canon.Physics.:outgoing_longwave_radiation","text":"Outgoing Longwave Radiation\n\nSource\n\nModel \n\n(Tₛ, OLR)::Form0\n              \n(A, B)::Constant\n              \nOLR == A .+ B .* Tₛ\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.absorbed_shortwave_radiation","page":"Canonical Models","title":"Decapodes.Canon.Physics.absorbed_shortwave_radiation","text":"Absorbed Shortwave Radiation\n\nSource\n\nThe proportion of light reflected by a surface is the albedo. The absorbed shortwave radiation is the complement of this quantity.\n\nModel \n\n(Q, ASR)::Form0\n              \nα::Constant\n              \nASR == (1 .- α) .* Q\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.advection","page":"Canonical Models","title":"Decapodes.Canon.Physics.advection","text":"Advection\n\nSource\n\nAdvection refers to the transport of a bulk along a vector field.\n\nModel \n\nC::Form0\n              \n(ϕ, V)::Form1\n              \nϕ == C ∧₀₁ V\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.ficks_law","page":"Canonical Models","title":"Decapodes.Canon.Physics.ficks_law","text":"Ficks Law\n\nSource\n\nEquation for diffusion first stated by Adolf Fick. The diffusion flux is proportional to the concentration gradient.\n\nModel \n\nC::Form0\n              \nϕ::Form1\n              \nϕ == k(d₀(C))\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.iceblockingwater","page":"Canonical Models","title":"Decapodes.Canon.Physics.iceblockingwater","text":"IceBlockingWater\n\nSource\n\nModel \n\nh::Form0\n              \n(𝐮, w)::DualForm1\n              \nw == (1 - σ(h)) ∧ᵖᵈ₀₁ 𝐮\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.jko_scheme","page":"Canonical Models","title":"Decapodes.Canon.Physics.jko_scheme","text":"Jordan-Kinderlehrer-Otto\n\nSource\n\nJordan, R., Kinderlehrer, D., & Otto, F. (1998). The Variational Formulation of the Fokker–Planck Equation. In SIAM Journal on Mathematical Analysis (Vol. 29, Issue 1, pp. 1–17). Society for Industrial & Applied Mathematics (SIAM). https://doi.org/10.1137/s0036141096303359\n\nModel \n\n(ρ, Ψ)::Form0\n              \nβ⁻¹::Constant\n              \n∂ₜ(ρ) == (∘(⋆, d, ⋆))(d(Ψ) ∧ ρ) + β⁻¹ * Δ(ρ)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.lie","page":"Canonical Models","title":"Decapodes.Canon.Physics.lie","text":"Lie\n\nSource\n\nModel \n\nC::Form0\n              \nV::Form1\n              \ndX::Form1\n              \nV == ((⋆) ∘ (⋆))(C ∧ dX)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.mohamed_flow","page":"Canonical Models","title":"Decapodes.Canon.Physics.mohamed_flow","text":"Mohamed Eq. 10, N2\n\nSource\n\nModel \n\n(𝐮, w)::DualForm1\n              \n(P, 𝑝ᵈ)::DualForm0\n              \nμ::Constant\n              \n𝑝ᵈ == P + 0.5 * ι₁₁(w, w)\n              \n∂ₜ(𝐮) == μ * (∘(d, ⋆, d, ⋆))(w) + -1 * (⋆₁⁻¹)(w ∧ᵈᵖ₁₀ (⋆)(d(w))) + d(𝑝ᵈ)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.momentum","page":"Canonical Models","title":"Decapodes.Canon.Physics.momentum","text":"Momentum\n\nSource\n\nModel \n\n(f, b)::Form0\n              \n(v, V, g, Fᵥ, uˢ, v_up)::Form1\n              \nτ::Form2\n              \nU::Parameter\n              \nuˢ̇ == ∂ₜ(uˢ)\n              \nv_up == (((((((-1 * L(v, v) - L(V, v)) - L(v, V)) - f ∧ v) - (∘(⋆, d, ⋆))(uˢ) ∧ v) - d(p)) + b ∧ g) - (∘(⋆, d, ⋆))(τ)) + uˢ̇ + Fᵥ\n              \nuˢ̇ == force(U)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.navier_stokes","page":"Canonical Models","title":"Decapodes.Canon.Physics.navier_stokes","text":"Navier-Stokes\n\nSource\n\nPartial differential equations which describe the motion of viscous fluid surfaces.\n\nModel \n\n(V, V̇, G)::Form1{X}\n              \n(ρ, ṗ, p)::Form0{X}\n              \nV̇ == neg₁(L₁′(V, V)) + div₁(kᵥ(Δ₁(V) + third(d₀(δ₁(V)))), avg₀₁(ρ)) + d₀(half(i₁′(V, V))) + neg₁(div₁(d₀(p), avg₀₁(ρ))) + G\n              \n∂ₜ(V) == V̇\n              \nṗ == neg₀((⋆₀⁻¹)(L₀(V, (⋆₀)(p))))\n              \n∂ₜ(p) == ṗ\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.oscillator","page":"Canonical Models","title":"Decapodes.Canon.Physics.oscillator","text":"Oscillator\n\nSource\n\nEquation governing the motion of an object whose acceleration is negatively-proportional to its position.\n\nModel \n\nX::Form0\n              \nV::Form0\n              \nk::Constant\n              \n∂ₜ(X) == V\n              \n∂ₜ(V) == -k * X\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.poiseuille","page":"Canonical Models","title":"Decapodes.Canon.Physics.poiseuille","text":"Poiseuille\n\nSource\n\nA relation between the pressure drop in an incompressible and Newtownian fluid in laminar flow flowing through a long cylindrical pipe.\n\nModel \n\nP::Form0\n              \nq::Form1\n              \n(R, μ̃)::Constant\n              \nΔq == Δ(q)\n              \n∇P == d(P)\n              \n∂ₜ(q) == q̇\n              \nq̇ == μ̃ * ∂q(Δq) + ∇P + R * q\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.poiseuille_density","page":"Canonical Models","title":"Decapodes.Canon.Physics.poiseuille_density","text":"Poiseuille Density\n\nSource\n\nModel \n\nq::Form1\n              \n(P, ρ)::Form0\n              \n(k, R, μ̃)::Constant\n              \n∂ₜ(q) == q̇\n              \n∇P == d(P)\n              \nq̇ == (μ̃ * ∂q(Δ(q)) - ∇P) + R * q\n              \nP == k * ρ\n              \n∂ₜ(ρ) == ρ̇\n              \nρ_up == (∘(⋆, d, ⋆))(-1 * (ρ ∧₀₁ q))\n              \nρ̇ == ∂ρ(ρ_up)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.schroedinger","page":"Canonical Models","title":"Decapodes.Canon.Physics.schroedinger","text":"Schroedinger\n\nSource\n\nThe evolution of the wave function over time.\n\nModel \n\n(i, h, m)::Constant\n              \nV::Parameter\n              \nΨ::Form0\n              \n∂ₜ(Ψ) == (((-1 * h ^ 2) / (2m)) * Δ(Ψ) + V * Ψ) / (i * h)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Physics.superposition","page":"Canonical Models","title":"Decapodes.Canon.Physics.superposition","text":"Superposition\n\nSource\n\nModel \n\n(C, Ċ)::Form0\n              \n(ϕ, ϕ₁, ϕ₂)::Form1\n              \nϕ == ϕ₁ + ϕ₂\n              \nĊ == (⋆₀⁻¹)(dual_d₁((⋆₁)(ϕ)))\n              \n∂ₜ(C) == Ċ\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Chemistry","page":"Canonical Models","title":"Chemistry","text":"","category":"section"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"Modules = [ Decapodes.Canon.Chemistry ]\nPrivate = false","category":"page"},{"location":"canon/#Decapodes.Canon.Chemistry.GrayScott","page":"Canonical Models","title":"Decapodes.Canon.Chemistry.GrayScott","text":"Gray-Scott\n\nSource\n\nA model of reaction-diffusion\n\nModel \n\n(U, V)::Form0\n              \nUV2::Form0\n              \n(U̇, V̇)::Form0\n              \n(f, k, rᵤ, rᵥ)::Constant\n              \nUV2 == U .* (V .* V)\n              \nU̇ == (rᵤ * Δ(U) - UV2) + f * (1 .- U)\n              \nV̇ == (rᵥ * Δ(V) + UV2) - (f + k) .* V\n              \n∂ₜ(U) == U̇\n              \n∂ₜ(V) == V̇\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Chemistry.brusselator","page":"Canonical Models","title":"Decapodes.Canon.Chemistry.brusselator","text":"Brusselator\n\nSource\n\nA model of reaction-diffusion for an oscillatory chemical system.\n\nModel \n\n(U, V)::Form0\n              \nU2V::Form0\n              \n(U̇, V̇)::Form0\n              \nα::Constant\n              \nF::Parameter\n              \nU2V == (U .* U) .* V\n              \nU̇ == ((1 + U2V) - 4.4U) + α * Δ(U) + F\n              \nV̇ == (3.4U - U2V) + α * Δ(V)\n              \n∂ₜ(U) == U̇\n              \n∂ₜ(V) == V̇\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Biology","page":"Canonical Models","title":"Biology","text":"","category":"section"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"Modules = [ Decapodes.Canon.Biology ]\nPrivate = false","category":"page"},{"location":"canon/#Decapodes.Canon.Biology.kealy","page":"Canonical Models","title":"Decapodes.Canon.Biology.kealy","text":"Kealy\n\nSource\n\nModel \n\n(n, w)::DualForm0\n              \ndX::Form1\n              \n(a, ν)::Constant\n              \n∂ₜ(w) == ((a - w) - w * n ^ 2) + ν * Δ(w)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Biology.klausmeier_2a","page":"Canonical Models","title":"Decapodes.Canon.Biology.klausmeier_2a","text":"Klausmeier (Eq. 2a)\n\nSource\n\nKlausmeier, CA. “Regular and irregular patterns in semiarid vegetation.” Science (New York, N.Y.) vol. 284,5421 (1999): 1826-8. doi:10.1126/science.284.5421.1826\n\nModel \n\n(n, w)::DualForm0\n              \ndX::Form1\n              \n(a, ν)::Constant\n              \n∂ₜ(w) == ((a - w) - w * n ^ 2) + ν * ℒ(dX, w)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Biology.klausmeier_2b","page":"Canonical Models","title":"Decapodes.Canon.Biology.klausmeier_2b","text":"Klausmeier (Eq. 2b)\n\nSource\n\nibid.\n\nModel \n\n(n, w)::DualForm0\n              \nm::Constant\n              \n∂ₜ(n) == (w * n ^ 2 - m * n) + Δ(n)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Biology.lejeune","page":"Canonical Models","title":"Decapodes.Canon.Biology.lejeune","text":"Lejeune\n\nSource\n\nLejeune, O., & Tlidi, M. (1999). A Model for the Explanation of Vegetation Stripes (Tiger Bush). Journal of Vegetation Science, 10(2), 201–208. https://doi.org/10.2307/3237141\n\nModel \n\nρ::Form0\n              \n(μ, Λ, L)::Constant\n              \n∂ₜ(ρ) == (ρ * (((1 - μ) + (Λ - 1) * ρ) - ρ * ρ) + 0.5 * (L * L - ρ) * Δ(ρ)) - 0.125 * ρ * Δ(ρ) * Δ(ρ)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Biology.turing_continuous_ring","page":"Canonical Models","title":"Decapodes.Canon.Biology.turing_continuous_ring","text":"Turing Continuous Ring\n\nSource\n\nModel \n\n(X, Y)::Form0\n              \n(μ, ν, a, b, c, d)::Constant\n              \n∂ₜ(X) == a * X + b * Y + μ * Δ(X)\n              \n∂ₜ(Y) == c * X + d * Y + ν * Δ(X)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Environment","page":"Canonical Models","title":"Environment","text":"","category":"section"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"Modules = [ Decapodes.Canon.Environment ]\nPrivate = false","category":"page"},{"location":"canon/#Decapodes.Canon.Environment.boundary_conditions","page":"Canonical Models","title":"Decapodes.Canon.Environment.boundary_conditions","text":"Boundary Conditions\n\nSource\n\nModel \n\n(S, T)::Form0\n              \n(Ṡ, T_up)::Form0\n              \nv::Form1\n              \nv_up::Form1\n              \nṪ == ∂ₜ(T)\n              \nṠ == ∂ₜ(S)\n              \nv̇ == ∂ₜ(v)\n              \nṪ == ∂_spatial(T_up)\n              \nv̇ == ∂_noslip(v_up)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.energy_balance","page":"Canonical Models","title":"Decapodes.Canon.Environment.energy_balance","text":"Energy balance\n\nSource\n\nenergy balance equation from Budyko Sellers\n\nModel \n\n(Tₛ, ASR, OLR, HT)::Form0\n              \nC::Constant\n              \nTₛ̇ == ∂ₜ(Tₛ)\n              \nTₛ̇ == ((ASR - OLR) + HT) ./ C\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.equation_of_state","page":"Canonical Models","title":"Decapodes.Canon.Environment.equation_of_state","text":"Equation of State\n\nSource\n\nModel \n\n(b, T, S)::Form0\n              \n(g, α, β)::Constant\n              \nb == g * (α * T - β * S)\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.glen","page":"Canonical Models","title":"Decapodes.Canon.Environment.glen","text":"Glens Law\n\nSource\n\nNye, J. F. (1957). The Distribution of Stress and Velocity in Glaciers and Ice-Sheets. Proceedings of the Royal Society of London. Series A, Mathematical and Physical Sciences, 239(1216), 113–133. http://www.jstor.org/stable/100184\n\nModel \n\nΓ::Form1\n              \n(A, ρ, g, n)::Constant\n              \nΓ == (2 / (n + 2)) * A * (ρ * g) ^ n\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.halfar_eq2","page":"Canonical Models","title":"Decapodes.Canon.Environment.halfar_eq2","text":"Halfar (Eq. 2)\n\nSource\n\nHalfar, P. (1981), On the dynamics of the ice sheets, J. Geophys. Res., 86(C11), 11065–11072, doi:10.1029/JC086iC11p11065\n\nModel \n\nh::Form0\n              \nΓ::Form1\n              \nn::Constant\n              \n∂ₜ(h) == (∘(⋆, d, ⋆))(((Γ * d(h)) ∧ mag(♯(d(h))) ^ (n - 1)) ∧ h ^ (n + 2))\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.insolation","page":"Canonical Models","title":"Decapodes.Canon.Environment.insolation","text":"Insolation\n\nSource\n\nModel \n\nQ::Form0\n              \ncosϕᵖ::Constant\n              \nQ == 450cosϕᵖ\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.tracer","page":"Canonical Models","title":"Decapodes.Canon.Environment.tracer","text":"Tracer\n\nSource\n\nModel \n\n(c, C, F, c_up)::Form0\n              \n(v, V, q)::Form1\n              \nc_up == (((-1 * (⋆)(L(v, (⋆)(c))) - (⋆)(L(V, (⋆)(c)))) - (⋆)(L(v, (⋆)(C)))) - (∘(⋆, d, ⋆))(q)) + F\n\n\n\n\n\n","category":"constant"},{"location":"canon/#Decapodes.Canon.Environment.warming","page":"Canonical Models","title":"Decapodes.Canon.Environment.warming","text":"Warming\n\nSource\n\nModel \n\nTₛ::Form0\n              \nA::Form1\n              \nA == avg₀₁(5.8282 * 10 ^ (-0.236Tₛ) * 1.65e7)\n\n\n\n\n\n","category":"constant"},{"location":"canon/","page":"Canonical Models","title":"Canonical Models","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"EditURL = \"../../../literate/oncology/tumor_proliferation_invasion.jl\"","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"using Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations, DiagrammaticEquations.Deca\nusing Distributions\nusing MLStyle\nusing OrdinaryDiffEq\nusing LinearAlgebra\nusing ComponentArrays\nusing CairoMakie\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Load in our Decapodes models","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"using Decapodes.Canon.Oncology","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Let's examine our models. Here's the tumor invasion model with the logistic and Gompertz growth models.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"@doc invasion","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"@doc logistic","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"@doc gompertz","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Load in a mesh and a plotting function","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"function show_heatmap(Cdata)\n  heatmap(reshape(Cdata, (floor(Int64, sqrt(length(Cdata))), floor(Int64, sqrt(length(Cdata))))))\nend\n\nmesh = triangulated_grid(50,50,0.2,0.2,Point2D);\ndualmesh = EmbeddedDeltaDualComplex2D{Bool, Float64, Point2D}(mesh);\nsubdivide_duals!(dualmesh, Circumcenter());\nnothing #hide","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Let's define initial conditions","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"constants_and_parameters = (invasion_Dif = 0.005, invasion_Kd = 0.5, Cmax = 10)","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Here we follow the assumption \"The model ... considers an equivalent radially symmetric tumour\", Murray J.D., Glioblastoma brain tumours, by initializing the tumor with a normal distribution.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"c_dist  = MvNormal([25, 25], 2)\nC = 100 * [pdf(c_dist, [p[1], p[2]]) for p in dualmesh[:point]]\nu₀ = ComponentArray(C=C)","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Let's define how our Proliferation-Invasion models will relate to one another.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"proliferation_invasion_composition_diagram = @relation () begin\n  proliferation(C, fC, Cmax)\n  invasion(C, fC, Cmax)\nend","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Now let's specify which sub-models slot into our system. We use the same pattern for two different models: the first model pertains to a logistic growth model,","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"logistic_proliferation_invasion_cospan = oapply(proliferation_invasion_composition_diagram,\n  [Open(logistic, [:C, :fC, :Cmax]),\n   Open(invasion, [:C, :fC, :Cmax])])\nlogistic_proliferation_invasion = apex(logistic_proliferation_invasion_cospan)","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"The second model uses the same composition pattern but swaps out the logistic growth mode for a Gompertz growth model.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"gompertz_proliferation_invasion_cospan = oapply(proliferation_invasion_composition_diagram,\n  [Open(gompertz, [:C, :fC, :Cmax]),\n   Open(invasion, [:C, :fC, :Cmax])])\ngompertz_proliferation_invasion = apex(gompertz_proliferation_invasion_cospan)","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Generate the logistic simulation","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"logistic_sim = evalsim(logistic_proliferation_invasion)\nlₘ = logistic_sim(dualmesh, default_dec_generate, DiagonalHodge())","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Execute the logistic simulation","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"tₑ = 15.0\nproblem = ODEProblem(lₘ, u₀, (0, tₑ), constants_and_parameters)\nlogistic_solution = solve(problem, Tsit5());\nnothing #hide","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Let's examine the solution using the heatmap equation we defined.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"show_heatmap(logistic_solution(tₑ).C)","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Generate the Gompertz simulation","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"gompertz_sim = evalsim(gompertz_proliferation_invasion)\ngₘ = gompertz_sim(dualmesh, default_dec_generate, DiagonalHodge())","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Execute the Gompertz simulation","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"problem = ODEProblem(gₘ, u₀, (0, tₑ), constants_and_parameters)\ngompertz_solution = solve(problem, Tsit5());\nnothing #hide","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"Let's examine this solution now.","category":"page"},{"location":"examples/oncology/tumor_proliferation_invasion/","page":"Oncology","title":"Oncology","text":"show_heatmap(gompertz_solution(tₑ).C)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"include(joinpath(Base.@__DIR__, \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"api/#Decapodes","page":"Library Reference","title":"Decapodes","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.compile-Tuple{DiagrammaticEquations.decapodeacset.SummationDecapode, Vector{Symbol}, Set{Symbol}, Int64, DataType, Decapodes.AbstractGenerationTarget, Bool}","page":"Library Reference","title":"Decapodes.compile","text":"compile(d::SummationDecapode, inputs::Vector{Symbol}, inplace_dec_ops::Set{Symbol}, dimension::Int, stateeltype::DataType, code_target::AbstractGenerationTarget, preallocate::Bool)\n\nFunction that compiles the computation body. d is the input Decapode, inputs is a vector of state variables and literals, inplace_dec_ops is a collection of all DEC operator symbols that can use special in-place methods, dimension is the dimension of the problem (usually 1 or 2), stateeltype is the type of the state elements (usually Float32 or Float64), code_target determines what architecture the code is compiled for (either CPU or CUDA), and preallocate which is set to true by default and determines if intermediate results can be preallocated..\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.compile_env-Tuple{DiagrammaticEquations.decapodeacset.SummationDecapode, Set{Symbol}, Vector{Symbol}, Decapodes.AbstractGenerationTarget}","page":"Library Reference","title":"Decapodes.compile_env","text":"compile_env(d::SummationDecapode, present_dec_ops::Vector{Symbol}, contracted_ops::Vector{Symbol}, code_target::AbstractGenerationTarget)\n\nEmit code to define functions given operator Symbols.\n\nDefault operations return a tuple of an in-place and an out-of-place function. User-defined operations return an out-of-place function.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.gensim-Tuple{DiagrammaticEquations.decapodeacset.SummationDecapode, Vector{Symbol}}","page":"Library Reference","title":"Decapodes.gensim","text":"gensim(user_d::SummationDecapode, input_vars::Vector{Symbol}; dimension::Int=2, stateeltype::DataType = Float64, code_target::AbstractGenerationTarget = CPUTarget(), preallocate::Bool = true)\n\nGenerates the entire code body for the simulation function. The returned simulation function can then be combined with a mesh, provided by CombinatorialSpaces, and a function describing symbol to operator mappings to return a simulator that can be used to solve the represented equations given initial conditions.\n\nArguments:\n\nuser_d: The user passed Decapode for which simulation code will be generated. (This is not modified)\n\ninput_vars is the collection of variables whose values are known at the beginning of the simulation. (Defaults to all state variables and literals in the Decapode)\n\nKeyword arguments:\n\ndimension: The dimension of the problem. (Defaults to 2)(Must be 1 or 2)\n\nstateeltype: The element type of the state forms. (Defaults to Float64)(Must be Float32 or Float64)\n\ncode_target: The intended architecture target for the generated code. (Defaults to CPUTarget())(Use CUDATarget() for NVIDIA CUDA GPUs)\n\npreallocate: Enables(true)/disables(false) pre-allocated caches for intermediate computations. Some functions, such as those that determine Jacobian sparsity patterns, or perform auto-differentiation, may require this to be disabled. (Defaults to true)\n\ncontract: Enables(true)/disables(false) pre-computation of matrix-matrix multiplications for chains of such operators. This feature can interfere with certain auto-differentiation methods, in which case this can be disabled. (Defaults to true)\n\nmultigrid: Enables multigrid methods during code generation. If true, then the function produced by gensim will expect a PrimalGeometricMapSeries. (Defaults to false)\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"harmonics/harmonics/#Harmonics-of-the-Sphere","page":"Harmonics","title":"Harmonics of the Sphere","text":"","category":"section"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"This page shows how to use Decapodes tooling to explore the harmonics of a discrete manifold. This isn't using any Decapodes specific code, but it  is emblematic of a more advanced analysis you might want to do on your Decapode.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"In this case we are trying to visualize the roots of the Laplacian on a discrete manifold.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"Load the dependencies","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"# Meshing:\nusing CombinatorialSpaces\nusing CoordRefSystems\nusing GeometryBasics: Point3\nconst Point3D = Point3{Float64};\n\n# Visualization:\nusing CairoMakie\n\n# Simulation:\nusing LinearAlgebra","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"Load the mesh","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"const RADIUS = 1.0\ns = loadmesh(Icosphere(3, RADIUS));\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s);\nsubdivide_duals!(sd, Barycenter());","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"Compute the Laplacian eigenvectors using LinearAlgebra.eigen. This requires making the sparse Laplacian matrix dense with collect. Alternatively, use Arpack.jl.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"Δ0 = -Δ(0,sd)\nλ = eigen(collect(Δ0))","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"Let's check that our eigenvalues satisfy the right equation. The first eigenvector should be the kernel of the laplacian. So the following norm should be close to 0.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"q1 = λ.vectors[:,1]\nnorm(Δ0 *q1)","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"The first eigenvector is boring to visualize, because it is constant. So we will make some plots of the second eigenvector. If you run this on the desktop, you can use GLMakie and get an interactive plot to explore. We will just draw two angles.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"q = λ.vectors[:,2]\nfig = Figure()\nLabel(fig[1, 1, Top()], \"Default Angle\", padding = (0, 0, 5, 0))\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s, color=q)\nColorbar(fig[1,2], msh, size=32)\n# Second Angle\nLabel(fig[2, 1, Top()], \"Bottom Angle\", padding = (0, 0, 5, 0))\nax = LScene(fig[2,1], scenekw=(lights=[],))\nupdate_cam!(ax.scene, Vec3f(-1/2,-1/2,1.0/2), Vec3f(1,1,1), Vec3f(0, 0, 1))\nmsh = CairoMakie.mesh!(ax, s, color=q)\nColorbar(fig[2,2], msh, size=32)\nfig","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"q = λ.vectors[:,12]\nfig = Figure()\nLabel(fig[1, 1, Top()], \"Default Angle\", padding = (0, 0, 5, 0))\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s, color=q)\nColorbar(fig[1,2], msh, size=32)\n# Second Angle\nLabel(fig[2, 1, Top()], \"Bottom Angle\", padding = (0, 0, 5, 0))\nax = LScene(fig[2,1], scenekw=(lights=[],))\nupdate_cam!(ax.scene, Vec3f(-1/2,-1/2,1.0/2), Vec3f(1,1,1), Vec3f(0, 0, 1))\nmsh = CairoMakie.mesh!(ax, s, color=q)\nColorbar(fig[2,2], msh, size=32)\nfig","category":"page"},{"location":"harmonics/harmonics/#Exploring-solutions-with-Krylov-methods","page":"Harmonics","title":"Exploring solutions with Krylov methods","text":"","category":"section"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"We can also use the information about the eigenvectors for spectral techniques in solving the equations. Krylov methods are a bridge between linear solvers and spectral information.","category":"page"},{"location":"harmonics/harmonics/","page":"Harmonics","title":"Harmonics","text":"using Krylov\nb = zeros(nv(sd))\nb[1] = 1\nb[end] = -1\nx, stats = Krylov.gmres(Δ0, b, randn(nv(sd)), restart=true, memory=20, atol = 1e-10, rtol=1e-8, history=true, itmax=10000)\nx̂ = x .- sum(x)./length(x)\nnorm(x̂)\nstats\nnorm(Δ0*(x) - b)","category":"page"},{"location":"cism/cism/#Replicating-the-Community-Ice-Sheet-Model-v2.1-Halfar-Dome-Benchmark-with-Decapodes","page":"CISM v2.1","title":"Replicating the Community Ice Sheet Model v2.1 Halfar Dome Benchmark with Decapodes","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The Decapodes framework takes high-level representations of physics equations and automatically generates solvers.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We do so by translating equations from vector calculus notation to the \"discrete exterior calculus\" (DEC). This process is roughly about recognizing whether physical quantities represent scalar or vector quantities, and recognizing whether differential operators represent gradient, divergence, and so on.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In this benchmark, we will implement the \"small slope approximation\" of glacial dynamics used by P. Halfar in his 1981 work \"On the dynamics of the ice sheets\"[1] by taking his original formulation, translating it into the DEC, then providing a mesh and initial conditions.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The initial conditions used here are exactly those considered by W. H. Lipscomb et al. in \"Description And Evaluation of the Community Ice Sheet Model (CISM) v2.1\"[2].","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations\n\n# External Dependencies\nusing BenchmarkTools\nusing CairoMakie\nusing ComponentArrays\nusing GeometryBasics: Point2, Point3\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing SparseArrays\nusing Statistics\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}\nnothing # hide","category":"page"},{"location":"cism/cism/#Specifying-and-Composing-Physics","page":"CISM v2.1","title":"Specifying and Composing Physics","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Halfar Equation 2\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We will translate Halfar's equation into the DEC below. Although the equation given by Halfar is dense, this notation does not allow you to see which operators represent divergence, which components represent diffusivity constants, and so on. In the DEC, there is a small pool of operators, ⋆, d, ∧, ♯, and ♭, which combine according to set rules to encode all of these notions.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In the DEC, gradients are generalized by the exterior derivative \"d\". Given scalar-data, d gives the slope along edges in our mesh. Similarly, the operator (⋆, d, ⋆) generalizes divergence.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"In Halfar's equation there is a term corresponding to the magnitude of the slope, but it is not clear where this quantity is to be defined. Is it a scalar-like quantity, or a vector-like quantity? In the DEC translation, we take the gradient of h, d(h), and use the \"sharp\" operator to define it on points in the domain, where we then take its magnitude. The \"wedge product\", ∧, takes care of multiplying a scalar-like quantity by a vector-like quantity.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Halfar's equation looks a little disjoint. It seems that the front most terms are responsible for computing some parameter, while the remaining terms on the right encode something about the dynamics. This is because Halfar's equation is actually describing two equations in one. The front-most term defines a quantity - depending on the strain of the ice - that controls the rate at which ice diffuses. Since this computation is rather separate from the rest of the computations involving our differential operators, we will call it \"Gamma\" here, and define it in a later component Decapode.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Equation 2 from Halfar, P. ON THE DYNAMICS OF THE ICE SHEETS. (1981),\n# translated into the exterior calculus.\nhalfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form0\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == Γ * ∘(⋆, d, ⋆)(d(h) ∧₁₀ ((mag(♯ᵖᵖ(d(h)))^(n-1)) ∧₀₀ h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Glen's Law\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Here, we recognize that Gamma is in fact what glaciologists call \"Glen's Flow Law\"[3]. It states that the strain rate of a sheet of ice can be related to applied stress via a power law. Below, we encode the formulation as it is usually given in the literature, depending explicitly on the gravitational constant, g.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Equation 1 from Glen, J. W. THE FLOW LAW OF ICE: A discussion of the\n# assumptions made in glacier theory, their experimental foundations and\n# consequences. (1958)\nglens_law = @decapode begin\n  Γ::Form0\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We now need some way to compose these physics equations together. Since this physics is rather small, and there are no naming conflicts of physical quantities, this composition is also rather simple.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"#####################\n# Compose the model #\n#####################\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\ndraw_composition(ice_dynamics_composition_diagram)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plug in our Decapodes to the composition pattern.\nice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n   Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics, verbose=false)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We have a representation of our composed physics. Now, we need to specify that these dynamics occur in 2 dimensions.","category":"page"},{"location":"cism/cism/#Providing-a-Semantics","page":"CISM v2.1","title":"Providing a Semantics","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Interpret this multiphysics diagram in the 2D exterior calculus.\n\nice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\nto_graphviz(ice_dynamics2D, verbose=false)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We are done encoding our dynamics. Now, we need to provide a mesh,  initial data to use for our quantities, and what functions to use for our differential operators.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Our mesh library, CombinatorialSpaces, can interpret arbitrary .OBJ files to run our dynamics on. Here, we use a script that generates a triangulated grid of the resolution used in the CISM benchmark. Note though that the \"resolution\" of a triangulated and non-triangulated grid is difficult to directly compare.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"s = triangulated_grid(60_000,100_000,2_000,2_000,Point3D)\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\nx̄ = mean(p -> p[1], point(sd))\nȳ = mean(p -> p[2], point(sd))\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect=0.6, xticks = [0, 3e4, 6e4])\nwf = wireframe!(ax, sd; linewidth=0.5)\nsave(\"ice_mesh.png\", fig)\nnothing # hide","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Wireframe of the Domain\")","category":"page"},{"location":"cism/cism/#Defining-input-data","page":"CISM v2.1","title":"Defining input data","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We replicate the initial conditions and parameter values used in the CISM benchmark.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# These are the initial conditions to the Halfar Dome test case that the\n# Community Ice Sheet Model uses.\nR₀ = 60_000 * sqrt(0.125)\nH = 2_000 * sqrt(0.125)\n\nn = 3\ng = 9.8101\nρ = 910\nalpha = 1/9\nbeta = 1/18\nflwa = 1e-16\nA = 1e-16\n\nGamma = 2.0/(n+2) * flwa * (ρ * g)^n\nt0 = (beta/Gamma) * (7.0/4.0)^3 * (R₀^4 / H^7)\n\n# This is the analytic solution for comparison.\n# It is ported over from the CISM code for comparison's sake,\n# and we will use it to set initial conditions.\nfunction height_at_p(x,y,t)\n  tr = (t + t0) / t0\n  r = sqrt((x - x̄)^2 + (y - ȳ)^2)\n  r = r/R₀\n  inside = max(0.0, 1.0 - (r / tr^beta)^((n+1.0) / n))\n  H * inside^(n / (2*n + 1)) / tr^alpha\nend\n\n# Set the initial conditions for ice sheet height:\n# Ice height is a primal 0-form. i.e. valued at vertices.\nh₀ = map(x -> height_at_p(x[1], x[2], 0), point(s))\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect=0.6, xticks = [0, 3e4, 6e4])\nmsh = mesh!(ax, s, color=h₀, colormap=:jet)\nsave(\"ice_initial_conditions.png\", fig)\nnothing # hide","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Initial Conditions\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Store these values to be passed to the solver.\nu₀ = ComponentArray(dynamics_h = h₀)\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"The gensim function takes our high-level representation of the physics equations and produces compiled simulation code. It performs optimizations such as allocating memory for intermediate variables, and so on.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"sim = eval(gensim(ice_dynamics2D))\nfₘ = sim(sd, nothing)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Julia is a \"Just-In-Time\" compiled language. That means that functions are compiled the first time they are called, and later calls to those functions skip this step. To get a feel for just how fast this simulation is, we will run the dynamics twice, once for a very short timespan to trigger pre-compilation, and then again for the actual dynamics.","category":"page"},{"location":"cism/cism/#Running-the-Simulation","page":"CISM v2.1","title":"Running the Simulation","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Pre-compile simulation\n\n# Julia will pre-compile the generated simulation the first time it is run.\n@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nproblem = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsolution = solve(problem, Tsit5())\nsolution.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Run simulation\ntₑ = 200\n\n# This next run should be fast.\n@info(\"Solving\")\nproblem = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsolution = solve(problem, Tsit5(), saveat=0.1)\n@show solution.retcode\n@info(\"Done\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We can benchmark the compiled simulation with @benchmarkable. This macro runs many samples of the simulation function so we get an accurate estimate of the simulation time. The simulation time is quite fast compared to the CISM benchmarks. These results are run automatically via GitHub Actions as part of our docs build, which is not optimized for numerical simulations.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Time the simulation\n\nb = @benchmarkable solve(problem, Tsit5(), saveat=0.1)\nc = run(b)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Here we save the solution information to a file.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"@save \"ice_dynamics2D.jld2\" solution","category":"page"},{"location":"cism/cism/#Result-Comparison-and-Analysis","page":"CISM v2.1","title":"Result Comparison and Analysis","text":"","category":"section"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We recall that these dynamics are of the \"shallow slope\" and \"shallow ice\" approximations. So, at the edge of our parabolic dome of ice, we expect increased error as the slope increases. On the interior of the dome, we expect the dynamics to match more closely that given by the analytic model. We will see that the CISM results likewise accumulate error in the same neighborhood.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Halfar Small Ice Approximation Quote\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the final conditions\nfunction plot_final_conditions()\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Modeled thickness (m) at time 200.0\",\n    aspect=0.6, xticks = [0, 3e4, 6e4])\n  msh = mesh!(ax, s, color=solution(200.0).dynamics_h, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_final_conditions()\nsave(\"ice_numeric_solution.png\", fig)\nnothing # hide","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Numerical Solution\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the final conditions according to the analytic solution.\nfunction plot_analytic()\n  hₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s))\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Analytic thickness (m) at time 200.0\",\n    aspect=0.6, xticks = [0, 3e4, 6e4])\n  msh = mesh!(ax, s, color=hₐ, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_analytic()\nsave(\"ice_analytic_solution.png\", fig)\nnothing # hide","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Analytic Solution)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Plot the error.\nfunction plot_error()\n  hₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s))\n  h_diff = solution(tₑ).dynamics_h - hₐ\n  extrema(h_diff)\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1],\n    title=\"Modeled thickness - Analytic thickness at time 200.0\",\n    aspect=0.6, xticks = [0, 3e4, 6e4])\n  msh = mesh!(ax, s, color=h_diff, colormap=:jet)\n  Colorbar(fig[1,2], msh)\n  fig\nend\nfig = plot_error()\nsave(\"ice_error.png\", fig)\nnothing # hide","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Numeric Solution - Analytic Solution\")","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We compute below that the maximum absolute error is approximately 89 meters. We observe that this error occurs exactly on the edge of the dome, which we expect given that this is where the \"shallow slope approximation\" breaks down, and the updates to our physical quantities should become more unstable. This pattern likewise occurs in the CISM benchmarks.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute max absolute error:\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s))\nh_diff = solution(tₑ).dynamics_h - hₐ\nmaximum(abs.(h_diff))","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We compute root-mean-square (RMS) error as well, both over the entire domain, and excluding where the ice distribution is 0 in the analytic solution. This is done since considering the entire domain decreases the RMS while not telling you much about the area of interest. Note that the official CISM benchmark reports 6.43 and 9.06 RMS for their two solver implementations.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute RMS not considering the \"outside\".\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s))\nnonzeros = findall(!=(0), hₐ)\nh_diff = solution(tₑ).dynamics_h - hₐ\nrmse = sqrt(sum(map(x -> x*x, h_diff[nonzeros])) / length(nonzeros))","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Compute RMS of the entire domain.\nhₐ = map(x -> height_at_p(x[1], x[2], 200.0), point(s))\nh_diff = solution(tₑ).dynamics_h - hₐ\nrmse = sqrt(sum(map(x -> x*x, h_diff)) / length(h_diff))","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"# Create a gif\nbegin\n  frames = 100\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1], aspect=0.6, xticks = [0, 3e4, 6e4])\n  msh = mesh!(ax, s, color=solution(0).dynamics_h, colormap=:jet, colorrange=extrema(solution(tₑ).dynamics_h))\n  Colorbar(fig[1,2], msh)\n  record(fig, \"ice_dynamics_cism.gif\", range(0.0, tₑ; length=frames); framerate = 30) do t\n    msh.color = solution(t).dynamics_h\n  end\nend","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: \"Ice Dynamics)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"For comparison's sake, we paste the results produced by CISM below. We observe that the error likewise accumulates around the edge of the dome, with more accurate predictions on the interior. We note that our simulation produces slight over-estimates on the interior, but there are further strategies that one can employ to increase accuracy, such as tweaking the error tolerance of the solver, and so on.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Not that since the DEC is based on triangulated meshes, the \"resolution\" of the CISM benchmark and the Decapodes implementation cannot be directly compared. An advantage of the DEC is that we do not need to operate on uniform grids. For example, you could construct a mesh that is finer along the dome edge, where you need more resolution, and coarser as you are farther away from the reach of the ice.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"(Image: CISM Results)","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"We saw in this document how to create performant and accurate simulations in the Decapodes framework, and compared against the CISM library . Although we do not expect to be both more performant and accurate compared to every hand-crafted simulation, Decapodes makes up for this difference in terms of development time, flexibility, and composition. For example, the original implementation of the Decapodes shallow ice model took place over a couple of afternoons.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Since Decapodes targets high-level representations of physics, it is uniquely suited to incorporating knowledge from subject matter experts to increase simulation accuracy. This process does not require an ice dynamics expert to edit physics equations that have already been weaved into solver code.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"Further improvements to the Decapodes library are made continuously. We are creating implementations of DEC operators that are constructed and execute faster. And we are in the beginning stages of 3D simulations using the DEC.","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"P. Halfar. On the dynamics of the ice sheets. Journal of Geophysical Research: Oceans 86, 11065–11072 (1981). Accessed on Jul 22, 2024.\n\n\n\nW. H. Lipscomb, S. F. Price, M. J. Hoffman, G. R. Leguy, A. R. Bennett, S. L. Bradley, K. J. Evans, J. G. Fyke, J. H. Kennedy, M. Perego, D. M. Ranken, W. J. Sacks, A. G. Salinger, L. J. Vargo and P. H. Worley. Description and evaluation of the Community Ice Sheet Model (CISM) v2.1. Geoscientific Model Development 12, 387–424 (2019). Accessed on Jul 22, 2024.\n\n\n\nJ. Glen. The flow law of ice: A discussion of the assumptions made in glacier theory, their experimental foundations and consequences. IASH Publ 47, 171–183 (1958).\n\n\n\n","category":"page"},{"location":"cism/cism/","page":"CISM v2.1","title":"CISM v2.1","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Halfar's-model-of-glacial-flow","page":"Glacial Flow","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing GeometryBasics: Point2, Point3\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing SparseArrays\nusing Statistics\nPoint2D = Point2{Float64};\nPoint3D = Point3{Float64};","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Defining-the-models","page":"Glacial Flow","title":"Defining the models","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first step is to find a suitable equation for our model, and translate it into the Discrete Exterior Calculus. The Exterior Calculus is a generalization of vector calculus, so for low-dimensional spaces, this translation is straightforward. For example, divergence is typically written as (⋆, d, ⋆). Scalar fields are typically interpreted as \"0Forms\", i.e. values assigned to vertices of a mesh.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We use the @decapode macro to interpret the equations. Here, we have equation 2 from Halfar:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fracpartial hpartial t = frac2n + 2 (fracrho gA)^n fracpartialpartial x(fracpartial hpartial x fracpartial hpartial x ^n-1 h^n+2)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll change the term out front to Γ so we can demonstrate composition in a moment.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In the exterior calculus, we could write the above equations like so:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"partial_t(h) = Gammaquad circ(star d star)(d(h)quad wedge quadd(h)^sharp^n-1 quad wedge quad (h^n+2))","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form0\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == Γ * ∘(⋆, d, ⋆)(d(h) ∧₁₀ ((mag(♯ᵖᵖ(d(h)))^(n-1)) ∧₀₀ h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"And here, a formulation of Glen's law from J.W. Glen's 1958 \"The flow law of ice\".","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"glens_law = @decapode begin\n  Γ::Form0\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Composing-models","page":"Glacial Flow","title":"Composing models","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can use operadic composition to specify how our models come together. In this example, we have two Decapodes, and two quantities that are shared between them.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\ndraw_composition(ice_dynamics_composition_diagram)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To a apply a composition, we specify which Decapodes to plug into those boxes, and what each calls the corresponding shared variables internally.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Provide-a-semantics","page":"Glacial Flow","title":"Provide a semantics","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To interpret our composed Decapode, we need to specify what Discrete Exterior Calculus to interpret our quantities in. Let's choose the 1D Discrete Exterior Calculus:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics1D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics1D, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(ice_dynamics1D, op1_res_rules_1D, op2_res_rules_1D)\n\nto_graphviz(ice_dynamics1D)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Define-a-mesh","page":"Glacial Flow","title":"Define a mesh","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll need a mesh to simulate on. Since this is a 1D mesh, we can go ahead and make one right now:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# This is an empty 1D mesh.\ns = EmbeddedDeltaSet1D{Bool, Point2D}()\n\n# 20 vertices along a line, connected by edges.\nadd_vertices!(s, 20, point=Point2D.(range(0, 10_000, length=20), 0))\nadd_edges!(s, 1:nv(s)-1, 2:nv(s))\norient!(s)\n\n# The dual 1D mesh\nsd = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s)\nsubdivide_duals!(sd, Circumcenter())","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Define-input-data","page":"Glacial Flow","title":"Define input data","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need initial conditions to use for our simulation.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\n# We choose a distribution that obeys the shallow height and shallow slope conditions.\nh₀ = map(point(s)) do (x,_)\n  10 - ((x-5000)*1e-5)^2\nend\n\n# Visualize initial conditions for ice sheet height.\nlines(map(x -> x[1], point(s)), h₀, linewidth=5)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need to tell our Decapode which data maps to which symbols. We can wrap up our data like so:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Generate-the-simulation","page":"Glacial Flow","title":"Generate the simulation","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Now, we have everything we need to generate our simulation:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics1D, dimension=1))\nfₘ = sim(sd, nothing)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Pre-compile-and-run","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first time that you run a function, Julia will pre-compile it, so that later runs will be fast. We'll solve our simulation for a short time span, to trigger this pre-compilation, and then run it.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\ntₑ = 3e17\n\n# This next run should be fast.\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can save our solution file in case we want to examine its contents when this Julia session ends.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics1D.jld2\" soln","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Visualize","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's examine the final conditions:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig,ax,ob = lines(map(x -> x[1], point(s)), soln(tₑ).dynamics_h, linewidth=5)\nylims!(ax, extrema(h₀))\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We see that our distribution converges to a more uniform ice height across our domain, which matches our physical intuition.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's create a GIF to examine an animation of these dynamics:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Create a gif\nbegin\n  time = Observable(0.0)\n  ys = @lift(getproperty(soln($time), :dynamics_h))\n  xcoords = map(x -> x[1], point(s))\n  fig, ax, ob = lines(xcoords, ys, colorrange=extrema(h₀);\n    axis = (; title = \"1D Ice Thickness\"))\n  record(fig, \"ice_dynamics1D.gif\", range(0, tₑ, length=30); framerate=15) do t\n    time[] = t\n  end\nend","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics1D)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#2D-Re-interpretation","page":"Glacial Flow","title":"2D Re-interpretation","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first, one-dimensional, semantics that we provided to our Decapode restricted the kinds of glacial sheets that we could model. (i.e. We could only look at glacial sheets which were constant along y). We can give our Decapode an alternate semantics, as some physics on a 2-dimensional manifold.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Note that for these physics, we make no adjustments to the underlying \"dimension-agnostic\" Decapode, we only provide a different set of rules for inferring what the type of each quantity is.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\n\nto_graphviz(ice_dynamics2D)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Store-as-JSON","page":"Glacial Flow","title":"Store as JSON","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We quickly demonstrate how to serialize a Decapode to JSON and read it back in:","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"write_json_acset(ice_dynamics2D, \"ice_dynamics2D.json\")","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"You can view the JSON file here.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# When reading back in, we specify that all attributes are \"Symbol\"s.\nice_dynamics2 = read_json_acset(SummationDecapode{Symbol,Symbol,Symbol}, \"ice_dynamics2D.json\")\n# Or, you could choose to interpret the data as \"String\"s.\nice_dynamics3 = read_json_acset(SummationDecapode{String,String,String}, \"ice_dynamics2D.json\")\n\nto_graphviz(ice_dynamics3)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Define-our-mesh","page":"Glacial Flow","title":"Define our mesh","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s = triangulated_grid(10_000,10_000,800,800,Point3D)\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nwf = wireframe!(ax, s)\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Define-our-input-data","page":"Glacial Flow","title":"Define our input data","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s)) do (x,y)\n  (7072-((x-5000)^2 + (y-5000)^2)^(1/2))/9e3+10\nend\n\n# Visualize initial condition for ice sheet height.\nmesh(s, color=h₀, colormap=:jet)\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nmsh = mesh!(ax, s, color=h₀, colormap=:jet)\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Generate-simulation","page":"Glacial Flow","title":"Generate simulation","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(sd, nothing)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Pre-compile-and-run-2D","page":"Glacial Flow","title":"Pre-compile and run 2D","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"tₑ = 5e13\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics2D.jld2\" soln","category":"page"},{"location":"ice_dynamics/ice_dynamics/#Visualize-2D","page":"Glacial Flow","title":"Visualize 2D","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Final conditions:\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nmsh = mesh!(ax, s, color=soln(tₑ).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 100\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1])\n  msh = CairoMakie.mesh!(ax, s, color=soln(0).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\n  Colorbar(fig[1,2], msh)\n  record(fig, \"ice_dynamics2D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    msh.color = soln(t).dynamics_h\n  end\nend","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2D)","category":"page"},{"location":"ice_dynamics/ice_dynamics/#2-Manifold-in-3D","page":"Glacial Flow","title":"2-Manifold in 3D","text":"","category":"section"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We note that just because our physics is happening on a 2-manifold, (a surface), this doesn't restrict us to the 2D plane. In fact, we can \"embed\" our 2-manifold in 3D space to simulate a glacial sheets spread across the globe.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s = loadmesh(Icosphere(3, 10_000))\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\nwireframe(sd)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s)) do (x,y,z)\n  (z*z)/(10_000*10_000)\nend\n\n# Visualize initial condition for ice sheet height.\n# There is lots of ice at the poles, and no ice at the equator.\nfig = Figure()\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s, color=h₀, colormap=:jet)\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = ComponentArray(dynamics_h=h₀)\n\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(sd, nothing)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"For brevity's sake, we'll skip the pre-compilation cell.","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"tₑ = 5e25\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\n# Compare the extrema of the initial and final conditions of ice height.\nextrema(soln(0).dynamics_h), extrema(soln(tₑ).dynamics_h)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig = Figure()\nax = LScene(fig[1,1], scenekw=(lights=[],))\nmsh = CairoMakie.mesh!(ax, s, color=soln(tₑ).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\nColorbar(fig[1,2], msh)\nfig","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 200\n  fig = Figure()\n  ax = LScene(fig[1,1], scenekw=(lights=[],))\n  msh = CairoMakie.mesh!(ax, s, color=soln(0).dynamics_h, colormap=:jet, colorrange=extrema(soln(0).dynamics_h))\n\n  Colorbar(fig[1,2], msh)\n  # These particular initial conditions diffuse quite quickly, so let's just look at\n  # the first moments of those dynamics.\n  record(fig, \"ice_dynamics2D_sphere.gif\", range(0.0, tₑ/64; length=frames); framerate = 20) do t\n    msh.color = soln(t).dynamics_h\n  end\nend","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2DSphere)","category":"page"},{"location":"ice_dynamics/ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"ch/cahn-hilliard/#The-Cahn-Hilliard-Equation","page":"Cahn-Hilliard","title":"The Cahn-Hilliard Equation","text":"","category":"section"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"For this example, Decapodes will model the Cahn-Hilliard equation. This equation describes the evolution of a binary fluid as its two phases separate out into distinct domains. Below is a high resolution preview of this model. Notice how the fluid has separated into distinct regions (blue and red) as well as the presence of a transition region.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"(Image: \"Cahn Hilliard sample\")","category":"page"},{"location":"ch/cahn-hilliard/#Formulating-the-Equation","page":"Cahn-Hilliard","title":"Formulating the Equation","text":"","category":"section"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"We first load in our dependencies","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing GeometryBasics\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing Random\nPoint3D = Point3{Float64};\nnothing #hide","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"and then proceed to describe our physics using Decapodes.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"CahnHilliard = @decapode begin\n    C::Form0\n    (D, γ)::Constant\n    ∂ₜ(C) == D * Δ(C.^3 - C - γ * Δ(C))\nend\n\nto_graphviz(CahnHilliard)","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"In this equation C will represent the concentration of the binary fluid, ranging from -1 to 1 to differentiate between different phases. We also have a diffusion constant D and a constant γ whose square root is the length of the transition regions. This formulation of the Cahn-Hilliard equation was drawn from the Wikipedia page on the topic found here.","category":"page"},{"location":"ch/cahn-hilliard/#Loading-the-Data","page":"Cahn-Hilliard","title":"Loading the Data","text":"","category":"section"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"We now generate the mesh information. We'll run the equation on a triangulated grid.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"s = triangulated_grid(100, 100, 0.5, 0.5, Point3D);\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s);\nsubdivide_duals!(sd, Circumcenter());\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1) \nwf = wireframe!(ax, s; linewidth=1) \nsave(\"CahnHilliard_Rect.png\", fig) \nnothing # hide","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"(Image: \"CahnHilliardRect\")","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"The Cahn-Hilliard equation starts with a random concentration holding values between -1 and 1. For both D and γ constants we choose 0.5.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"Random.seed!(0)\n\nC = rand(Float64, nv(sd)) * 2 .- 1\nu₀ = ComponentArray(C=C)\nconstants = (D = 0.5, γ = 0.5);\n\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1) \nmsh = CairoMakie.mesh!(ax, s, color=C, colormap=:jet, colorrange=extrema(C)) \nColorbar(fig[1,2], msh)\nsave(\"CahnHilliard_initial.png\", fig) \nnothing # hide","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"(Image: \"Initial conditions\")","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"We'll now create the simulation code representing the Cahn-Hilliard equation. We pass nothing in the second argument to sim since we have no custom functions to pass in.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"sim = eval(gensim(CahnHilliard))\nfₘ = sim(sd, nothing, DiagonalHodge());","category":"page"},{"location":"ch/cahn-hilliard/#Getting-the-Solution","page":"Cahn-Hilliard","title":"Getting the Solution","text":"","category":"section"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"Now that everything is set up and ready, we can solve the equation. We run the simulation for 200 time units to see the long-term evolution of the fluid. Note we only save the solution at intervals of 0.1 time units in order to reduce the memory-footprint of the solve.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"tₑ = 200\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants)\nsoln = solve(prob, Tsit5(), saveat=0.1);\nsoln.retcode","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"And we can see the result as a gif.","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"function create_gif(solution, file_name)\n  frames = 200\n  fig = Figure()\n  ax = CairoMakie.Axis(fig[1,1])\n  msh = CairoMakie.mesh!(ax, s, color=solution(0).C, colormap=:jet, colorrange=extrema(solution(0).C))\n  Colorbar(fig[1,2], msh)\n  CairoMakie.record(fig, file_name, range(0.0, tₑ; length=frames); framerate = 15) do t\n    msh.color = solution(t).C\n  end\nend\ncreate_gif(soln, \"CahnHilliard_Rect.gif\")","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"(Image: \"CahnHilliardRes\")","category":"page"},{"location":"ch/cahn-hilliard/","page":"Cahn-Hilliard","title":"Cahn-Hilliard","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"concepts/equations/#Simple-Equations","page":"Equations","title":"Simple Equations","text":"","category":"section"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\",\"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"This tutorial shows how to use Decapodes to represent simple equations. These aren't using any of the Discrete Exterior Calculus or CombinatorialSpaces features of Decapodes. They just are a reference for how to build equations with the @decapodes macro and see how they are stored as ACSets.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"using Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"The harmonic oscillator can be written in Decapodes in at least three different ways.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k(X)\nend","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"The default representation is a tabular output as an ACSet. The tables are Var for storing variables (X) and their types (Form0). TVar for identifying a subset of variables that are the tangent variables of the dynamics (Ẋ). The unary operators are stored in Op1 and binary operators stored in Op2. If a table is empty, it doesn't get printed.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"Even though a diagrammatic equation is like a graph, there are no edge tables, because the arity (number of inputs) and coarity (number of outputs) is baked into the operator definitions.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"You can also see the output as a directed graph. The input arrows point to the state variables of the system and the output variables point from the tangent variables. You can see that I have done the differential degree reduction from  x'' = -kx by introducing a velocity term v. Decapodes has some support for derivatives in the visualization layer, so it knows that dX/dt should be called Ẋ and that dẊ/dt should be called Ẋ̇.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"In the previous example, we viewed negation and transformation by k as operators. Notice that k appears as an edge in the graph and not as a vertex. You can also use a 2 argument function like multiplication (*). With a constant value for k::Constant. In this case you will see k enter the diagram as a vertex and multiplication with * as a binary operator.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k*(X)\nend","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"This gives you a different graphical representation as well. Now we have the cartesian product objects which represent a tupling of two values.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"You can also represent negation as a multiplication by a literal -1.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"Notice that the type bubble for the literal one is ΩL. This means that it is a literal. The literal is also used as the variable name.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"We can allow the material properties to vary over time by changing Constant to Parameter. This is how we tell the simulator that it needs to call k(t) at each time step to get the updated value for k or if it can just reuse that constant k from the initial time step.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Parameter\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"Often you will have a linear material where you are scaling by a constant, and a nonlinear version of that material where that scaling is replaced by a generic nonlinear function. This is why we allow Decapodes to represent both of these types of equations.","category":"page"},{"location":"concepts/equations/","page":"Equations","title":"Equations","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"nhs/nhs_lite/#Implement-Oceananigans.jl's-NonhydrostaticModel-in-the-Discrete-Exterior-Calculus","page":"NHS","title":"Implement Oceananigans.jl's NonhydrostaticModel in the Discrete Exterior Calculus","text":"","category":"section"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Let's use Decapodes to implement the NonhydrostaticModel from Oceananigans.jl. We will take the opportunity to demonstrate how we can use our \"algebra of model compositions\" to encode certain guarantees on the models we generate. We will use the 2D Turbulence as a guiding example, and use only equations found in the Oceananigans docs to construct our model.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"The full code that generated these results is available in a julia script.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing Downloads\nusing GeometryBasics: Point3\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nPoint3D = Point3{Float64};\nnothing # hide","category":"page"},{"location":"nhs/nhs_lite/#Specify-our-models","page":"NHS","title":"Specify our models","text":"","category":"section"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"This is Equation 1: \"The momentum conservation equation\". This is the first formulation of mutual advection (of v along V, and V along v) that we could find in the exterior calculus.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"momentum =  @decapode begin\n  (v,V)::DualForm1\n  f::Form0\n  uˢ::DualForm1\n  ∂tuˢ::DualForm1\n  p::DualForm0\n  b::DualForm0\n  ĝ::DualForm1\n  Fᵥ::DualForm1\n  StressDivergence::DualForm1\n\n  ∂ₜ(v) ==\n    -ℒ₁(v,v) + 0.5*d(ι₁₁(v,v)) -\n     d(ι₁₁(v,V)) + ι₁₂(v,d(V)) + ι₁₂(V,d(v)) -\n     (f - ∘(d,⋆)(uˢ)) ∧ᵖᵈ₀₁ v -\n     d(p) +\n     b ∧ᵈᵈ₀₁ ĝ -\n     StressDivergence +\n     ∂tuˢ +\n     Fᵥ\nend\nto_graphviz(momentum)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Why did we write \"StressDivergence\" instead of ∇⋅τ, as in the linked equation? According to this docs page, the user makes a selection of what model to insert in place of the term ∇⋅τ. For example, in the isotropic case, Oceananigans.jl replaces this term with: ∇⋅τ = νΔv. Thus, we write StressDivergence, and replace this term with a choice of \"turbulence closure\" model. Using the \"constant isotropic diffusivity\" case, we can operate purely in terms of scalar-valued forms.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"This is Equation 2: \"The tracer conservation equation\".","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"tracer_conservation = @decapode begin\n  (c,C,F,FluxDivergence)::DualForm0\n  (v,V)::DualForm1\n\n  ∂ₜ(c) ==\n    -1*ι₁₁(v,d(c)) -\n    ι₁₁(V,d(c)) -\n    ι₁₁(v,d(C)) -\n    FluxDivergence +\n    F\nend\nto_graphviz(tracer_conservation)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"This is Equation 2: \"Linear equation of state\" of seawater buoyancy.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"equation_of_state = @decapode begin\n  (b,T,S)::DualForm0\n  (g,α,β)::Constant\n\n  b == g*(α*T - β*S)\nend\nto_graphviz(equation_of_state)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"This is Equation 2: \"Constant isotropic diffusivity\".","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"isotropic_diffusivity = @decapode begin\n  v::DualForm1\n  c::DualForm0\n  StressDivergence::DualForm1\n  FluxDivergence::DualForm0\n  (κ,nu)::Constant\n\n  StressDivergence == nu*Δᵈ₁(v)\n  FluxDivergence == κ*Δᵈ₀(c)\nend\nto_graphviz(isotropic_diffusivity)","category":"page"},{"location":"nhs/nhs_lite/#Compatibility-Guarantees-via-Operadic-Composition","page":"NHS","title":"Compatibility Guarantees via Operadic Composition","text":"","category":"section"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Decapodes composition is formally known as an \"operad algebra\". That means that we don't have to encode our composition in a single undirected wiring diagram (UWD) and then apply it. Rather, we can define several UWDs, compose those, and then apply those. Of course, since the output of oapply is another Decapode, we could perform an intermediate oapply, if that is convenient.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Besides it being convenient to break apart large UWDs into component UWDs, this hierarchical composition can enforce rules on our physical quantities.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"For example:","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"We want all the tracers (salinity, temperature, etc.) in our physics to obey the same conservation equation.\nWe want them to obey the same \"turbulence closure\", which affects their flux-divergence term.\nAt the same time, a choice of turbulence closure doesn't just affect (each of) the flux-divergence terms, it also constrains which stress-divergence is physically valid in the momentum equation.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"We will use our operad algebra to guarantee model compatibility and physical consistency, guarantees that would be burdensome to fit into a one-off type system.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Here, we specify the equations that any tracer obeys:","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"tracer_composition = @relation () begin\n  # \"The turbulence closure selected by the user determines the form of ... diffusive flux divergence\"\n  turbulence(FD,v,c)\n\n  continuity(FD,v,c)\nend\ndraw_composition(tracer_composition)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Let's \"lock in\" isotropic diffusivity by doing an intermediate oapply.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"isotropic_tracer = apex(oapply(tracer_composition, [\n  Open(isotropic_diffusivity, [:FluxDivergence, :v, :c]),\n  Open(tracer_conservation,   [:FluxDivergence, :v, :c])]))\nto_graphviz(isotropic_tracer)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"Let's use this building-block tracer physics at the next level. The quotes that appear in this composition diagram appear directly in the Oceananigans.jl docs.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"nonhydrostatic_composition = @relation () begin\n  # \"The turbulence closure selected by the user determines the form of stress divergence\"\n  #   => Note that the StressDivergence term, SD, is shared by momentum and all the tracers.\n  momentum(V, v, b, SD)\n\n  # \"Both T and S obey the tracer conservation equation\"\n  #   => Temperature and Salinity both receive a copy of the tracer physics.\n  temperature(V, v, T, SD, nu)\n  salinity(V, v, S, SD, nu)\n\n  # \"Buoyancy is determined from a linear equation of state\"\n  #   => The b term in momentum is that described by the equation of state here.\n  eos(b, T, S)\nend\ndraw_composition(nonhydrostatic_composition)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"isotropic_nonhydrostatic_buoyancy = apex(oapply(nonhydrostatic_composition, [\n  Open(momentum,          [:V, :v, :b, :StressDivergence]),\n  Open(isotropic_tracer,  [:continuity_V, :v, :c, :turbulence_StressDivergence, :turbulence_nu]),\n  Open(isotropic_tracer,  [:continuity_V, :v, :c, :turbulence_StressDivergence, :turbulence_nu]),\n  Open(equation_of_state, [:b, :T, :S])]));\nto_graphviz(isotropic_nonhydrostatic_buoyancy)","category":"page"},{"location":"nhs/nhs_lite/#Our-Mesh","page":"NHS","title":"Our Mesh","text":"","category":"section"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"We execute these dynamics on the torus explicitly, instead of using a square with periodic boundary conditions.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"# This is a torus with resolution of its dual mesh similar to that\n# used by Oceananigans (explicitly represented as a torus, not as a\n# square with periodic boundary conditions!)\nDownloads.download(\"https://cise.ufl.edu/~luke.morris/torus.obj\", \"torus.obj\")\ns = EmbeddedDeltaSet2D(joinpath(@__DIR__, \"torus.obj\"))\nsd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1) \nwf = wireframe!(ax, s; linewidth=1) \nsave(\"NHS_mesh.png\", fig) \nnothing # hide","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"(Image: \"NHS_torus\")","category":"page"},{"location":"nhs/nhs_lite/#Results","page":"NHS","title":"Results","text":"","category":"section"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"In the DEC, vorticity is encoded with d⋆, and speed can be encoded with norm ♯. We can use our operators from CombinatorialSpaces.jl to create our GIFs.","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"(Image: Vorticity)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"(Image: Speed)","category":"page"},{"location":"nhs/nhs_lite/","page":"NHS","title":"NHS","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"brussel/brussel/#Brusselator","page":"Brusselator","title":"Brusselator","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"This Brusselator example is adapted from DifferentialEquations.jl's page on the same topic. The Brusselator is a autocatalytic chemical reaction that takes place between two reactants U and V.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"include(joinpath(Base.@__DIR__, \"..\" , \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"brussel/brussel/#Dependencies","page":"Brusselator","title":"Dependencies","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"using CairoMakie\nimport CairoMakie: wireframe, mesh, Figure, Axis\n\nusing Catlab\nusing CombinatorialSpaces\nusing ComponentArrays\nusing DiagrammaticEquations\nusing Decapodes\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\n\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64}\nnothing # hide","category":"page"},{"location":"brussel/brussel/#The-Model","page":"Brusselator","title":"The Model","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We establish the model for the Brusselator, with the two reactants U and V, modeled as residing on the vertices of the mesh. The equations encode a reaction that occurs independently at each point coupled with a diffusion term as well as a source term F in the case of U. Here α denotes the rate of diffusion for both reactants.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"BrusselatorDynamics = @decapode begin\n  (U, V)::Form0\n  U2V::Form0\n  (U̇, V̇)::Form0\n\n  (α)::Constant\n  F::Parameter\n\n  U2V == (U .* U) .* V\n\n  U̇ == 1 + U2V - (4.4 * U) + (α * Δ(U)) + F\n  V̇ == (3.4 * U) - U2V + (α * Δ(V))\n  ∂ₜ(U) == U̇\n  ∂ₜ(V) == V̇\nend\nnothing # hide","category":"page"},{"location":"brussel/brussel/#Boundary-Conditions","page":"Brusselator","title":"Boundary Conditions","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We now establish the Dirichlet boundary conditions for our model. Here we intend to set some portion of the U variable to be a fixed value on some portion of the mesh. At this point the boundary conditions are only set symbolically and their actual implementation can change. Note that these values are set at the beginning of execution, as shown by the computation graph.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"BrusselatorBoundaries = @decapode begin\n  B::Constant\nend\n\nBrusselatorMorphism = @relation () begin\n  rlb(C, Cb)\nend\n\nBrusselator = collate(\n  BrusselatorDynamics,\n  BrusselatorBoundaries,\n  BrusselatorMorphism,\n  Dict(\n    :C => :U,\n    :Cb => :B))\n\nto_graphviz(Brusselator)","category":"page"},{"location":"brussel/brussel/#The-Mesh","page":"Brusselator","title":"The Mesh","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We load our triangulated mesh with horizontal and vertical resolution being h=0.01. Point3D is being used for the primal mesh s for ease of visualization while Point2D is used for the dual mesh sd for better memory usage. Since this conversion only drops the final z-coordinate, no information is lost.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"h = 0.01\ns = triangulated_grid(1,1,h,h,Point3D);\nsd = EmbeddedDeltaDualComplex2D{Bool,Float64,Point2D}(s);\nsubdivide_duals!(sd, Circumcenter());\n\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1) \nwf = wireframe!(ax, s; linewidth=1) \nsave(\"Brusselator_rect.png\", fig) \nnothing # hide","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"(Image: \"BrusselatorRect\")","category":"page"},{"location":"brussel/brussel/#Initial-data","page":"Brusselator","title":"Initial data","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We assign the initial values of U and V according to a continuous function. Since they both live on the vertices of our mesh, we can simply iterate over all point coordinates, extract the coordinate values (for either x or y) and compute the desired value. F has some logic attached to it encoding that it will \"activate\" only once the simulation has reached time t = 1.1.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"Here we also decide to set our boundary conditions to be 1.0 along the left and right sides of our mesh.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"U = map(sd[:point]) do (_,y)\n  22 * (y *(1-y))^(3/2)\nend\n\nV = map(sd[:point]) do (x,_)\n  27 * (x *(1-x))^(3/2)\nend\n\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1, title = \"Initial value of U\") \nmsh = CairoMakie.mesh!(ax, s, color=U, colormap=:jet, colorrange=extrema(U)) \nColorbar(fig[1,2], msh) \nsave(\"initial_U.png\", fig) \n\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1, title = \"Initial value of V\") \nmsh = CairoMakie.mesh!(ax, s, color=V, colormap=:jet, colorrange=extrema(V)) \nColorbar(fig[1,2], msh) \nsave(\"initial_V.png\", fig) \n\nF₁ = map(sd[:point]) do (x,y)\n (x-0.3)^2 + (y-0.6)^2 ≤ (0.1)^2 ? 5.0 : 0.0\nend\n\nF₂ = zeros(nv(sd))\n\nconstants_and_parameters = (\n  α = 0.001,\n  B = 1.0, # Boundary value\n  F = t -> t ≥ 1.1 ? F₁ : F₂)\nnothing # hide","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"(Image: Initial U Conditions) (Image: Initial V Conditions)","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"# Find left and right vertices of mesh\nmin_x = minimum(x -> x[1], s[:point])\nmax_x = maximum(x -> x[1], s[:point])\nleft_wall_idxs = findall(x -> x[1] == min_x, s[:point])\nright_wall_idxs = findall(x -> x[1] == max_x, s[:point])\nwall_idxs = vcat(left_wall_idxs, right_wall_idxs)\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :rlb => (x,y) -> begin\n      x[wall_idxs] .= y\n      x\n    end\n    _ => error(\"Unmatched operator $my_symbol\")\n  end\nend\n\nfig = Figure() \nax = CairoMakie.Axis(fig[1,1], aspect=1, title = \"Highlighted Boundary\") \nvalue = zeros(nv(sd)) \nvalue[wall_idxs] .= 1.0 \nmsh = CairoMakie.mesh!(ax, s, color=value, colormap=:jet, colorrange=(0,2)) \nColorbar(fig[1,2], msh) \nsave(\"boundary.png\", fig) \nnothing # hide","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"(Image: Boundary Visualized)","category":"page"},{"location":"brussel/brussel/#Generate-the-Simulation","page":"Brusselator","title":"Generate the Simulation","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We generate our simulation code and store the function in fₘ and then run our simulation for t=11.5 simulated time units.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"sim = evalsim(Brusselator)\nfₘ = sim(sd, generate, DiagonalHodge())\n\nu₀ = ComponentArray(U=U, V=V)\n\ntₑ = 11.5\n\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode","category":"page"},{"location":"brussel/brussel/#Visualize","page":"Brusselator","title":"Visualize","text":"","category":"section"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"We can then use Makie to visualize the evolution of our Brusselator model.","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"function save_dynamics(save_file_name)\n  time = Observable(0.0)\n  u = @lift(soln($time).U)\n  v = @lift(soln($time).V)\n  f = Figure(; size = (500, 850))\n  ax_U = CairoMakie.Axis(f[1,1], title = @lift(\"Concentration of U at Time $($time)\"))\n  ax_V = CairoMakie.Axis(f[2,1], title = @lift(\"Concentration of V at Time $($time)\"))\n\n  msh_U = mesh!(ax_U, s, color=u, colormap=:jet, colorrange=extrema(soln(tₑ).U))\n  Colorbar(f[1,2], msh_U)\n\n  msh_V = mesh!(ax_V, s, color=v, colormap=:jet, colorrange=extrema(soln(tₑ).V))\n  Colorbar(f[2,2], msh_V)\n\n  timestamps = range(0, tₑ, step=1e-1)\n  record(f, save_file_name, timestamps; framerate = 15) do t\n    time[] = t\n  end\nend\n\nsave_dynamics(\"brusselator.gif\")\nnothing # hide","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"(Image: Brusselator_results_flat)","category":"page"},{"location":"brussel/brussel/","page":"Brusselator","title":"Brusselator","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"poiseuille/poiseuille/#Poissuille-Flow-for-Fluid-Mechanics","page":"Pipe Flow","title":"Poissuille Flow for Fluid Mechanics","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"When modeling a fluid flowing in a pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The no-slip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\n\n# Julia community libraries\nusing CairoMakie\nusing GeometryBasics: Point3\nusing LinearAlgebra\nusing OrdinaryDiffEq\nPoint3D = Point3{Float64}\nnothing # hide","category":"page"},{"location":"poiseuille/poiseuille/#Creating-the-Poiseuille-Equations","page":"Pipe Flow","title":"Creating the Poiseuille Equations","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"For these physics, μ̃ represents the negative viscosity per unit area while R represents the drag of the pipe boundary.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Poise = @decapode begin\n  P::Form0\n  q::Form1\n  (R, μ̃ )::Constant\n\n  # Laplacian of q for the viscous effect\n  Δq == Δ(q)\n  # Gradient of P for the pressure driving force\n  ∇P == d(P)\n\n  # Definition of the time derivative of q\n  ∂ₜ(q) == q̇\n\n  # The core equation\n  q̇ == μ̃  * ∂q(Δq) + ∇P + R * q\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/poiseuille/#Defining-the-Semantics","page":"Pipe Flow","title":"Defining the Semantics","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The generate function below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. You can find the file for boundary conditions here.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using MLStyle\ninclude(\"../boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :∂q => x -> begin\n      x[boundary_edges(sd)] .= 0\n      x\n    end\n    :∂ρ => ρ -> begin\n      ρ[1] = 0\n      ρ[end] = 0\n      ρ\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return op\nend","category":"page"},{"location":"poiseuille/poiseuille/#A-Single-Pipe-Segment","page":"Pipe Flow","title":"A Single Pipe Segment","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"This simulation can be validated with the Poiseuille equation for a single pipe. First we create a mesh with one pipe segment.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"s = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])\nadd_edge!(s, 1, 2, edge_orientation=true)\n\nsd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(sd, Circumcenter())\nsd","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using ComponentArrays\nsim = eval(gensim(Poise, dimension=1))\nfₘ = sim(sd, generate)\nq = [2.0]\nP = [10.0, 5.0]\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsoln = solve(prob, Tsit5())\nsoln.u","category":"page"},{"location":"poiseuille/poiseuille/#A-Linear-Pipe-with-Multiple-Segments","page":"Pipe Flow","title":"A Linear Pipe with Multiple Segments","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into n segments. First we define the mesh:","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\n\nsd = linear_pipe(10)\nnothing # hide","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Note that we do not generate new simulation code for Poiseuille flow with gensim again. We simply need to provide our new mesh so that our discrete differential operators can be re-instantiated.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nP = [9,8,7,6,5,4,3,2,1,0]\nq = [5,3,4,2,5,2,8,4,3]\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5());\nsol.u","category":"page"},{"location":"poiseuille/poiseuille/#A-Distribution-Network","page":"Pipe Flow","title":"A Distribution Network","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"To model a distribution network, such as residential drinking water system, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function binary_pipe(depth::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertex!(s, point=Point3D(0, 0, 0))\n  for n in 1:depth\n    for prev_v in vertices(s)[end-2^(n-1)+1:end]\n      x, y, _ = s[:point][prev_v]\n      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)\n                                 for sgn in [1,-1]])\n      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)\n    end\n  end\n  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))\n  add_edge!(s, 1, v, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\nsd = binary_pipe(2)\nnothing # hide","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nP = collect(1.0:nv(sd))\nq = fill(5.0, ne(sd))\nu = ComponentArray(q=q,P=P)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/poiseuille/#Multiphysics","page":"Pipe Flow","title":"Multiphysics","text":"","category":"section"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow q and the pressure P to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The Decapode can be visualized with Graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# μ̃ = negative viscosity per unit area\n# R = drag of pipe boundary\n# k = pressure as a function of density\nPoise = @decapode begin\n  q::Form1\n  (P, ρ)::Form0\n  (k, R, μ̃ )::Constant\n\n  # Poiseuille Flow\n  ∂ₜ(q) == q̇\n  ∇P == d(P)\n  q̇ == μ̃ * ∂q(Δ(q)) - ∇P + R * q\n  \n  # Pressure/Density Coupling\n  P == k * ρ\n  ∂ₜ(ρ) == ρ̇\n  ρ_up == ∘(⋆, d, ⋆)(-1 * ∧₀₁(ρ,q)) # advection\n  \n  # Boundary conditions\n  ρ̇ == ∂ρ(ρ_up)\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we can create the mesh and solve the equation.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"sd = linear_pipe(20)\n\nsim = eval(gensim(Poise, dimension=1))\nfunc = sim(sd, generate)\n\nq = [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5]\nρ = [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5,5]\nu = ComponentArray(q=q,ρ=ρ)\nparams = (k = -0.01, μ̃ = 0.5, R=0.005)\n\nprob = ODEProblem(func, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Notice that the solution contains both a vector of flows and a vector of pressures.","category":"page"},{"location":"poiseuille/poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Budyko-Sellers-Halfar","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\",\"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"In this example, we will compose the Budyko-Sellers 1D energy balance model of the Earth's surface temperature with the Halfar model of glacial dynamics. Note that each of these components models is itself a composition of smaller physical models. In this walkthrough, we will compose them together using the same techniques.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing GeometryBasics: Point2\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing SparseArrays\nPoint2D = Point2{Float64};\nnothing # hide","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We have defined the Halfar ice model in other docs pages, and so will quickly define it here.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form0\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == Γ * ∘(⋆, d, ⋆)(d(h) * avg₀₁(mag(♯(d(h)))^(n-1)) * avg₀₁(h^(n+2)))\nend\n\nglens_law = @decapode begin\n  Γ::Form0\n  A::Form0\n  (ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\nice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n   Open(glens_law, [:Γ,:n])])\nhalfar = apex(ice_dynamics_cospan)\n\nto_graphviz(halfar, verbose=false)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We will introduce the Budyko-Sellers energy balance model in more detail. First, let's define the composite physics. We will visualize them all in a single diagram without any composition at first:","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"energy_balance = @decapode begin\n  (Tₛ, ASR, OLR, HT)::Form0\n  (C)::Constant\n\n  Tₛ̇ == ∂ₜ(Tₛ) \n\n  Tₛ̇ == (ASR - OLR + HT) ./ C\nend\n\nabsorbed_shortwave_radiation = @decapode begin\n  (Q, ASR)::Form0\n  α::Constant\n\n  ASR == (1 .- α) .* Q\nend\n\noutgoing_longwave_radiation = @decapode begin\n  (Tₛ, OLR)::Form0\n  (A,B)::Constant\n\n  OLR == A .+ (B .* Tₛ)\nend\n\nheat_transfer = @decapode begin\n  (HT, Tₛ)::Form0\n  (D,cosϕᵖ,cosϕᵈ)::Constant\n\n  HT == (D ./ cosϕᵖ) .* ⋆(d(cosϕᵈ .* ⋆(d(Tₛ))))\nend\n\ninsolation = @decapode begin\n  Q::Form0\n  cosϕᵖ::Constant\n\n  Q == 450 * cosϕᵖ\nend\n\nto_graphviz(oplus([energy_balance, absorbed_shortwave_radiation, outgoing_longwave_radiation, heat_transfer, insolation]), directed=false)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Now let's compose the Budyko-Sellers model together. We first specify a composition shape by declaring there are models called energy with four inputs, absorbed_radiation with two inputs, etc.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_composition_diagram = @relation () begin\n  energy(Tₛ, ASR, OLR, HT)\n  absorbed_radiation(Q, ASR)\n  outgoing_radiation(Tₛ, OLR)\n  diffusion(Tₛ, HT, cosϕᵖ)\n  insolation(Q, cosϕᵖ)\nend\n\ndraw_composition(budyko_sellers_composition_diagram)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We've obtained a composition shape. Now we oapply the composition diagram to a list of open models. By \"opening\" the models, we're specifying that they are models with inputs exposed to a larger system.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_cospan = oapply(budyko_sellers_composition_diagram,\n  [Open(energy_balance,               [:Tₛ, :ASR, :OLR, :HT]),\n   Open(absorbed_shortwave_radiation, [:Q, :ASR]),\n   Open(outgoing_longwave_radiation,  [:Tₛ, :OLR]),\n   Open(heat_transfer,                [:Tₛ, :HT, :cosϕᵖ]),\n   Open(insolation,                   [:Q, :cosϕᵖ])])\n\nbudyko_sellers = apex(budyko_sellers_cospan)\n\n# Save this Decapode as a JSON file\nwrite_json_acset(budyko_sellers, \"budyko_sellers.json\") \n\nto_graphviz(budyko_sellers, verbose=false)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"The resulting system is a cospan diagram which specifies how each subsystem fits.","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Warming","page":"Budyko-Sellers-Halfar","title":"Warming","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We need to specify physically what it means for these two terms to interact. We will say that ice will diffuse faster as temperature increases, and will pick some coefficients that demonstrate interesting dynamics on short timescales.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"warming = @decapode begin\n  Tₛ::Form0\n  A::Form0\n  \n  A == 5.8282*10^(-0.236 * Tₛ)*1.65e7\nend\n\nto_graphviz(warming)","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Composition","page":"Budyko-Sellers-Halfar","title":"Composition","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Observe that Decapodes composition is hierarchical. This composition technique is the same as that used in composing each of the Budyko-Sellers and Halfar models.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_composition_diagram = @relation () begin\n  budyko_sellers(Tₛ)\n  warming(A, Tₛ)\n  halfar(A)\nend\n\ndraw_composition(budyko_sellers_halfar_composition_diagram)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We apply a composition by plugging in a Decapode for each component. We also specify the internal name of the variables to be used in combining.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_cospan = oapply(budyko_sellers_halfar_composition_diagram,\n  [Open(budyko_sellers, [:Tₛ]),\n   Open(warming,        [:A, :Tₛ]),\n   Open(halfar,         [:stress_A])])\nbudyko_sellers_halfar = apex(budyko_sellers_halfar_cospan)\n\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can perform type inference to determine what kind of differential form each of our variables are. This is done automatically with the dimension=1 keyword given to gensim, but we will do it in-place for demonstration purposes.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar = expand_operators(budyko_sellers_halfar)\ninfer_types!(budyko_sellers_halfar, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(budyko_sellers_halfar, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Defining-the-mesh","page":"Budyko-Sellers-Halfar","title":"Defining the mesh","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"These dynamics will occur on a 1-D manifold (a line). Points near +-π/2 will represent points near the North/ South poles. Points near 0 represent those at the equator.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"s = EmbeddedDeltaSet1D{Bool, Point2D}()\nadd_vertices!(s, 100, point=Point2D.(range(-π/2 + π/32, π/2 - π/32, length=100), 0))\nadd_edges!(s, 1:nv(s)-1, 2:nv(s))\norient!(s)\nsd = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s)\nsubdivide_duals!(sd, Circumcenter())","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Define-input-data","page":"Budyko-Sellers-Halfar","title":"Define input data","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We need to supply initial conditions to our model. We will use synthetic data here.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# This is a primal 0-form, with values at vertices.\ncosϕᵖ = map(x -> cos(x[1]), point(s))\n\n# This is a dual 0-form, with values at edge centers.\ncosϕᵈ = map(edges(s)) do e\n  (cos(point(s, src(s, e))[1]) + cos(point(s, tgt(s, e))[1])) / 2\nend\n\nα₀ = 0.354\nα₂ = 0.25\nα = map(point(s)) do ϕ\n  α₀ + α₂*((1/2)*(3*ϕ[1]^2 - 1))\nend\nA = 210\nB = 2\nf = 0.70\nρ = 1025\ncw = 4186\nH = 70\nC = map(point(s)) do ϕ\n  f * ρ * cw * H\nend\nD = 0.6\n\n# Isothermal initial conditions:\nTₛ₀ = map(point(s)) do ϕ\n  15\nend\n\n# Visualize initial condition for temperature.\nlines(map(x -> x[1], point(s)), Tₛ₀)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"n = 3\nρ = 910\ng = 9.8\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s)) do (x,_)\n  (((x)^2)+2.5) / 1e3\nend\n\n# Visualize initial condition for ice sheet height.\nlines(map(x -> x[1], point(s)), h₀)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# Store these values to be passed to the solver.\nu₀ = ComponentArray(Tₛ=Tₛ₀, halfar_dynamics_h=h₀)\n\nconstants_and_parameters = (\n  budyko_sellers_absorbed_radiation_α = α,\n  budyko_sellers_outgoing_radiation_A = A,\n  budyko_sellers_outgoing_radiation_B = B,\n  budyko_sellers_energy_C = C,\n  budyko_sellers_diffusion_D = D,\n  budyko_sellers_cosϕᵖ = cosϕᵖ,\n  budyko_sellers_diffusion_cosϕᵈ = cosϕᵈ,\n  halfar_n = n,\n  halfar_stress_ρ = ρ,\n  halfar_stress_g = g)","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Symbols-to-functions","page":"Budyko-Sellers-Halfar","title":"Symbols to functions","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"The symbols along edges in our Decapode must be mapped to executable functions. In the Discrete Exterior Calculus, all our operators are defined as relations between points, lines, and triangles on meshes known as simplicial sets. Thus, DEC operators are re-usable across any simplicial set.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    x => default_dec_generate(sd, my_symbol, hodge)\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Simulation-generation","page":"Budyko-Sellers-Halfar","title":"Simulation generation","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"From our Decapode, we automatically generate a finite difference method solver that performs explicit time-stepping to solve our system of multiphysics equations.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"sim = eval(gensim(budyko_sellers_halfar, dimension=1))\nfₘ = sim(sd, generate)","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Run-simulation","page":"Budyko-Sellers-Halfar","title":"Run simulation","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We wrap our simulator and initial conditions and solve them with the stability-detection and time-stepping methods provided by DifferentialEquations.jl .","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"tₑ = 1e6\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can save the solution file to examine later.","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"@save \"budyko_sellers_halfar.jld2\" soln","category":"page"},{"location":"bsh/budyko_sellers_halfar/#Visualize","page":"Budyko-Sellers-Halfar","title":"Visualize","text":"","category":"section"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for temperature:","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s)), soln(tₑ).Tₛ)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for ice height:","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s)), soln(tₑ).halfar_dynamics_h)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"begin\n# Initial frame\nframes = 100\nfig = Figure()\nax1 = CairoMakie.Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s))))\nylims!(ax1, extrema(soln(tₑ).Tₛ))\nax1.xlabel = \"Line plot of temperature from North to South pole, every $(tₑ/frames) time units\"\nLabel(fig[1,1,Top()], \"Surface temperature, Tₛ, [C°]\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_T.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s)), soln(t).Tₛ)\nend\nend\n\nbegin\n# Initial frame\nframes = 100\nfig = Figure()\nax1 = CairoMakie.Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s))))\nylims!(ax1, extrema(soln(tₑ).halfar_dynamics_h))\nax1.xlabel = \"Line plot of temperature from North to South pole, every $(tₑ/frames) time units\"\nLabel(fig[1,1,Top()], \"Ice height, h\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_h.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s)), soln(t).halfar_dynamics_h)\nend\nend","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_Temperature)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_IceHeight)","category":"page"},{"location":"bsh/budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"klausmeier/klausmeier/#Klausmeier","page":"Klausmeier","title":"Klausmeier","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"include(joinpath(Base.@__DIR__, \"..\" , \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"(Image: Somaliland Vegetation)","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"<figure>\n    <figcaption>One of the first aerial photographs of British Somaliland (now Somaliland) investigated by W.A. Macfadyen in his 1950 \"Vegetation Patterns in the Semi-Desert Plains of British Somaliland\" [1]. From this point of view, Macfadyen's \"vegetation arcs\" are plainly visible.</figcaption>\n</figure>","category":"page"},{"location":"klausmeier/klausmeier/#Background","page":"Klausmeier","title":"Background","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"From aerial photographs in the late 1940s, British ecologist W.A. Macfadyen discovered that vegetation in semi-arid environments often grows in striping patterns, but was unaware of the exact mechanism that causes them. What is especially striking about these \"vegetation arcs\" is that these stripes appear to climb uphill, with denser plant growth at the leading edge of these traveling waves. Much like how the Mandelbrot set and other interesting fractal patterns can arise from simple sets of rules, these vegetation dynamics can be explained by simple sets of partial differential equations.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The Klausmeier model, given by Christopher Klausmeier in his 1999 paper Regular and Irregular Patterns in Semiarid Vegetation[2], models such dynamics. Although Macfadyen had discovered these vegetation patterns 50s years prior[1,3], defining these dynamics through accessible and physically-meaningful PDEs proved a catalyst for further research. At the time of writing, Klausmeier's paper has been cited 594 times.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"In this document, we will use Decapodes to formally represent these equations. Moreover, we will demonstrate how one can automatically generate simulation that reproduces the dynamics given by a scientist, simply by reading in the equations given in their original publication.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The lofty goal of this document, and of Decapodes itself, is that through both explicitly representing a model - such as Klausmeier's - and handling the generation of simulation code, we can amplify its accessibility and composability, and ultimately spur further research. Lets start by using Decapodes.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"(Image: Klausmeier GIF)","category":"page"},{"location":"klausmeier/klausmeier/#using-Decapodes","page":"Klausmeier","title":"using Decapodes","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Load Dependencies\nusing CairoMakie\nusing Catlab\nusing CombinatorialSpaces\nusing ComponentArrays\nusing Decapodes\nusing DiagrammaticEquations\nusing DiagrammaticEquations.Deca\nusing Distributions\nusing GeometryBasics: Point2\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nPoint2D = Point2{Float64}\nnothing # hide","category":"page"},{"location":"klausmeier/klausmeier/#Model-Representation","page":"Klausmeier","title":"Model Representation","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The Klausmeier model consists of two parts: one governing plant growth (phytodynamics), and one governing hydrodynamics. The differential operator Δ represents the diffusion of vegetation, and the \"Lie derivative\" operator ℒ represents the change of water in a direction. In this case, the flow of water downhill, \"dX\".","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Decapodes are written in the language of the Exterior Calculus, which generalizes Vector Calculus. For us, that means that we get to specify whether a physical quantity should valued at points in our domain (i.e. primal and dual Form0s), or whether they are more vector-like quantities, that should be valued along edges in our domain (i.e. primal and dual Form1s). In this case, water density w and vegetation density n are both Form0s, while dX, the gradient of our hill, is a Form1.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# See Klausmeier Equation 2.a\nHydrodynamics = @decapode begin\n  (n,w)::DualForm0\n  dX::Form1\n  (a,ν)::Constant\n\n  ∂ₜ(w) == a - w - w * n^2 + ν * L(dX, w)\nend\n\n# See Klausmeier Equation 2.b\nPhytodynamics = @decapode begin\n  (n,w)::DualForm0\n  m::Constant\n\n  ∂ₜ(n) == w * n^2 - m*n + Δ(n)\nend\nnothing # hide","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Now that we have our two component models, we can specify a means of composing them via a composition pattern.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Specify Composition\ncompose_klausmeier = @relation () begin\n  phyto(N, W)\n  hydro(N, W)\nend\n\ndraw_composition(compose_klausmeier)","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We apply our composition pattern by plugging in component Decapodes, and specifying which internal quantities to share along edges. Decapodes are formalized via the field of Applied Category Theory. A practical consequence here is that we can view a Decapode as a sort of computation graph.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Apply Composition\nklausmeier_cospan = oapply(compose_klausmeier,\n                           [Open(Phytodynamics, [:n, :w]),\n                            Open(Hydrodynamics, [:n, :w])])\nKlausmeier = apex(klausmeier_cospan)\nto_graphviz(Klausmeier)","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"With our model now explicitly represented, we have everything we need to automatically generate simulation code. We could write this to an intermediate file and use it later, or we can go ahead and evaluate the code in this session.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"sim = eval(gensim(Klausmeier, dimension=1))","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We now need a mesh to define our domain. In the 2D case, our CombinatorialSpaces library can read in arbitrary .OBJ files. In 1D, it is often simpler to just generate a mesh on the fly. Since we are running our physics on a circle - i.e periodic boundaries - we will use a simple function that generates it.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We will visualize the mesh embedded in two dimensions here, but in later visualizations, we can represent it as a periodic line.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Define Mesh\nfunction circle(n, c)\n  mesh = EmbeddedDeltaSet1D{Bool, Point2D}()\n  map(range(0, 2pi - (pi/(2^(n-1))); step=pi/(2^(n-1)))) do t\n    add_vertex!(mesh, point=Point2D(cos(t),sin(t))*(c/2pi))\n  end\n  add_edges!(mesh, 1:(nv(mesh)-1), 2:nv(mesh))\n  add_edge!(mesh, nv(mesh), 1)\n  dualmesh = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(mesh)\n  subdivide_duals!(dualmesh, Circumcenter())\n  mesh,dualmesh\nend\nmesh,dualmesh = circle(9, 500)\n\nscatter(dualmesh[:point])","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's pass our mesh and methods of generating operators to our simulation code.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Instantiate Simulation\n\nlap_mat = dec_hodge_star(1,dualmesh) * dec_differential(0,dualmesh) * dec_inv_hodge_star(0,dualmesh) * dec_dual_derivative(0,dualmesh)\n\nfunction generate(sd, my_symbol; hodge=DiagonalHodge())\n  op = @match my_symbol begin\n    :Δ => x -> begin\n      lap_mat * x\n    end\n  end\n  return (args...) -> op(args...)\nend\n\n\nfₘ = sim(dualmesh, generate, DiagonalHodge())","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"With our simulation now ready, let's specify initial data to pass to it. We'll define them with plain Julia code.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The most interesting parameter here is our \"downhill gradient\" dX. This parameter defines how steep our slope is. Since our mesh is a circle, and we are setting dX to a constant value, this means that \"downhill\" always points counter-clockwise. Essentially, this is an elegant way of encoding an infinite hill.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Define Initial Conditions\nn_dist = Normal(pi)\nn = [pdf(n_dist, t)*(√(2pi))*7.2 + 0.08 - 5e-2 for t in range(0,2pi; length=ne(dualmesh))]\n\nw_dist = Normal(pi, 20)\nw = [pdf(w_dist, t) for t in range(0,2pi; length=ne(dualmesh))]\n\ndX = dualmesh[:length]\n\nu₀ = ComponentArray(N = n, W = w, hydro_dX = dX)\n\ncs_ps = (phyto_m = 0.45,\n         hydro_a = 0.94,\n         hydro_ν = 182.5)","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's execute our simulation.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Run Simulation\ntₑ = 300.0\nproblem = ODEProblem(fₘ, u₀, (0.0, tₑ), cs_ps)\nsolution = solve(problem, Tsit5(), saveat=0.1, save_idxs=[:N, :W])\nsolution.retcode","category":"page"},{"location":"klausmeier/klausmeier/#Animation","page":"Klausmeier","title":"Animation","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Let's perform some basic visualization and analysis of our results to verify our dynamics.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"n = solution(0).N\nnₑ = solution(tₑ).N\nw = solution(0).W\nwₑ = solution(tₑ).W\nnothing # hide","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"# Animate dynamics\nfunction save_dynamics(form_name, framerate, filename)\n  time = Observable(0.0)\n  ys = @lift(getproperty(solution($time), form_name))\n  xcoords = [0, accumulate(+, dualmesh[:length])[1:end-1]...]\n  fig = lines(xcoords, ys, color=:green, linewidth=4.0,\n    colorrange=extrema(getproperty(solution(0), form_name));\n    axis = (; title = @lift(\"Klausmeier $(String(form_name)) at $($time)\")))\n  timestamps = range(0, tₑ, step=1)\n  record(fig, filename, timestamps; framerate=framerate) do t\n    time[] = t\n  end\nend\nsave_dynamics(:N, 20, \"klausmeier.gif\")","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"(Image: Klausmeier)","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"We can observe a few interesting phenomena that we wanted to capture:","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"The vegetation density bands move uphill in traveling waves.\nThe leading edge of the waves is denser than the rest of the band.\nOver time, the periodicity of the vegetation bands stabilizes.\nThe distribution naturally emerges, despite the initial distribution is a simple normal distribution.\nThis is evidence against the real-world theory that these vegetation contours are the result of an initial (man-made) distribution.","category":"page"},{"location":"klausmeier/klausmeier/#Conclusion","page":"Klausmeier","title":"Conclusion","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"Due to the ease of composition of Decapodes, representing the Klausmeier model opens up many areas for future work. For example, we can now compose these dynamics with a model of temperature dynamics informed by the Budyko-Sellers model. We can take advantage of the fact that the Lie derivative generalizes partial derivatives, and model the flow of water according to any vector field. Or, we can extend this model by composing it with a model that can recreate the so-called \"leopard pattern\" of vegetation, such as an \"Interaction-Dispersion\" model of vegetation dynamics given by Lejeune et al[4].","category":"page"},{"location":"klausmeier/klausmeier/#References","page":"Klausmeier","title":"References","text":"","category":"section"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[1] W. A. Macfadyen, “Vegetation Patterns in the Semi-Desert Plains of British Somaliland,” The Geographical Journal, vol. 116, no. 4/6, p. 199, Oct. 1950, doi: 10.2307/1789384.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[2] C. A. Klausmeier, “Regular and Irregular Patterns in Semiarid Vegetation,” Science, vol. 284, no. 5421, pp. 1826–1828, Jun. 1999, doi: 10.1126/science.284.5421.1826.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[3] W. A. Macfadyen, “Soil and Vegetation in British Somaliland,” Nature, vol. 165, no. 4186, Art. no. 4186, Jan. 1950, doi: 10.1038/165121a0.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"[4] O. Lejeune and M. Tlidi, “A Model for the Explanation of Vegetation Stripes (Tiger Bush),” Journal of Vegetation Science, vol. 10, no. 2, pp. 201–208, 1999, doi: 10.2307/3237141.","category":"page"},{"location":"klausmeier/klausmeier/","page":"Klausmeier","title":"Klausmeier","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"grigoriev/grigoriev/#Halfar's-model-of-glacial-flow","page":"Grigoriev Ice Cap","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"include(joinpath(Base.@__DIR__, \"..\" , \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's run the Halfar shallow ice / shallow slope model on some \"real world\" data for ice thickness. Van Tricht et al. in their 2023 communication Measuring and modelling the ice thickness of the Grigoriev ice cap (Kyrgyzstan) and comparison with global dataset published ice thickness data on an ice cap and stored their data in a TIF. In this document, we will demonstrate how to parse such data and execute a Decapodes model on these initial conditions.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"For the parameters to Glen's law, we will use those used in the Community Ice Sheet Model benchmark. Of course, the parameters of this Kyrgyzstani ice cap likely differ from these by quite some amount, but they are a good place to start. Further, this ice cap does not satisfy the \"shallow slope\" assumption across the entire domain.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing DiagrammaticEquations\nusing Decapodes\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing FileIO  \nusing GeometryBasics: Point2\nusing Interpolations\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nusing SparseArrays\nPoint2D = Point2{Float64}\nPoint3D = Point3{Float64};\nnothing # hide","category":"page"},{"location":"grigoriev/grigoriev/#Loading-a-Scientific-Dataset","page":"Grigoriev Ice Cap","title":"Loading a Scientific Dataset","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"The ice thickness data is stored in a TIF that can be downloaded here. We have downloaded it locally, and load it using basic FileIO.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"file_name = \"Icethickness_Grigoriev_ice_cap_2021.tif\"\nice_thickness_tif = load(file_name)","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"This data may visually appear to be a binary mask but that is only because values with no ice are set to -Inf. We will account for this when interpolate our data.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"We use the Interpolations.jl library to interpolate this dataset:","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Taking the coordinates to be from the extrema of the measured points:\nconst MIN_X = 4648894.5\nconst MAX_X = 4652179.7\nconst MIN_Y = 243504.5\nconst MAX_Y = 245599.8\nice_coords = (range(MIN_X, MAX_X, length=size(ice_thickness_tif,1)),\n              range(MIN_Y, MAX_Y, length=size(ice_thickness_tif,2)))\n\n# Note that the TIF is set to -floatmax(Float32) where there is no ice.\n# For our purposes, this is equivalent to 0.0.\nice_interp = LinearInterpolation(ice_coords, Float32.(ice_thickness_tif))","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"To use this interpolating object ice_interp, we can simply query it for the value at some coordinates: ice_interp(x,y).","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"Let's generate a triangulated grid located at the appropriate coordinates:","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Specify a resolution:\nRES_Y = (MAX_Y-MIN_Y)/30.0\nRES_X = RES_Y\n\n# Generate the mesh with appropriate dimensions and resolution:\ns = triangulated_grid(MAX_X-MIN_X, MAX_Y-MIN_Y, RES_X, RES_Y, Point3D)\n\n# Shift it into place:\ns[:point] = map(x -> x + Point3D(MIN_X, MIN_Y, 0), s[:point])\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1])\nwf = wireframe!(ax, s)\nsave(\"Grigoriev_IceMesh.png\", fig)\nnothing # hide","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"(Image: \"Grigoriev_IceMesh\")","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"The coordinates of a vertex are stored in sd[:point]. Let's use our interpolator to assign ice thickness values to each vertex in the mesh:","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# These are the values used by the CISM benchmark:\nn = 3\nρ = 910\ng = 9.8101\nA = 1e-16\n\nh₀ = map(sd[:point]) do (x,y,_)\n  tif_val = ice_interp(x,y)\n  # Accommodate for the -∞'s that encode \"no ice\".\n  tif_val < 0.0 ? 0.0 : tif_val\nend\n\n# Store these values to be passed to the solver.\nu₀ = ComponentArray(h=h₀, stress_A=A)\nconstants_and_parameters = (n = n, \n                            stress_ρ = ρ,\n                            stress_g = g, \n                            stress_A = A)\nnothing # hide","category":"page"},{"location":"grigoriev/grigoriev/#Defining-and-Composing-Models","page":"Grigoriev Ice Cap","title":"Defining and Composing Models","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"For exposition on this Halfar Decapode, see our Glacial Flow docs page. Otherwise, you may skip ahead to the next section.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form0\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == Γ * ∘(⋆, d, ⋆)(d(h) ∧₁₀ ((mag(♯ᵖᵖ(d(h)))^(n-1)) ∧₀₀ h^(n+2)))\nend\n\nglens_law = @decapode begin\n  Γ::Form0\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(h,Γ,n)\n  stress(Γ,n)\nend\n\nice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:h,:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"grigoriev/grigoriev/#Generate-simulation","page":"Grigoriev Ice Cap","title":"Generate simulation","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"sim = eval(gensim(ice_dynamics, dimension=2))\nfₘ = sim(sd, nothing)","category":"page"},{"location":"grigoriev/grigoriev/#Run","page":"Grigoriev Ice Cap","title":"Run","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"tₑ = 10\n\n@info(\"Solving Grigoriev Ice Cap\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\n@save \"grigoriev.jld2\" soln","category":"page"},{"location":"grigoriev/grigoriev/#Results-and-Discussion","page":"Grigoriev Ice Cap","title":"Results and Discussion","text":"","category":"section"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"# Visualize the initial conditions.\nfunction plot_ic()\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1],\n            title=\"Grigoriev Ice Cap Initial Thickness [m]\",\n            xticks = range(MIN_X, MAX_X; length=5),\n            yticks = range(MIN_Y, MAX_Y; length=5))\n  msh = mesh!(ax, s, color=soln(0.0).h, colormap=:jet)\n  Colorbar(f[1,2], msh)\n  f\nend\nf = plot_ic()\nsave(\"grigoriev_ic.png\", f)\n\n# Visualize the final conditions.\nfunction plot_fc()\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1],\n            title=\"Grigoriev Ice Cap Final Thickness [m]\",\n            xticks = range(MIN_X, MAX_X; length=5),\n            yticks = range(MIN_Y, MAX_Y; length=5))\n  msh = mesh!(ax, s, color=soln(tₑ).h, colormap=:jet)\n  Colorbar(f[1,2], msh)\n  f\nend\nf = plot_fc()\nsave(\"grigoriev_fc.png\", f)\n\n# Create a gif\nfunction save_dynamics(save_file_name)\n  time = Observable(0.0)\n  h = @lift(soln($time).h)\n  f = Figure()\n  ax = CairoMakie.Axis(f[1,1], title = @lift(\"Grigoriev Ice Cap Dynamic Thickness [m] at time $($time)\"))\n  gmsh = mesh!(ax, s, color=h, colormap=:jet,\n               colorrange=extrema(soln(tₑ).h))\n  #Colorbar(f[1,2], gmsh, limits=extrema(soln(tₑ).h))\n  Colorbar(f[1,2], gmsh)\n  timestamps = range(0, tₑ, step=1e-1)\n  record(f, save_file_name, timestamps; framerate = 15) do t\n    time[] = t\n  end\nend\nsave_dynamics(\"grigoriev.gif\")","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"We observe the usual Halfar model phenomena of ice \"melting\". Note that since the \"shallow slope\" approximation does not hold on the boundaries (due to the so-called \"ice cliffs\" described in the Van Tricht et al. paper), we do not expect the \"creep\" effect to be physical in this region of the domain. Rather, the Halfar model's predictive power is tuned for the interiors of ice caps and glaciers. Note that we also assume here that the bedrock that the ice rests on is flat. We may in further documents demonstrate how to use topographic data from Digital Elevation Models to inform the elevation of points in the mesh itself.","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"(Image: Grigoriev_ICs)","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"(Image: Grigoriev_FCs)","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"(Image: Grigoriev_Dynamics)","category":"page"},{"location":"grigoriev/grigoriev/","page":"Grigoriev Ice Cap","title":"Grigoriev Ice Cap","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"concepts/composition/#Composition","page":"Composition","title":"Composition","text":"","category":"section"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"using Catlab \nusing DiagrammaticEquations \nusing Decapodes ","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"<details open>\n  <summary><i>Dependencies</i></summary>\n  <pre><code>\n  using Catlab\n  using DiagrammaticEquations\n  using Decapodes\n  </code></pre>\n</details>","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"Decapodes composition is formally known as an \"operad algebra\". That means that we don't have to encode our composition in a single undirected wiring diagram (UWD) and then apply it. Rather, we can define several UWDs, compose those, and then apply those. Of course, since the output of oapply is another Decapode, we could perform an intermediate oapply, if that is convenient. In this tutorial we will learn how to use this capability to define more complex models, and how this modularity allows us to swap out models.","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"Besides it being convenient to break apart large UWDs into component UWDs, this hierarchical composition can enforce rules on our physical quantities.","category":"page"},{"location":"concepts/composition/#Example:-Klausmeier","page":"Composition","title":"Example: Klausmeier","text":"","category":"section"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"We will study how the Klausmeier model uses the operad algebra to describe a phenomenon of vegetation patterns can be governed by the interaction of two different dynamics.","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"# See Klausmeier Equation 2.a\nHydrodynamics = @decapode begin\n  (n,w)::DualForm0\n  dX::Form1\n  (a,ν)::Constant\n\n  ∂ₜ(w) == a - w - w * n^2 + ν * L(dX, w)\nend\n\n# See Klausmeier Equation 2.b\nPhytodynamics = @decapode begin\n  (n,w)::DualForm0\n  m::Constant\n\n  ∂ₜ(n) == w * n^2 - m*n + Δ(n)\nend\nnothing # hide","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"However let's for a moment pretend we don't have a very good understanding of the hydrodynamics. We'll create an incorrect model:","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"WrongHydrodynamics = @decapode begin\n    (n,w)::DualForm0\n    dX::Form1\n    ∂ₜ(w) == L(dX, w)\nend\nnothing # hide","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"Now that we have our two component models, we can specify a means of composing them via a composition pattern. This defines placeholder models which accept variables as inputs. If the variables between any two models are the same, then we have asserted that they are shared. For example, in this @relation diagram, we assert that there are two models, phyto and hydro, which each share the N and W variables.","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"# Specify Composition\ncompose_klausmeier = @relation () begin\n  phyto(N, W)\n  hydro(N, W)\nend\n\ndraw_composition(compose_klausmeier)","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"We apply our composition pattern by plugging in component Decapodes, and specifying which internal quantities to share along edges. Decapodes are formalized via the field of Applied Category Theory. A practical consequence here is that we can view a Decapode as a sort of computation graph.","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"# Apply Composition\nklausmeier_cospan = oapply(compose_klausmeier,\n                           [Open(Phytodynamics, [:n, :w]),\n                            Open(WrongHydrodynamics, [:n, :w])])\nKlausmeier = apex(klausmeier_cospan)\nto_graphviz(Klausmeier)","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"Let's pretend our understanding of the hydrodynamics model has improved. Since the composition pattern has not changed, we can just substitute the WrongHydrodynamics model out for the correct one.","category":"page"},{"location":"concepts/composition/","page":"Composition","title":"Composition","text":"# Apply Composition\nklausmeier_cospan = oapply(compose_klausmeier,\n                           [Open(Phytodynamics, [:n, :w]),\n                            Open(Hydrodynamics, [:n, :w])])\nKlausmeier = apex(klausmeier_cospan)\nto_graphviz(Klausmeier)","category":"page"},{"location":"halmo/halmo/#Couple-Ice-and-Water-Dynamics","page":"Halfar-NS","title":"Couple Ice and Water Dynamics","text":"","category":"section"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Let's use Decapodes to implement the incompressible Navier-Stokes as given by Mohamed et al.. We will run these dynamics on the sphere. We will couple this model with Halfar glacier dynamics on the sphere. For the initial conditions of the Halfar ice thickness, we will use an idealized polar ice cap.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Note that the time scale at which ice creeps is much larger than the time scale at which the water in the ocean would flow. So we can either choose to model a very slow moving fluid around the ice (like a storm on a gas giant), or we can choose to model on a shorter timescale, on which the ice does not move very much.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing CombinatorialSpaces\nusing Decapodes\nusing DiagrammaticEquations\n\n# External Dependencies\nusing CairoMakie\nusing ComponentArrays\nusing GeometryBasics: Point3\nusing JLD2\nusing LinearAlgebra\nusing MLStyle\nusing OrdinaryDiffEq\nPoint3D = Point3{Float64};\nnothing # hide","category":"page"},{"location":"halmo/halmo/#Specify-our-models","page":"Halfar-NS","title":"Specify our models","text":"","category":"section"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Our first component is the Mohamed et al. formulation of the incompressible Navier-Stokes equations. We will call the flow here \"w\". This will be the flow after collisions with glaciers are considered.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"This is Equation 10 for N=2.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"eq10forN2 = @decapode begin\n  (𝐮,w)::DualForm1\n  (P, 𝑝ᵈ)::DualForm0\n  μ::Constant\n\n  𝑝ᵈ == P + 0.5 * ι₁₁(w,w)\n\n  ∂ₜ(𝐮) == μ * ∘(d, ⋆, d, ⋆)(w) + (-1)*⋆₁⁻¹(∧ᵈᵖ₁₀(w, ⋆(d(w)))) + d(𝑝ᵈ)\nend\nto_graphviz(eq10forN2)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Halfar's equation and Glen's law are composed like so:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form0\n  n::Constant\n\n  ∂ₜ(h) == Γ * ∘(⋆, d, ⋆)(d(h) ∧₁₀ ((mag(♯ᵖᵖ(d(h)))^(n-1)) ∧₀₀ h^(n+2)))\nend\n\nglens_law = @decapode begin\n  Γ::Form0\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\nice_dynamics = apex(oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n   Open(glens_law, [:Γ,:n])]))\n\nto_graphviz(ice_dynamics, verbose=false)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We now have our dynamics that govern glaciers, and our dynamics that govern water. We need to specify the physics of what happens when glaciers and water interact. There are many options, and the choice you make depends on the time-scale and resolution of the dynamics that you are interested in.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"An interaction between glacier and water dynamics can look like the following, where flow_after is the flow of water after interaction with ice is considered.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"ice_water_composition_diagram = @relation () begin\n  glacier_dynamics(ice_thickness)\n  water_dynamics(flow, flow_after)\n\n  interaction(ice_thickness, flow, flow_after)\nend\ndraw_composition(ice_water_composition_diagram)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We will use the language of Decapodes to encode the dynamics that ice blocks water from flowing.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We can detect the ice with a sigmoid function. Where there is ice, we want the flow to be 0, and where there is no ice, we will not impede the flow. We won't consider any further special boundary conditions between ice and water here. Since h is a scalar-like quantity, and flow is a vector-like quantity, we can relate them using the wedge product operator from the exterior calculus. We can state these dynamics using the language of Decapodes like so:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"blocking = @decapode begin\n  h::Form0\n  (𝐮,w)::DualForm1\n\n  w == (1-σ(h)) ∧ᵖᵈ₀₁ 𝐮\nend\nto_graphviz(blocking)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Here, σ is a sigmoid function that is 0 when d(h) is 0, and goes to 1 otherwise. We see that w is indeed defined as 𝐮, after interacting with the ice boundary is considered.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We can apply our composition diagram to generate our physics:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"ice_water = apex(oapply(ice_water_composition_diagram,\n  [Open(ice_dynamics, [:dynamics_h]),\n   Open(eq10forN2,    [:𝐮, :w]),\n   Open(blocking,     [:h, :𝐮, :w])]))\n\nto_graphviz(ice_dynamics, verbose=false)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We can now generate our simulation:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"sim = eval(gensim(ice_water))","category":"page"},{"location":"halmo/halmo/#Meshes-and-Initial-Conditions","page":"Halfar-NS","title":"Meshes and Initial Conditions","text":"","category":"section"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Since we want to demonstrate these physics on the Earth, we will use one of our icosphere discretizations with the appropriate radius.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"rₑ = 6378e3 # [km]\ns = loadmesh(Icosphere(5, rₑ))\nsd = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s)\nsubdivide_duals!(sd, Barycenter())\nwireframe(sd)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Let's demonstrate how to add operators by providing the definition of a sigmoid function:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"sigmoid(x) = (2 ./ (1 .+ exp.(-x*1e2)) .- 1)\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    # This is a new function.\n    :σ => sigmoid\n    # Remaining operations (such as our differential operators) are built-in.\n    _ => error(\"Unmatched operator $my_symbol\")\n  end\n  return op\nend;","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Let's combine our mesh with our physics to instantiate our simulation:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"fₘ = sim(sd, generate);","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We can now supply initial conditions:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"ice_thickness = map(sd[:point]) do (_,_,z)\n  z < 0.8*rₑ ? 0 : 1\nend\n\nflow = dec_dual_derivative(0,sd) *\n  map(sd[sd[:tri_center], :dual_point]) do (_,_,z)\n    (rₑ-abs(z))/rₑ\n  end\n\n# There is no water \"under\" the ice:\nflow = dec_wedge_product_pd(Tuple{0,1},sd)(1 .- sigmoid(ice_thickness), flow)\n\nu₀ = ComponentArray(\n  ice_thickness = ice_thickness,\n  flow = flow,\n  water_dynamics_P = zeros(ntriangles(sd)))\n\nconstants_and_parameters = (\n  glacier_dynamics_n = 3,\n  glacier_dynamics_stress_A = 1e-16,\n  glacier_dynamics_stress_ρ = 910,\n  glacier_dynamics_stress_g = 9.8101,\n  water_dynamics_μ = 0.01);","category":"page"},{"location":"halmo/halmo/#Execute-the-Simulation","page":"Halfar-NS","title":"Execute the Simulation","text":"","category":"section"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"We specified our physics, our mesh, and our initial conditions. We have everything we need to execute the simulation.","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"tₑ = 100\n\n# Julia will pre-compile the generated simulation the first time it is run.\n@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-4), constants_and_parameters)\nsoln = solve(prob, Vern7())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Vern7())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"halmo/halmo/#Results","page":"Halfar-NS","title":"Results","text":"","category":"section"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"Let's look at the dynamics of the ice:","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"begin\n  frames = 200\n  fig = Figure()\n  ax = LScene(fig[1,1], scenekw=(lights=[],))\n  msh = CairoMakie.mesh!(ax, s, color=soln(0).ice_thickness, colormap=:jet, colorrange=extrema(soln(0).ice_thickness))\n\n  Colorbar(fig[1,2], msh)\n  record(fig, \"halmo_ice.gif\", range(0.0, tₑ; length=frames); framerate = 20) do t\n    msh.color = soln(t).ice_thickness\n  end\nend","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"(Image: HalfarMohamedIce)","category":"page"},{"location":"halmo/halmo/","page":"Halfar-NS","title":"Halfar-NS","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"overview/overview/#Introduction-to-Decapodes","page":"Overview","title":"Introduction to Decapodes","text":"","category":"section"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"include(joinpath(Base.@__DIR__, \"..\", \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (Decapodes) is a diagrammatic language used to express systems of ordinary and partial differential equations. Decapodes provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how Decapodes can be generated and interpreted.","category":"page"},{"location":"overview/overview/#Your-First-Decapode","page":"Overview","title":"Your First Decapode","text":"","category":"section"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"In the Decapodes graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since Decapodes applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0 will be the 0-dimensional data points defined the vertices of a mesh. Similarly, Form1 will be values stored on edges of the mesh and Form2 will be values stored on the surfaces of the mesh.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Below, we provide a Decapode with just a single variable C and display it.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using Decapodes\nusing DiagrammaticEquations\nusing Catlab\n\nVariable = @decapode begin\n  C::Form0\nend\n\nto_graphviz(Variable)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"The resulting diagram contains a single node, showing the single variable in this system. The arrow into this node represents that C is a source term.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Note that to display these diagrams you will require Graphviz.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We can add a second variable.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"TwoVariables = @decapode begin\n  C::Form0\n  dC::Form1\nend\n\nto_graphviz(TwoVariables)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We can also add a relationship between them. In this case, we make an equation which states that dC is the derivative of C.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Equation = @decapode begin\n  C::Form0\n  dC::Form1\n\n  dC == d(C)\nend\n\nto_graphviz(Equation)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the derivative.","category":"page"},{"location":"overview/overview/#A-Little-More-Complicated","page":"Overview","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  (C, Ċ)::Form0\n  ϕ::Form1\n  k::Constant\n\n  # Fick's first law\n  ϕ ==  k*(d₀(C))\n\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\n\nend\n\nto_graphviz(Diffusion)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"The resulting Decapode shows the relationships between the three variables with the triangle diagram.","category":"page"},{"location":"overview/overview/#Bring-in-the-Dynamics","page":"Overview","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using OrdinaryDiffEq.jl to handle time-stepping and instability detection).","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"To start with, we solve our PDE on a flat triangulated_grid as provided by CombinatorialSpaces.jl.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using CairoMakie\nusing CombinatorialSpaces\nusing GeometryBasics: Point3\n\nmesh = triangulated_grid(30,10,1,1,Point3{Float64})\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nwireframe!(ax, mesh)\nfig","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We first create a mesh that is \"dual\" to the original mesh by creating an EmbeddedDeltaDualComplex2D and calling subdivide_duals!. This is done to allow important DEC operators to be created and used in the simulation.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We then compile the simulation by using gensim and create functional simulation by calling the evaluated sim  with the mesh. Decapodes supports providing custom functions to the simulator, but for the time being we will keep things simple by passing in nothing to this value.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"dualmesh = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(mesh)\nsubdivide_duals!(dualmesh, Circumcenter())\nsim = eval(gensim(Diffusion))\nfₘ = sim(dualmesh, nothing, DiagonalHodge())","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We go ahead and set up our initial conditions for this problem. In this case we generate a Gaussian over our mesh.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in mesh[:point]]\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\nmesh!(ax, mesh; color=c)\nfig","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Finally, we solve this PDE problem using the Tsit5() solver provided by OrdinaryDiffEq. We will need to make two ComponentArrays to store the state variable data and constants, respectively.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing ComponentArrays\nusing OrdinaryDiffEq\n\nu₀ = ComponentArray(C=c)\nconstants = ComponentArray(k=0.05)\n\ntₑ = 100\nprob = ODEProblem(fₘ, u₀, (0.0, tₑ), constants)\nsoln = solve(prob, Tsit5())\nsoln.retcode","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Now that the simulation has succeeded we can plot out our results with CairoMakie.jl.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"fig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, mesh; color=c, colorrange = extrema(c))\nColorbar(fig[1,2], pmsh)\n\n\ntimes = range(0.0, tₑ, length=150)\nrecord(fig, \"diffusion.gif\", times; framerate = 30) do t\n  pmsh.color = soln(t).C\nend\nnothing # hide","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"(Image: Your first Decapode!)","category":"page"},{"location":"overview/overview/#Merging-Multiple-Physics","page":"Overview","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n  k::Constant\n\n  # Fick's first law\n  ϕ == k*(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Form1\n\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, Ċ)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\nend\nnothing # hide","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"The diffusion Decapode.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"to_graphviz(Diffusion) ","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"The advection Decapode.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"to_graphviz(Advection) ","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"And the superposition Decapode.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"to_graphviz(Superposition) ","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"For this example, we will invoke Catlab's exported @relation to specify a composition pattern. We are essentially saying here that the C in each Decapode should be fused into the same variable. Likewise for ϕ₁ between diffusion and superposition as well as ϕ₂ between advection and superposition.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using Catlab\ncompose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\ndraw_composition(compose_diff_adv)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"After this, the physics can be composed as follows. Here we specify, for example, that the ϕ₁ that we wish to have in our final Decapode (as declared above) is called ϕ in diffusion and ϕ₁ in superposition. Notice the fused result in DiffusionAdvection.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Similar to before, this physics can be compiled, executed, and plotted.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"Note that for our purposes we require a velocity vector field for the advection (remember we called this term V in our Decapode). We define the velocity field so as to move our fluid to the right (the negative is to account for the orientation of the edges of the mesh) and call eval_constant_primal_form to convert this field into a Form1 usable by the Decapode.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"We then run the simulation and create video out of the solution.","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing MLStyle\nusing StaticArrays\nimport CombinatorialSpaces.DiscreteExteriorCalculus: eval_constant_primal_form\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(dualmesh, nothing, DiagonalHodge())\n\nv = eval_constant_primal_form(dualmesh, SVector{3}(-0.25, 0.0, 0.0))\n\nu₀ = ComponentArray(C=c,V=v)\nconstants = ComponentArray(diffusion_k=0.05)\n\ntₑ = 50\nprob = ODEProblem(fₘ, u₀, (0.0, tₑ), constants)\nsol = solve(prob, Tsit5())\n\nfig = Figure()\nax = CairoMakie.Axis(fig[1,1], aspect = AxisAspect(3.0))\npmsh = mesh!(ax, mesh; color=c, colorrange = extrema(c))\nColorbar(fig[1,2], pmsh)\n\ntimes = range(0.0, tₑ, length=150)\nrecord(fig, \"diff_adv.gif\", times; framerate = 30) do t\n  pmsh.color = soln(t).C\nend\nnothing # hide","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"(Image: Your first composed Decapode!)","category":"page"},{"location":"overview/overview/","page":"Overview","title":"Overview","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"ascii/#ASCII-and-Vector-Calculus-Operators","page":"ASCII Operators","title":"ASCII and Vector Calculus Operators","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"include(joinpath(Base.@__DIR__, \"..\", \"docinfo.jl\"))\ninfo = DocInfo.Info()","category":"page"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Some users may have trouble entering unicode characters like ⋆ or ∂ in their development environment. So, we offer the following ASCII equivalents. Further, some users may like to use vector calculus symbols instead of exterior calculus symbols where possible. We offer support for such symbols as well.","category":"page"},{"location":"ascii/#ASCII-Equivalents","page":"ASCII Operators","title":"ASCII Equivalents","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Unicode ASCII Meaning\n∂ₜ dt derivative w.r.t. time\n⋆ star Hodge star, generalizing transpose\nΔ lapl laplacian\n∧ wedge wedge product, generalizing the cross product\n⋆⁻¹ star_inv Hodge star, generalizing transpose\n∘(⋆,d,⋆) div divergence, a.k.a. ∇⋅\navg₀₁ avg_01 average values stored on endpoints of edges","category":"page"},{"location":"ascii/#Vector-Calculus-Equivalents","page":"ASCII Operators","title":"Vector Calculus Equivalents","text":"","category":"section"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"Vec DEC How to enter\ngrad d grad\ndiv ∘(⋆,d,⋆) div\ncurl ∘(d,⋆) curl\n∇ d \\nabla\n∇ᵈ ∘(⋆,d,⋆) \\nabla \\<tab\\> \\^d \\<tab\\>\n∇x ∘(d,⋆) \\nabla \\<tab\\> x\nadv(X,Y) ∘(⋆,d,⋆)(X∧Y) adv","category":"page"},{"location":"ascii/","page":"ASCII Operators","title":"ASCII Operators","text":"DocInfo.get_report(info) # hide","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes.jl is a framework for developing, composing, and simulating physical systems.","category":"page"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes.jl is the synthesis of Applied Category Theory (ACT) techniques for formalizing and composing physics equations, and Discrete Exterior Calculus (DEC) techniques for formalizing differential operators. CombinatorialSpaces.jl hosts tools for discretizing space and defining DEC operators on simplicial complexes, and DiagrammaticEquations.jl hosts tooling for representing the equations as formal ACT diagrams. This repository combines these two packages, compiling diagrams down to runnable simulation code.","category":"page"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"By combining the power of ACT and the DEC, we seek to improve the scientific computing workflow. Decapodes simulations are hierarchically composable, generalize over any type of manifold, and are performant and accurate with a declarative domain specific language (DSL) that is human-readable.","category":"page"},{"location":"#Getting-started","page":"Decapodes.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Walkthroughs creating, composing, and solving Decapodes are available in the side-bar of this documentation page. Further example scripts are available in the examples folder of the Decapodes.jl GitHub repo, and will be added to this documentation site soon.","category":"page"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"note: Under Active Development\nThis library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"}]
}
