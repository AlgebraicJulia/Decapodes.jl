var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Diagrams","page":"Library Reference","title":"Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Diagrams ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Diagrams","page":"Library Reference","title":"Decapodes.Diagrams","text":"Provides the tooling for defining Decapodes conveniently with symbolic expressions\n\n\n\n\n\n","category":"module"},{"location":"api/#Decapodes.Diagrams.Decapodes2D","page":"Library Reference","title":"Decapodes.Diagrams.Decapodes2D","text":"Decapodes2D A schema which includes any homomorphisms that may be added by the @decapode macro.\n\nTODO: This should be chipped away at as more of this tooling takes advantage of the Catlab GAT system\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.Diagrams.@decapode-Tuple{Any, Any}","page":"Library Reference","title":"Decapodes.Diagrams.@decapode","text":"decapode(cat, body)\n\nThis macro is called as:\n\n@decapode presentation begin\n  expressions\nend\n\nwhere presentation is a Presentation containing the syntax for the Decapode (operators and form types), and expressions is symbolic expressions of the relations within the Decapode.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Open-Diagrams","page":"Library Reference","title":"Open Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.OpenDiagrams ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.OpenDiagrams.OpenDiagram","page":"Library Reference","title":"Decapodes.OpenDiagrams.OpenDiagram","text":"Open diagram as a structured multicospan in R-form.\n\nAn open diagram is a diagram, represented as a FinDomFunctor, together with a cospan of finite sets whose apex is the object set of the diagram's indexing category.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation","page":"Library Reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Simulations ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Simulations.ArbitraryFunc","page":"Library Reference","title":"Decapodes.Simulations.ArbitraryFunc","text":"ArbitraryFunc\n\nOut of place function which applies to any number of arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.ConstantFunc","page":"Library Reference","title":"Decapodes.Simulations.ConstantFunc","text":"ConstantFunc\n\nFunction which always returns the same value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.ElementwiseFunc","page":"Library Reference","title":"Decapodes.Simulations.ElementwiseFunc","text":"ElementwiseFunc\n\nFunction applied to each element of one or more vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.InPlaceFunc","page":"Library Reference","title":"Decapodes.Simulations.InPlaceFunc","text":"InPlaceFunc\n\nFunction which operates on arguments in-place, not returning a value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.MatrixFunc","page":"Library Reference","title":"Decapodes.Simulations.MatrixFunc","text":"MatrixFunc\n\nLinear operator applied through matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.TDInPlaceFunc","page":"Library Reference","title":"Decapodes.Simulations.TDInPlaceFunc","text":"TDInPlaceFunc\n\nFunction which accepts the current time as the last argument. Used to set up time-dependent physics or boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.gen_sim-Tuple{WiringDiagram, Any, Any}","page":"Library Reference","title":"Decapodes.Simulations.gen_sim","text":"gen_sim(dwd::WiringDiagram, name2func::Dict,             s::EmbeddedDeltaDualComplex2D;             form2dim=form2dim, params=[], autodiff=false)\n\nThis function generates a function which evaluates the acylcic directed wiring diagram dwd, using the functions in name2func for operators to execute corresonding to each box and information from the mesh s to pre-allocate necessary memory. This operator can generate a function which is compatible with the autodifferentiation solvers in DifferentialEquations.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#Schedules","page":"Library Reference","title":"Schedules","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Schedules ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Schedules","page":"Library Reference","title":"Decapodes.Schedules","text":"Schedules\n\nThis module contains the tooling which converts diagrams to DWDs.\n\nTODO This module will also include optimization tooling relating to DWD schedules (compressing matrix operations, pre-computing constant values, etc).\n\n\n\n\n\n","category":"module"},{"location":"api/#Decapodes.Schedules.diag2dwd-Tuple{Any}","page":"Library Reference","title":"Decapodes.Schedules.diag2dwd","text":"diag2dwd(diagram; clean = false, calcstates = [], outvars=[], in_vars=[])\n\nGenerates a directed wiring diagram (DWD) from a Decapode diagram. This method generates a DWD which represents a single explicit time step of the system, computed by the dependency graph of each time derivative within the system. This does not necessarily work for all Decapodes, and only generates an explicit time-step solution.\n\nTODO: Functions like this can be created to generate other solution styles, like implicit solutions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples","page":"Library Reference","title":"Examples","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Examples ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Examples.dual-Union{Tuple{CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D{O, P}}, Tuple{P}, Tuple{O}} where {O, P}","page":"Library Reference","title":"Decapodes.Examples.dual","text":"dual(s::EmbeddedDeltaSet2D{O, P})\n\nGenerates a dual mesh for the provided delta set s.\n\nTODO: This tooling should be upstreamed to CombinatorialSpaces\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.Examples.expand_dwd-Tuple{Any, Any}","page":"Library Reference","title":"Decapodes.Examples.expand_dwd","text":"expanddwd(dwdorig::WiringDiagram, patterns::Dict{Symbol, WiringDiagram})\n\nReplaces any boxes in dwd_orig which map to a key in patterns with their corresponding diagram in patterns. This allows for replacement of complex operations with their definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#PetriNets","page":"Library Reference","title":"PetriNets","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.PetriNets]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.PetriNets.expand_pres!-Tuple{Any, LabelledReactionNet}","page":"Library Reference","title":"Decapodes.PetriNets.expand_pres!","text":"expand_pres!(pres::Presentation, pn::LabelledReactionNet)\n\nExpands the syntax of the presentation pres to include the necessary operators for expressing mass action on the Petri net pn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.PetriNets.gen_functions-Tuple{LabelledReactionNet, Any}","page":"Library Reference","title":"Decapodes.PetriNets.gen_functions","text":"gen_functions(pn::LabelledReactionNet, s::EmbeddedDeltaDualComplex2D)\n\nGenerates the functions necessary for executing the Petri net after it has been converted to a Decapode.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.PetriNets.pn2dec-Tuple{Any, LabelledReactionNet}","page":"Library Reference","title":"Decapodes.PetriNets.pn2dec","text":"pn2dec(prs::Presentation, pn::LabelledReactionNet)\n\nGenerates a Decapode diagram which represents the law of mass action applied to the petri net pn with the syntax from the presentation prs.\n\n\n\n\n\n","category":"method"},{"location":"bc_debug/#Simulation-Setup","page":"Misc Features","title":"Simulation Setup","text":"","category":"section"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"This tutorial showcases some of the other features included in the Decapodes.jl package. Currently, these features are the treatment of boundary conditions and the simulation debugger interface. To begin, we set up the same advection-diffusion problem presented in the Overview section. As before, we define the Diffusion, Advection, and Superposition components, and now include a BC (Bounday Condition) component. Decapodes.jl interprets any Hom which begins with a ∂ as a boundary condition. These boundary conditions recieve special treatment at the scheduling step. Below we show the graphical rendering of this boundary condition diagram, which we will use to impose a Dirichlet condition on the time derivative of concentration at the mesh boundary.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Decapodes, Decapodes.Diagrams, Decapodes.OpenDiagrams\nusing Catlab.Present, Catlab.Graphics, Catlab.Programs\n\n@present DiffusionQuantities <: Decapodes2D begin\n  k::Hom(Form1(X), Form1(X))    # diffusivity (usually scalar multiplication)\n  ∂C::Hom(Form0(X), Form0(X))   # concentration boundary condition\nend;\n\nDiffusion = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\nend\n\nAdvection = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  (V, ϕ)::Form1{X}\n  ϕ == ∧₀₁{X}(C,V)\nend\n\nSuperposition = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  (ϕ, ϕ₁, ϕ₂)::Form1{X}\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend\n\nBoundaryConditions = @decapode DiffusionQuantities begin\n  (Ċ, Ċ_bound)::Form0{X}\n  ∂C(Ċ) == Ċ_bound\nend\n\ndraw_diagram(BoundaryConditions)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"As before, we compose these physics components over our wiring diagram.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  bc(Ċ)\n  superposition(ϕ₁, ϕ₂, ϕ, Ċ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable,\n            graph_attrs=Dict(:start => \"2\"))","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"DiffusionAdvection = oapply(compose_diff_adv,\n                  [OpenDiagram(Diffusion, [:C, :ϕ]),\n                   OpenDiagram(Advection, [:C, :ϕ, :V]),\n                   OpenDiagram(BoundaryConditions, [:Ċ]),\n                   OpenDiagram(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :Ċ, :C])])\n\ndraw_diagram(DiffusionAdvection.functor)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"When this is scheduled, Decapodes will apply any boundary conditions immediately after the impacted value is computed. This implementation choice ensures that this boundary condition holds true for any variables dependent on this variable, though also means that the boundary conditions on a variable have no immediate impact on the variables this variable is dependent on.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Below, we see the generated schedule, which shows that the final operation executed on the data is the boundary condition we are enforcing on the change in concentration.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Decapodes.Schedules\n\nexplicit_ts = diag2dwd(DiffusionAdvection.functor)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Next we import the mesh we will use. In this case, we are wanting to impose boundary conditions and so we will use the plot_mesh from the previous example instead of the mesh with periodic boundary conditions. Because the mesh is only a primal mesh, we also generate and subdivide the dual mesh.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\nusing JSON\nusing HTTP: get\n\nplot_mesh = parse_json_acset(EmbeddedDeltaSet2D{Bool, Point3{Float64}},\n                                 String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/plot_mesh.json\").body))\n\n# Generate the dual mesh\nplot_mesh_dual = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(plot_mesh)\n# Calculate distances and subdivisions for the dual mesh\nsubdivide_duals!(plot_mesh_dual, Circumcenter())\n\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Finally, we define our operators, generate the simulation function, and compute the simulation. Note that when we define the boudary condition operator, we hardcode the boundary indices and values into the operator itself. We also move the initial concentration to the left, so that we are able to see a constant concentration on the left boundary which will act as a source in the flow. The modified initial condition is shown below:","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using LinearAlgebra\nusing Decapodes.Examples, Decapodes.Simulations\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\n\nfuncs = sym2func(plot_mesh_dual)\n\nfuncs[:k] = Dict(:operator => 0.05 * I(ne(plot_mesh_dual)), :type => MatrixFunc())\nfuncs[:⋆₁] = Dict(:operator => ⋆(Val{1}, plot_mesh_dual, hodge=DiagonalHodge()),\n                  :type => MatrixFunc());\nfuncs[:∧₀₁] = Dict(:operator => (r, c,v)->r .= ∧(Tuple{0,1}, plot_mesh_dual, c, v), :type => InPlaceFunc())\n\nboundary = Examples.boundary_inds(Val{0}, plot_mesh)\nfuncs[:∂C] = Dict(:operator => (∂ċ, ċ)->(∂ċ .= ċ; ∂ċ[boundary] .= 0), :type => InPlaceFunc())\n\n\nusing Distributions\nc_dist = MvNormal([1, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in plot_mesh_dual[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[1:nv(plot_mesh)])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"And the simulation result is then computed and visualized below.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using OrdinaryDiffEq\nfunc, code = gen_sim(explicit_ts, funcs, plot_mesh_dual; autodiff=false, params = [:V]);\n\nvelocity(p) = [-0.5, 0.0, 0.0]\nv = ♭(plot_mesh_dual, DualVectorField(velocity.(plot_mesh_dual[triangle_center(plot_mesh_dual),:dual_point]))).data\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5(), p=v);\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[1:nv(plot_mesh)] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv_right.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[1:nv(plot_mesh)]\nend","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"(Image: )","category":"page"},{"location":"bc_debug/#Debug-the-Simulation","page":"Misc Features","title":"Debug the Simulation","text":"","category":"section"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"The benefit of having the computation graph which we generated above means that we have the opportunity to inspect the simulation at different stages of computation. Since each wire in the computation diagram has the data of a particular form on the mesh, this data can be visualized. The first step of getting at this data, though, is understanding the index associated with each wire. This key between indices and wires can be generated with the sim_key function.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Decapodes.Debug\n\nsim_key(explicit_ts)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Another key piece of data is what the initial state is at the time-step you are debugging. We choose the time step t = 10 for this example, shown below.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"t = 10.0\nfig, ax, ob = mesh(plot_mesh; color=sol(t)[1:nv(plot_mesh_dual)])\nxlims!(ax, (0,10.0))\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Now we can see what the value is of the result of the product between velocity and the concentration.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 2;p = v, xlim=(0, 10.0), ylim=(0.0,10.0))\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Now, this information doesn't seem all that useful at first glance. The result is basically a heatmap of the magnitude of the vector field across each edge of the mesh. Here, we see that this product has a greater magnitude on edges that are both aligned with the flow and have a high concentraiton at that point.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Something which is a little more useful is to includ arrows! By using the use_arrows keyword argument, we are able to get arrows, directed along the mesh edge elements, which show the direction of the vectorfield at that point. The color of these arrows shows the magnitude of the vectorfield in that direction. Note that this method of plotting arrows with CairoMakie is fairly computationally expensive, so as the n_arrows argument increases, so will the time it takes to render.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 2;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Note that all of the arrows from the result of the product are pointing in the direction of flow. This intuitively makes sense for how the concentration flow vectorfield should look.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Below, we show the concentration flow resulting just from the gradient.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 7;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Here, we see that the arrows are pointing away from areas of high concentration to areas of low concentration, and that the magnitude of the arrows grows greater as the slope of concentration is greater.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Next, we can show what happens after the effects of diffusion and advection are added together.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 4;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Finally, in order to compute the change of concentration, we visualize what the resulting change in concentration is.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"\nfig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 3;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Here, we can see the positive change which is weighted heavily to the right of the existing distribution, and the slight negative change which follows from where the distribution is flowing.","category":"page"},{"location":"overview/#Introduction-to-DECAPODEs","page":"Overview","title":"Introduction to DECAPODEs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (DECAPODE) is a diagrammatic language used to express systems of ordinary and partial differential equations. The DECAPODE provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how DECAPODEs can be generated and interpreted.","category":"page"},{"location":"overview/#Your-First-DECAPODE","page":"Overview","title":"Your First DECAPODE","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin with the most basic DECAPODE, one which only includes a single variable. In the DECAPODE graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since the DECAPODE applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0{X} will be the 0-dimensional data points on the space X, or in a discrete context, the values defined on points of a mesh X. Similarly, Form1{X} will be values stored on edges of the mesh, and Form2{X} will be values stored on the surfaces of the mesh. Below, we provide a very simple DECAPODE with just a single variable C. In this example, we also provide the necessary imports, and define a convenience function for visualization in later examples.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes, Decapodes.Diagrams\nusing Catlab.Present, Catlab.Graphics\n\nVariable = @decapode Decapodes2D begin\n  C::Form0{X}\nend;\n\ndraw_equation(decapode) = to_graphviz(decapode, node_labels=true, prog=\"neato\",\n  node_attrs=Dict(:shape=>\"oval\"),\n  graph_attrs=Dict(:nodesep=>\"4.0\"))\n\ndraw_equation(Variable)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting diagram contains a single node, showing the single variable in this system. We can then add a second variable:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"TwoVariables = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\nend;\n\ndraw_equation(TwoVariables)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"And then can add some relationship between them. In this case, we make an equation which states that dC is the discrete derivative of C:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Equation = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\n\n  dC == d₀{X}(C)\nend;\n\ndraw_equation(Equation)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the discrete derivative.","category":"page"},{"location":"overview/#A-Little-More-Complicated","page":"Overview","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration. One issue that we run into here, though, is that there isn't a \"proportionality\" operator in the default DECAPODEs syntax Decapodes2D. Thus, in this next example, we will first extend the Decapodes2D syntax and then define the DECAPODE for diffusion.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@present DiffusionQuantities <: Decapodes2D begin\n  k::Hom(Form1(X), Form1(X))    # diffusivity (usually scalar multiplication)\nend;\n\nDiffusion = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend;\n\ndraw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting DECAPODE shows the relationships between the three variables with the triangle diagram. Note that automatic layout of these labels can result in confusion as to which edge each label corresponds, but any confusion can be resolved by referring back to the original @decapode definition.","category":"page"},{"location":"overview/#Bring-in-the-Dynamics","page":"Overview","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using DifferentialEquatons.jl for the actual computation).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin this process by importing a mesh. The mesh has been pre-generated within CombinatorialSpaces, and is generated such that it has periodic boundary conditions. We will also upload a non-periodic mesh for the sake of visualization, as well as a mapping between the points on the periodic and non-periodic meshes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\nusing JSON\nusing HTTP: get\n\nperiodic_mesh = parse_json_acset(EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}},\n                                 String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/periodic_mesh.json\").body))\nplot_mesh = parse_json_acset(EmbeddedDeltaSet2D{Bool, Point3{Float64}},\n                                 String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/plot_mesh.json\").body))\npoint_map = JSON.parse(String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/point_map.json\").body))\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With the mesh uploaded, we also need to convert the DECAPODE into something which can be scheduled as an explicit time step. In order to do this, we take every variable which is the time derivative of another variable and trace back the operations needed to compute this. This process generates a computation graph in the form of a directed wiring diagram, as shown below.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes.Schedules\n\nexplicit_ts = diag2dwd(Diffusion)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As can be seen, diffusion has a very simple explicit time step. With this diagram defined, we just need to define a function which implements each of these symbolic operators and pass them to a scheduler for generating the function. The basic DEC operators can be computed with the sym2func operator, and more complex or custom functions (like the proportionality constant k) can be defined manually. We choose to also define the hodge star (⋆₁) on primal 1-forms manually, as this mesh allows for a diagonal hodge star which is significantly more efficient for computation.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing Decapodes.Examples, Decapodes.Simulations\n\nfuncs = sym2func(periodic_mesh)\n\nfuncs[:k] = Dict(:operator => 0.05 * I(ne(periodic_mesh)), :type => MatrixFunc())\nfuncs[:⋆₁] = Dict(:operator => ⋆(Val{1}, periodic_mesh, hodge=DiagonalHodge()),\n                  :type => MatrixFunc());","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we generate the simulation function using gen_sim and set up our initial conditions for this problem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"func, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false);\n\nusing Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in periodic_mesh[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[point_map])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we solve this PDE problem using the Tsit5() solver and generate an animation of the result!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using OrdinaryDiffEq\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diffusion.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"overview/#Merging-Multiple-Physics","page":"Overview","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\nend\n\nAdvection = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  (V, ϕ)::Form1{X}\n  ϕ == ∧₀₁{X}(C,V)\nend\n\nSuperposition = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  (ϕ, ϕ₁, ϕ₂)::Form1{X}\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Advection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Superposition)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.Programs\n\ncompose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable,\n            graph_attrs=Dict(:start => \"2\"))\n","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After this, the physics can be composed as follows:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes.OpenDiagrams\nDiffusionAdvection = oapply(compose_diff_adv,\n                  [OpenDiagram(Diffusion, [:C, :ϕ]),\n                   OpenDiagram(Advection, [:C, :ϕ, :V]),\n                   OpenDiagram(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\n\ndraw_equation(DiffusionAdvection.functor)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Similar to before, this physics can be converted to a directed wiring diagram, compiled, and executed. Note that this process now requires another value to be defined, namely the velocity vector field. We do this using a custom operator called flat_op. This operator is basically the flat operator from CombinatorialSpaces.jl, but specialized to account for the periodic mesh.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"function closest_point(p1, p2, dims)\n    p_res = collect(p2)\n    for i in 1:length(dims)\n        if dims[i] != Inf\n            p = p1[i] - p2[i]\n            f, n = modf(p / dims[i])\n            p_res[i] += dims[i] * n\n            if abs(f) > 0.5\n                p_res[i] += sign(f) * dims[i]\n            end\n        end\n    end\n    Point3{Float64}(p_res...)\nend\n\nfunction flat_op(s::AbstractDeltaDualComplex2D, X::AbstractVector; dims=[Inf, Inf, Inf])\n  # XXX: Creating this lookup table shouldn't be necessary. Of course, we could\n  # index `tri_center` but that shouldn't be necessary either. Rather, we should\n  # loop over incident triangles instead of the elementary duals, which just\n  # happens to be inconvenient.\n  tri_map = Dict{Int,Int}(triangle_center(s,t) => t for t in triangles(s))\n\n  map(edges(s)) do e\n    p = closest_point(point(s, tgt(s,e)), point(s, src(s,e)), dims)\n    e_vec = (point(s, tgt(s,e)) - p) * sign(1,s,e)\n    dual_edges = elementary_duals(1,s,e)\n    dual_lengths = dual_volume(1, s, dual_edges)\n    mapreduce(+, dual_edges, dual_lengths) do dual_e, dual_length\n      X_vec = X[tri_map[s[dual_e, :D_∂v0]]]\n      dual_length * dot(X_vec, e_vec)\n    end / sum(dual_lengths)\n  end\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"explicit_ts = diag2dwd(DiffusionAdvection.functor)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nfuncs[:∧₀₁] = Dict(:operator => (r, c,v)->r .= ∧(Tuple{0,1}, periodic_mesh, c, v), :type => InPlaceFunc())\n\nfunc, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false, params = [:V]);\n\nvelocity(p) = [-0.5, -0.5, 0.0]\nv = flat_op(periodic_mesh, DualVectorField(velocity.(periodic_mesh[triangle_center(periodic_mesh),:dual_point])); dims=[30, 10, Inf])\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5(), p=v);\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: ) ```","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes are a graphical tool for the composition of physical systems. Ultimately, this library will include tooling which takes advantage of the formalization of physical theories described by DEC provided by CombinatorialSpaces.jl.","category":"page"},{"location":"#NOTE","page":"Decapodes.jl","title":"NOTE","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"This library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"},{"location":"poiseuille/#Poissuille-Flow-for-Fluid-Mechanics","page":"Pipe Flow","title":"Poissuille Flow for Fluid Mechanics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"When modeling a fluid flowing in pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The noslip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nimport Catlab.Theories: otimes, oplus, compose, ⊗, ⊕, ⋅, associate, associate_unit, Ob, Hom, dom, codom\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nusing Catlab.Theories\nusing Catlab.Present\nusing Catlab.Graphics\nusing Catlab.Syntax\nusing Catlab.CategoricalAlgebra\nusing LinearAlgebra\n\nusing Decapodes.Simulations\nusing Decapodes.Examples\nusing Decapodes.Diagrams\nusing Decapodes.Schedules\n\n# Julia community libraries\n\nusing CairoMakie\nusing Decapodes.Debug\nusing OrdinaryDiffEq\n\n\n\"\"\" Decapodes1D\nA schema which includes any homomorphisms that may be added by the @decapode\nmacro.\n\nTODO: This should be chipped away at as more of this tooling takes advantage\nof the Catlab GAT system\n\"\"\"\n\n@present Decapodes1D(FreeExtCalc1D) begin\n  X::Space\n  proj₁_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  proj₂_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  proj₁_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))\n  proj₂_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))\n  proj₁_⁰¹₀::Hom(Form0(X)⊗Form1(X),Form0(X))\n  proj₂_⁰¹₁::Hom(Form0(X)⊗Form1(X),Form1(X))\n  proj₁_⁰¹₀⁺::Hom(Form0(X)⊕Form1(X),Form0(X))\n  proj₂_⁰¹₁⁺::Hom(Form0(X)⊕Form1(X),Form1(X))\n  proj₁_⁰⁰̃₀::Hom(Form0(X)⊗DualForm0(X),Form0(X))\n  proj₂_⁰⁰̃₀̃::Hom(Form0(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_⁰⁰̃₀⁺::Hom(Form0(X)⊕DualForm0(X),Form0(X))\n  proj₂_⁰⁰̃₀̃⁺::Hom(Form0(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_⁰¹̃₀::Hom(Form0(X)⊗DualForm1(X),Form0(X))\n  proj₂_⁰¹̃₁̃::Hom(Form0(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_⁰¹̃₀⁺::Hom(Form0(X)⊕DualForm1(X),Form0(X))\n  proj₂_⁰¹̃₁̃⁺::Hom(Form0(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_¹⁰₁::Hom(Form1(X)⊗Form0(X),Form1(X))\n  proj₂_¹⁰₀::Hom(Form1(X)⊗Form0(X),Form0(X))\n  proj₁_¹⁰₁⁺::Hom(Form1(X)⊕Form0(X),Form1(X))\n  proj₂_¹⁰₀⁺::Hom(Form1(X)⊕Form0(X),Form0(X))\n  proj₁_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  proj₂_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  proj₁_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))\n  proj₂_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))\n  proj₁_¹⁰̃₁::Hom(Form1(X)⊗DualForm0(X),Form1(X))\n  proj₂_¹⁰̃₀̃::Hom(Form1(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_¹⁰̃₁⁺::Hom(Form1(X)⊕DualForm0(X),Form1(X))\n  proj₂_¹⁰̃₀̃⁺::Hom(Form1(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_¹¹̃₁::Hom(Form1(X)⊗DualForm1(X),Form1(X))\n  proj₂_¹¹̃₁̃::Hom(Form1(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_¹¹̃₁⁺::Hom(Form1(X)⊕DualForm1(X),Form1(X))\n  proj₂_¹¹̃₁̃⁺::Hom(Form1(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_⁰̃⁰₀̃::Hom(DualForm0(X)⊗Form0(X),DualForm0(X))\n  proj₂_⁰̃⁰₀::Hom(DualForm0(X)⊗Form0(X),Form0(X))\n  proj₁_⁰̃⁰₀̃⁺::Hom(DualForm0(X)⊕Form0(X),DualForm0(X))\n  proj₂_⁰̃⁰₀⁺::Hom(DualForm0(X)⊕Form0(X),Form0(X))\n  proj₁_⁰̃¹₀̃::Hom(DualForm0(X)⊗Form1(X),DualForm0(X))\n  proj₂_⁰̃¹₁::Hom(DualForm0(X)⊗Form1(X),Form1(X))\n  proj₁_⁰̃¹₀̃⁺::Hom(DualForm0(X)⊕Form1(X),DualForm0(X))\n  proj₂_⁰̃¹₁⁺::Hom(DualForm0(X)⊕Form1(X),Form1(X))\n  proj₁_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  proj₂_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))\n  proj₂_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_⁰̃¹̃₀̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm0(X))\n  proj₂_⁰̃¹̃₁̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_⁰̃¹̃₀̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm0(X))\n  proj₂_⁰̃¹̃₁̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_¹̃⁰₁̃::Hom(DualForm1(X)⊗Form0(X),DualForm1(X))\n  proj₂_¹̃⁰₀::Hom(DualForm1(X)⊗Form0(X),Form0(X))\n  proj₁_¹̃⁰₁̃⁺::Hom(DualForm1(X)⊕Form0(X),DualForm1(X))\n  proj₂_¹̃⁰₀⁺::Hom(DualForm1(X)⊕Form0(X),Form0(X))\n  proj₁_¹̃¹₁̃::Hom(DualForm1(X)⊗Form1(X),DualForm1(X))\n  proj₂_¹̃¹₁::Hom(DualForm1(X)⊗Form1(X),Form1(X))\n  proj₁_¹̃¹₁̃⁺::Hom(DualForm1(X)⊕Form1(X),DualForm1(X))\n  proj₂_¹̃¹₁⁺::Hom(DualForm1(X)⊕Form1(X),Form1(X))\n  proj₁_¹̃⁰̃₁̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm1(X))\n  proj₂_¹̃⁰̃₀̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_¹̃⁰̃₁̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm1(X))\n  proj₂_¹̃⁰̃₀̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\n  proj₂_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))\n  proj₂_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))\n  sum₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  sum₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  sum₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  sum₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\nend","category":"page"},{"location":"poiseuille/#Creating-the-Poiseuille-Equations","page":"Pipe Flow","title":"Creating the Poiseuille Equations","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The first step is to present an extension of the generic Decapodes1D presentation with specific named linear operators for the viscosity effect and the drag effect. This is purely syntactic, we will add the corresponding matrices later. ","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The @decapode macro creates the data structure representing the equations of Poiseuille flow. The first block declares variables, the second block defines intermediate terms and the last block is the core equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"@present Poiseuille <: Decapodes1D begin\n  (R, μ̃)::Hom(Form1(X), Form1(X))\n  # μ̃ = negative viscosity per unit area\n  # R = drag of pipe boundary\nend;\n\nPoise = @decapode Poiseuille begin\n  (∇P)::Form1{X}\n  (q, q̇, Δq)::Form1{X}\n  P::Form0{X}\n\n  # Laplacian of q for the viscous effect\n  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))\n  # Gradient of P for the pressure driving force\n  ∇P == d₀{X}(P)\n  # definition of time derivative of q\n  ∂ₜ{Form1{X}}(q) == q̇\n\n  # the core equation\n  q̇ == sum₁(sum₁(μ̃(Δq), ∇P),R(q))\nend;","category":"page"},{"location":"poiseuille/#Defining-the-Semantics","page":"Pipe Flow","title":"Defining the Semantics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The operator funcs code below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. ","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"\"\"\"    boundary_edges(ds)\n\nCompute the edges of a 1D simplicial set that are either incident to in-degree 1 or out-degree 1 nodes.\nFor a graph, these are boundary vertices meaning leaf nodes. For our pipeflow problems,\nthese are the edges where material can enter the pipe network.\n\"\"\"\nfunction boundary_edges(ds)\n  out_degree(x) = length(incident(ds, x, :∂v1))\n  in_degree(x) = length(incident(ds, x, :∂v0))\n  bpoints = findall(x -> out_degree(x) == 0 || in_degree(x) == 0, 1:nv(ds))\n  sedges = vcat(incident(ds,bpoints,:∂v0)...)\n  tedges = vcat(incident(ds,bpoints,:∂v1)...)\n  bedges = collect(union(sedges, tedges))\n  return bedges\nend\n\n\"\"\"    mask_boundary_edges(ds)\n\nProvides the `boundary_edges(ds)` as a vector of 0/1 entries to use as a mask.\n\"\"\"\nfunction mask_boundary_edges(ds)\n  D = ones(Int, ne(ds))\n  D[boundary_edges(ds)] .= 0\n  return D\nend\n\n\nopbind(f, T) = Dict(:operator=>f, :type=>T)\n\nfunction create_funcs(ds, hodge=DiagonalHodge())\n  funcs = Dict{Symbol, Dict}()\n  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₀] = opbind(⋆(Val{0}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₀⁻¹] = opbind(inv(⋆(Val{0}, ds, hodge=hodge)), MatrixFunc())\n  funcs[:⋆₁⁻¹] = opbind(inv(⋆(Val{1}, ds, hodge=hodge)), MatrixFunc())\n  funcs[:d₀] = opbind(d(Val{0}, ds), MatrixFunc())\n  funcs[:dual_d₀] = opbind(dual_derivative(Val{0}, ds), MatrixFunc());\n  funcs[:sum₁] = opbind((x′, x, y)->(x′ .= x .+ y), InPlaceFunc())\n  funcs[:∧₀₁] = opbind((r, c, v) -> r .= -∧(Tuple{0,1}, ds, c, v), InPlaceFunc())\n  return funcs\nend\n\n##\nfunction create_funcs(ds, operators, boundaries, hodge=DiagonalHodge())\n  funcs = create_funcs(ds, hodge)\n  merge!(funcs, operators, boundaries)\n  return funcs\nend\n\nfunction operator_funcs(ds)\n  F = Dict(\n    :μ̃ => opbind(0.5 *  Diagonal(mask_boundary_edges(ds)), MatrixFunc()),\n    :R => opbind(-0.1 * I(ne(ds)), MatrixFunc()),\n    :¬ => opbind(-I(ne(ds)), MatrixFunc()),\n    :k => opbind(1.0 * I(nv(ds)), MatrixFunc()))\n  B = Dict(\n    :∂ρ => opbind((ρᵇ, ρ) -> begin ρᵇ .= ρ; ρᵇ[1] = 0; ρᵇ[end] = 0; return ρᵇ end, InPlaceFunc())\n  )\n  create_funcs(ds, F, B)\nend\nform2dim = Dict(:Scalar => x->1,\n                :Form0 => nv,\n                :Form1 => ne,\n                :DualForm1 => nv,\n                :DualForm0 => ne)\n","category":"page"},{"location":"poiseuille/#A-Single-Pipe-Segment","page":"Pipe Flow","title":"A Single Pipe Segment","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We create a mesh with one pipe segment to see if we get the right answer. This simulation can be validated with the Poiseuille equation for a single pipe. First we create the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Point3D = Point3{Float64}\ns = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])\nadd_edge!(s, 1, 2, edge_orientation=true)\n\nds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(ds, Circumcenter())\nds","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"funcs = operator_funcs(ds)\nfunc, code = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P]);\nprob = ODEProblem(func, [2.], (0.0, 10000.0), [1.,11.])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#A-Linear-Pipe-with-Multiple-Segments","page":"Pipe Flow","title":"A Linear Pipe with Multiple Segments","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into n segments. First we define the mesh:","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\n\nds, func, funcs = linear_pipe(10)\nds","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"prob = ODEProblem(func, [5,3,4,2,5,2,8,4,3], (0.0, 10000.0), [10. *i for i in 1:10])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#A-Distribution-Network","page":"Pipe Flow","title":"A Distribution Network","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"To model a distribution network such as residential drinking water or natural gas, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function binary_pipe(depth::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertex!(s, point=Point3D(0, 0, 0))\n  for n in 1:depth\n    for prev_v in vertices(s)[end-2^(n-1)+1:end]\n      x, y, _ = s[:point][prev_v]\n      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)\n                                 for sgn in [1,-1]])\n      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)\n    end\n  end\n  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))\n  add_edge!(s, 1, v, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\nds, func, funcs = binary_pipe(2);\nds","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"prob = ODEProblem(func,\n                 [5. for _ in 1:ne(ds)],\n                 (0.0, 10000.0),\n                 Float64[2^(7-p[2]) for p in ds[:point]])\n\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#Multiphysics","page":"Pipe Flow","title":"Multiphysics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow (q) and the pressure (P) to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The Decapode can be visualized with graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper [PBHF22]. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"@present Poiseuille <: Decapodes1D begin\n  (R, μ̃, ¬)::Hom(Form1(X), Form1(X))\n  k::Hom(Form0(X), Form0(X))\n  # μ̃ = negative viscosity per unit area\n  # R = drag of pipe boundary\n  # k = pressure as a function of density\n  # boundary conditions\n  ∂ρ::Hom(Form0(X), Form0(X))\nend;\n\nPoise = @decapode Poiseuille begin\n  (∇P)::Form1{X}\n  (q, q̇, Δq)::Form1{X}\n  (P, ρ, ρ̇)::Form0{X}\n\n  # Poiseuille Flow\n  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))\n  ∂ₜ{Form1{X}}(q) == q̇\n  ∇P == d₀{X}(P)\n  q̇ == sum₁(sum₁(μ̃(Δq), ¬(∇P)),R(q))\n  \n  # Pressure/Density Coupling\n  P == k(ρ)\n  ∂ₜ{Form0{X}}(ρ) == ρ̇\n  ρ̇ == ⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(∧₀₁{X}(ρ,q)))) # advection\n  \n  # Boundary conditions\n  ρᵇ::Form0{X}\n  ∂ρ(ρ̇) == ρᵇ\nend;\n\nto_graphviz(Poise, node_labels=true, prog=\"neato\", node_attrs=Dict(:shape=>\"oval\"))","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we can create the mesh and solve the equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise, in_vars=[:q, :ρ]), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\n\nds, func, funcs = linear_pipe(10)\n\nprob = ODEProblem(func, [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5], (0.0, 10000.0), [10. *i for i in 1:10])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Notice that the solution contains both a vector of flows and a vector of pressures.","category":"page"}]
}
