var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Decapodes","page":"Library Reference","title":"Decapodes","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.op1_inf_rules_1D","page":"Library Reference","title":"Decapodes.op1_inf_rules_1D","text":"These are the default rules used to do type inference in the 1D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.op1_inf_rules_2D","page":"Library Reference","title":"Decapodes.op1_inf_rules_2D","text":"These are the default rules used to do type inference in the 2D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.op1_res_rules_1D","page":"Library Reference","title":"Decapodes.op1_res_rules_1D","text":"These are the default rules used to do function resolution in the 1D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.op1_res_rules_2D","page":"Library Reference","title":"Decapodes.op1_res_rules_2D","text":"These are the default rules used to do function resolution in the 2D exterior calculus.\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.CartesianPoint","page":"Library Reference","title":"Decapodes.CartesianPoint","text":"CartesianPoint{T}(p)\n\na point in cartesian coordinates, intended as a wrapper around Point3 from GeometryBasics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.SpherePoint","page":"Library Reference","title":"Decapodes.SpherePoint","text":"SpherePoint{T}(p)\n\na point in spherical coordinates, intended as a wrapper around Point3 from GeometryBasics.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.TangentBasis-Tuple{Any}","page":"Library Reference","title":"Decapodes.TangentBasis","text":"tb(w)\n\nTake a linear combinations of the tangent vectors at the base point.  Use this to get a vector tangent to the sphere in the coordinate system of the base point. If the base point is in spherical coordinates, this is the identity, if the base point is in cartesian coordinates, it returns the tangent vector in cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply-Union{Tuple{D}, Tuple{RelationDiagram, Vector{D}}} where D<:(StructuredMulticospan{Catlab.CategoricalAlgebra.StructuredCospans.DiscreteACSet{AnonACSet{TypeLevelBasicSchema{Symbol, Tuple{:Var}, Tuple{}, Tuple{:Type, :Operator, :Name}, Tuple{(:type, :Var, :Type), (:name, :Var, :Name)}}, Tuple{Type, Operator, Name}, NamedTuple{(:Var, :Type, :Operator, :Name), NTuple{4, IntParts}}, NamedTuple{(:type, :name), Tuple{ACSets.ColumnImplementations.DenseColumn{Union{AttrVar, Type}, Array{Union{AttrVar, Type}, 1}}, ACSets.ColumnImplementations.DenseColumn{Union{AttrVar, Name}, Array{Union{AttrVar, Name}, 1}}}}, IntParts}, SummationDecapode{Type, Operator, Name}}} where {Type, Operator, Name})","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"function oapply(relation::RelationDiagram, podes::Vector{D}) where {D<:OpenSummationDecapode}\n\nCompose a list of decapodes as specified by the given relation diagram.\n\nThe decapodes must be given in the same order as they were specified in the relation.\n\nState variables (such as the (C,V) given in the head of the following @relation) do not affect the result of a composition.\n\nExamples\n\njulia> compose_diff_adv = @relation (C,V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend;\n\njulia> oapply(compose_diff_adv, [(Diffusion, [:C, :ϕ]),\n  (Advection, [:C, :ϕ, :V]), (Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])]);\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.Open-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{SummationDecapode{T, U, V}, AbstractVector{Symbol}}} where {T, U, V}","page":"Library Reference","title":"Decapodes.Open","text":"Open(d::SummationDecapode{T,U,V}, names::AbstractVector{Symbol}) where {T,U,V}\n\ncreates an OpenSummationDecapode based on named variables rather than variable indices.  See AlgebraicPetri.jl's Open for the analogous verion for LabelledReactionNetworks.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.average_rewrite-Tuple{SummationDecapode}","page":"Library Reference","title":"Decapodes.average_rewrite","text":"function average_rewrite(deca_source::SummationDecapode)\n\nCompute each quantitity in the given Decapode by the average of all computation paths leading to that node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.contract_operators-Tuple{SummationDecapode}","page":"Library Reference","title":"Decapodes.contract_operators","text":"function contract_operators(d::SummationDecapode)\n\nFind chains of Op1s in the given Decapode, and replace them with a single Op1 with a vector of function names. After this process, all Vars that are not a part of any computation are removed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.dot_rename!-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"Decapodes.dot_rename!","text":"dot_rename!(d::AbstractNamedDecapode)\n\nRename tangent variables by their depending variable appended with a dot. e.g. If D == ∂ₜ(C), then rename D to Ċ.\n\nIf a tangent variable updates multiple vars, choose one arbitrarily. e.g. If D == ∂ₜ(C) and D == ∂ₜ(B), then rename D to either Ċ or B ̇.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.expand_operators-Tuple{SummationDecapode}","page":"Library Reference","title":"Decapodes.expand_operators","text":"function expand_operators(d::SummationDecapode)\n\nFind operations that are compositions, and expand them with intermediate variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.fill_names!-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"Decapodes.fill_names!","text":"fill_names!(d::AbstractNamedDecapode)\n\nProvide a variable name to all the variables that don't have names.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.gensim-Tuple{AbstractNamedDecapode}","page":"Library Reference","title":"Decapodes.gensim","text":"function gensim(d::AbstractNamedDecapode; dimension::Int=2)\n\nGenerate a simulation function from the given Decapode. The returned function can then be combined with a mesh and a function describing function mappings to return a simulator to be passed to solve.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.infer_types!-Tuple{SummationDecapode, Vector{NamedTuple{(:src_type, :tgt_type, :op_names), Tuple{Symbol, Symbol, Vector{Symbol}}}}, Vector{NamedTuple{(:proj1_type, :proj2_type, :res_type, :op_names), Tuple{Symbol, Symbol, Symbol, Vector{Symbol}}}}}","page":"Library Reference","title":"Decapodes.infer_types!","text":"function infer_types!(d::SummationDecapode, op1_rules::Vector{NamedTuple{(:src_type, :tgt_type, :replacement_type, :op), NTuple{4, Symbol}}})\n\nInfer types of Vars given rules wherein one type is known and the other not.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.loadmesh","page":"Library Reference","title":"Decapodes.loadmesh","text":"loadmesh(s, subdivision=Circumcenter())\n\nLoad in a mesh from the Artifacts.jl system and automatically subdivide it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Decapodes.loadmesh-Tuple{Icosphere}","page":"Library Reference","title":"Decapodes.loadmesh","text":"loadmesh(s::Icosphere)\n\nLoad in a icosphere mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.loadmesh-Tuple{Point_Map}","page":"Library Reference","title":"Decapodes.loadmesh","text":"loadmesh(s::Point_Map)\n\nLoad in a point map describing the connectivity of the toroidal mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.loadmesh-Tuple{Rectangle_30x10}","page":"Library Reference","title":"Decapodes.loadmesh","text":"loadmesh(s::Rectangle_30x10)\n\nLoad in a rectangular mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.loadmesh-Tuple{Torus_30x10}","page":"Library Reference","title":"Decapodes.loadmesh","text":"loadmesh(s::Torus_30x10)\n\nLoad in a toroidal mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.recursive_delete_parents-Tuple{SummationDecapode, Vector{Int64}}","page":"Library Reference","title":"Decapodes.recursive_delete_parents","text":"function recursive_delete_parents!(d::SummationDecapode, to_delete::Vector{Int64})\n\nDelete the given nodes and their parents in the decapode, recursively.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.resolve_overloads!-Tuple{SummationDecapode, Vector{NamedTuple{(:src_type, :tgt_type, :resolved_name, :op), NTuple{4, Symbol}}}, Vector{NamedTuple{(:proj1_type, :proj2_type, :res_type, :resolved_name, :op), NTuple{5, Symbol}}}}","page":"Library Reference","title":"Decapodes.resolve_overloads!","text":"function resolve_overloads!(d::SummationDecapode, op1_rules::Vector{NamedTuple{(:src_type, :tgt_type, :resolved_name, :op), NTuple{4, Symbol}}})\n\nResolve function overloads based on types of src and tgt.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.resolve_overloads!-Tuple{SummationDecapode}","page":"Library Reference","title":"Decapodes.resolve_overloads!","text":"function resolve_overloads!(d::SummationDecapode)\n\nResolve function overloads based on types of src and tgt.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.unique_by!-Tuple{Any, Symbol, Vector{Symbol}}","page":"Library Reference","title":"Decapodes.unique_by!","text":"function unique_by!(acset, column_names::Vector{Symbol})\n\nGiven column names from the same table, remove duplicate rows.\n\nWARNING: This function does not check if other tables index into the one given. Removal of rows is performed with prejudice.\n\nSee also: unique_by.\n\nExamples\n\njulia> unique_by!(parallel_arrows(Graph, 123), :E, [:src,:tgt]) == parallel_arrows(Graph, 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.unique_by-Tuple{Any, Symbol, Vector{Symbol}}","page":"Library Reference","title":"Decapodes.unique_by","text":"function unique_by(acset, column_names::Vector{Symbol})\n\nGiven column names from the same table, return a copy of the acset with duplicate rows removed. Removal of rows is performed with prejudice.\n\nWARNING: This function does not check if other tables index into the one given. Removal of rows is performed with prejudice.\n\nSee also: unique_by!.\n\nExamples\n\njulia> unique_by(parallel_arrows(Graph, 123), :E, [:src,:tgt]) == parallel_arrows(Graph, 1)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.@decapode-Tuple{Any}","page":"Library Reference","title":"Decapodes.@decapode","text":"macro decapode(e)\n\nConstruct a Decapode.\n\n\n\n\n\n","category":"macro"},{"location":"equations/#Simple-Equations","page":"Equations","title":"Simple Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"This tutorial shows how to use Decapodes to represent simple equations. These aren't using any of the Discrete Exterior Calculus or CombinatorialSpaces features of Decapodes. They just are a reference for how to build equations with the @decapodes macro and see how they are stored as ACSets.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"using Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nusing Decapodes","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The harmonic oscillator can be written in Decapodes in at least three different ways.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"The default representation is a tabular output as an ACSet. The tables are Var for storing variables (X) and their types (Form0). TVar for identifying a subset of variables that are the tangent variables of the dynamics (Ẋ). The unary operators are stored in Op1 and binary operators stored in Op2. If a table is empty, it doesn't get printed.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Even though a diagrammatic equation is like a graph, there are no edge tables, because the arity (number of inputs) and coarity (number of outputs) is baked into the operator definitions.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"You can also see the output as a directed graph. The input arrows point to the state variables of the system and the output variables point from the tangent variables. You can see that I have done the differential degree reduction from  x'' = -kx by introducing a velocity term v. Decapodes has some support for derivatives in the visualization layer, so it knows that dX/dt should be called Ẋ and that dẊ/dt should be called Ẋ̇.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"In the previous example, we viewed negation and transformation by k as operators. Notice that k appears as an edge in the graph and not as a vertex. You can also use a 2 argument function like multiplication (*). With a constant value for k::Constant. In this case you will see k enter the diagram as a vertex and multiplication with * as a binary operator.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"This gives you a different graphical representation as well. Now we have the cartesian product objects which represent a tupling of two values.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"to_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"You can also represent negation as a multiplication by a literal -1.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Constant\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Notice that the type bubble for the literal one is ΩL. This means that it is a literal. The literal is also used as the variable name.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"We can allow the material properties to vary over time by changing Constant to Parameter. This is how we tell the simulator that it needs to call k(t) at each time step to get the updated value for k or if it can just reuse that constant k from the initial time step.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"oscillator = @decapode begin\n  X::Form0\n  V::Form0\n\n  k::Parameter\n\n  ∂ₜ(X) == V\n  ∂ₜ(V) == -1*k*(X)\nend","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"infer_types!(oscillator)\nto_graphviz(oscillator)","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Often you will have a linear material where you are scaling by a constant, and a nonlinear version of that material where that scaling is replaced by a generic nonlinear function. This is why we allow Decapodes to represent both of these types of equations.","category":"page"},{"location":"budyko_sellers_halfar/#Budko-Sellers-Halfar","page":"Budyko-Sellers-Halfar","title":"Budko-Sellers-Halfar","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"In this example, we will compose the Budyko-Sellers 1D energy balance model of the Earth's surface temperature with the Halfar model of glacial dynamics. Note that each of these components models is itself a composition of smaller physical models. In this walkthrough, we will compose them together using the same techniques.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing Decapodes\n\n# External Dependencies\nusing MLStyle\nusing MultiScaleArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing CairoMakie\nusing GeometryBasics: Point2\nPoint2D = Point2{Float64};","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We defined the Budyko-Sellers and Halfar models in example scripts (soon to be turned into Docs pages) in the examples/climate folder of the main repository. We recall them here.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"include(\"../../examples/climate/budyko_sellers.jl\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"include(\"../../examples/climate/shallow_ice.jl\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers = apex(budyko_sellers_cospan)\nhalfar = apex(ice_dynamics_cospan)\ntrue # hide","category":"page"},{"location":"budyko_sellers_halfar/#Budyko-Sellers","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"to_graphviz(budyko_sellers)","category":"page"},{"location":"budyko_sellers_halfar/#Halfar","page":"Budyko-Sellers-Halfar","title":"Halfar","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"to_graphviz(halfar)","category":"page"},{"location":"budyko_sellers_halfar/#Warming","page":"Budyko-Sellers-Halfar","title":"Warming","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"This is a formula that computes A for use in the Halfar glacial dynamics, given T from the Budyko-Sellers model.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# Tₛ(ϕ,t) := Surface temperature\n# A(ϕ) := Longwave emissions at 0°C\nwarming = @decapode begin\n  (Tₛ)::Form0\n  (A)::Form1\n\n  A == avg₀₁(5.8282*10^(-0.236 * Tₛ)*1.65e7)\n\nend\nto_graphviz(warming)","category":"page"},{"location":"budyko_sellers_halfar/#Composition","page":"Budyko-Sellers-Halfar","title":"Composition","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Observe that this composition technique is the same as that used in composing each of the Budyko-Sellers and Halfar models.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_composition_diagram = @relation () begin\n  budyko_sellers(Tₛ)\n\n  warming(A, Tₛ)\n\n  halfar(A)\nend\nto_graphviz(budyko_sellers_halfar_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We apply a composition by plugging in a Decapode for each component. We also specify the internal name of the variables to be used in combining.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar_cospan = oapply(budyko_sellers_halfar_composition_diagram,\n  [Open(budyko_sellers, [:Tₛ]),\n   Open(warming, [:A, :Tₛ]),\n   Open(halfar, [:stress_A])])\nbudyko_sellers_halfar = apex(budyko_sellers_halfar_cospan)\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can perform type inference to determine what kind of differential form each of our variables are.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"budyko_sellers_halfar = expand_operators(budyko_sellers_halfar)\ninfer_types!(budyko_sellers_halfar, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(budyko_sellers_halfar, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(budyko_sellers_halfar)","category":"page"},{"location":"budyko_sellers_halfar/#Defining-the-mesh","page":"Budyko-Sellers-Halfar","title":"Defining the mesh","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"These dynamics will occur on a 1-D manifold (a line). Points near +-π/2 will represent points near the North/ South poles. Points near 0 represent those at the equator.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"s′ = EmbeddedDeltaSet1D{Bool, Point2D}()\n#add_vertices!(s′, 30, point=Point2D.(range(-π/2 + π/32, π/2 - π/32, length=30), 0))\nadd_vertices!(s′, 100, point=Point2D.(range(-π/2 + π/32, π/2 - π/32, length=100), 0))\nadd_edges!(s′, 1:nv(s′)-1, 2:nv(s′))\norient!(s′)\ns = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s′)\nsubdivide_duals!(s, Circumcenter())","category":"page"},{"location":"budyko_sellers_halfar/#Define-input-data","page":"Budyko-Sellers-Halfar","title":"Define input data","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We need to supply initial conditions to our model. We create synthetic data here, although one may imagine that they could source this from their data repo of choice.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# This is a primal 0-form, with values at vertices.\ncosϕᵖ = map(x -> cos(x[1]), point(s′))\n# This is a dual 0-form, with values at edge centers.\ncosϕᵈ = map(edges(s′)) do e\n  (cos(point(s′, src(s′, e))[1]) + cos(point(s′, tgt(s′, e))[1])) / 2\nend\n\nα₀ = 0.354\nα₂ = 0.25\nα = map(point(s′)) do ϕ\n  α₀ + α₂*((1/2)*(3*ϕ[1]^2 - 1))\nend\nA = 210\nB = 2\nf = 0.70\nρ = 1025\ncw = 4186\nH = 70\nC = map(point(s′)) do ϕ\n  f * ρ * cw * H\nend\nD = 0.6\n\n# Isothermal initial conditions:\nTₛ₀ = map(point(s′)) do ϕ\n  15\nend\n\n# Visualize initial condition for temperature.\nlines(map(x -> x[1], point(s′)), Tₛ₀)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"n = 3\nρ = 910\ng = 9.8\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,_)\n  (((x)^2)+2.5) / 1e3\nend\n\n# Visualize initial condition for ice sheet height.\nlines(map(x -> x[1], point(s′)), h₀)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"# Store these values to be passed to the solver.\nu₀ = construct(PhysicsState, [\n  VectorForm(Tₛ₀),\n  VectorForm(h₀),\n  ], Float64[], [\n  :Tₛ,\n  :halfar_h])\nconstants_and_parameters = (\n  budyko_sellers_absorbed_radiation_α = α,\n  budyko_sellers_outgoing_radiation_A = A,\n  budyko_sellers_outgoing_radiation_B = B,\n  budyko_sellers_energy_C = C,\n  budyko_sellers_diffusion_D = D,\n  budyko_sellers_cosϕᵖ = cosϕᵖ,\n  budyko_sellers_diffusion_cosϕᵈ = cosϕᵈ,\n  halfar_n = n,\n  halfar_stress_ρ = ρ,\n  halfar_stress_g = g)","category":"page"},{"location":"budyko_sellers_halfar/#Symbols-to-functions","page":"Budyko-Sellers-Halfar","title":"Symbols to functions","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"The symbols along edges in our Decapode must be mapped to executable functions. In the Discrete Exterior Calculus, all our operators are defined as relations bewteen points, lines, and triangles on meshes known as simplicial sets. Thus, DEC operators are re-usable across any simplicial set.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"budyko_sellers_halfar/#Simulation-generation","page":"Budyko-Sellers-Halfar","title":"Simulation generation","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"From our Decapode, we automatically generate a finite difference method solver that performs explicit time-stepping to solve our system of multiphysics equations.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"sim = eval(gensim(budyko_sellers_halfar, dimension=1))\nfₘ = sim(s, generate)","category":"page"},{"location":"budyko_sellers_halfar/#Run-simulation","page":"Budyko-Sellers-Halfar","title":"Run simulation","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We wrap our simulator and initial conditions and solve them with the stability-detection and time-stepping methods provided by DifferentialEquations.jl .","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"tₑ = 1e6\n\n# Julia will pre-compile the generated simulation the first time it is run.\n@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-4), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"We can save the solution file to examine later.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"@save \"budyko_sellers_halfar.jld2\" soln","category":"page"},{"location":"budyko_sellers_halfar/#Visualize","page":"Budyko-Sellers-Halfar","title":"Visualize","text":"","category":"section"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for temperature.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s′)), findnode(soln(tₑ), :Tₛ))","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Quickly examine the final conditions for ice height.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"lines(map(x -> x[1], point(s′)), findnode(soln(tₑ), :halfar_h))","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"Create animated GIFs of the temperature and ice height dynamics.","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"begin\n# Initial frame\nframes = 100\nfig = Figure(resolution = (800, 800))\nax1 = Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s′))))\nylims!(ax1, extrema(findnode(soln(tₑ), :Tₛ)))\nLabel(fig[1,1,Top()], \"Surface temperature, Tₛ, [C°]\")\nLabel(fig[2,1,Top()], \"Line plot of temperature from North to South pole, every $(tₑ/frames) time units\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_T.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s′)), findnode(soln(t), :Tₛ))\nend\nend\n\nbegin\n# Initial frame\nframes = 100\nfig = Figure(resolution = (800, 800))\nax1 = Axis(fig[1,1])\nxlims!(ax1, extrema(map(x -> x[1], point(s′))))\nylims!(ax1, extrema(findnode(soln(tₑ), :halfar_h)))\nLabel(fig[1,1,Top()], \"Ice height, h\")\nLabel(fig[2,1,Top()], \"Line plot of ice height from North to South pole, every $(tₑ/frames) time units\")\n\n# Animation\nrecord(fig, \"budyko_sellers_halfar_h.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n  lines!(fig[1,1], map(x -> x[1], point(s′)), findnode(soln(t), :halfar_h))\nend\nend","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_Temperature)","category":"page"},{"location":"budyko_sellers_halfar/","page":"Budyko-Sellers-Halfar","title":"Budyko-Sellers-Halfar","text":"(Image: BSH_IceHeight)","category":"page"},{"location":"bc_debug/#Simulation-Setup","page":"Misc Features","title":"Simulation Setup","text":"","category":"section"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"This tutorial showcases some of the other features included in the Decapodes.jl package. Currently, these features are the treatment of boundary conditions and the simulation debugger interface. To begin, we set up the same advection-diffusion problem presented in the Overview section. As before, we define the Diffusion, Advection, and Superposition components, and now include a BC (Bounday Condition) component. Decapodes.jl interprets any Hom which begins with a ∂ as a boundary condition. These boundary conditions recieve special treatment at the scheduling step. Below we show the graphical rendering of this boundary condition diagram, which we will use to impose a Dirichlet condition on the time derivative of concentration at the mesh boundary.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using Catlab\nusing Catlab.Graphics\nusing Decapodes\n\nDiffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Constant\n\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, C_up)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  C_up == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\nend\n\nBoundaryConditions = @decapode begin\n  (C, C_up)::Form0\n\n  # Temporal boundary\n  ∂ₜ(C) == Ċ\n\n  # Spatial boundary\n  Ċ == ∂C(C_up)\nend\n\nto_graphviz(BoundaryConditions)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"As before, we compose these physics components over our wiring diagram.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  bc(C, C_up)\n  superposition(ϕ₁, ϕ₂, ϕ, C_up, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(BoundaryConditions, [:C, :C_up]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C_up, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"When this is scheduled, Decapodes will apply any boundary conditions immediately after the impacted value is computed. This implementation choice ensures that this boundary condition holds true for any variables dependent on this variable, though also means that the boundary conditions on a variable have no immediate impact on the variables this variable is dependent on.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"In the visualization below, wee see that the final operation executed on the data is the boundary condition we are enforcing on the change in concentration.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"to_graphviz(DiffusionAdvection)","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Next we import the mesh we will use. In this case, we are wanting to impose boundary conditions and so we will use the plot_mesh from the previous example instead of the mesh with periodic boundary conditions. Because the mesh is only a primal mesh, we also generate and subdivide the dual mesh.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Rectangle_30x10 is a default mesh that is downloaded via Artifacts.jl when a user installs Decapodes. Via CombinatorialSpaces.jl, we can instantiate any .obj file of triangulated faces as a simplicial set.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\n\n# Generate the dual mesh\nplot_mesh_dual = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(plot_mesh)\n# Calculate distances and subdivisions for the dual mesh\nsubdivide_duals!(plot_mesh_dual, Circumcenter())\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"Finally, we define our operators, generate the simulation function, and compute the simulation. Note that when we define the boundary condition operator, we hardcode the boundary indices and values into the operator itself. We also move the initial concentration to the left, so that we are able to see a constant concentration on the left boundary which will act as a source in the flow. The modified initial condition is shown below:","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using LinearAlgebra\nusing MultiScaleArrays\nusing MLStyle\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\ninclude(\"../../examples/boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    :∂C => x -> begin\n      boundary = boundary_inds(Val{0}, sd)\n      x[boundary] .= 0\n      x\n    end\n    :∧₀₁ => (x,y) -> begin\n      ∧(Tuple{0,1}, sd, x,y)\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend\n\nusing Distributions\nc_dist = MvNormal([1, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in plot_mesh_dual[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[1:nv(plot_mesh)])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"And the simulation result is then computed and visualized below.","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"using OrdinaryDiffEq\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(plot_mesh_dual, generate)\n\nvelocity(p) = [-0.5, 0.0, 0.0]\nv = ♭(plot_mesh_dual, DualVectorField(velocity.(plot_mesh_dual[triangle_center(plot_mesh_dual),:dual_point]))).data\n\nu₀ = construct(PhysicsState, [VectorForm(c)], Float64[], [:C])\nparams = (V = v,)\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0), params)\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [findnode(sol(t), :C) for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv_right.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\n  ob.color = findnode(sol(t), :C)\nend","category":"page"},{"location":"bc_debug/","page":"Misc Features","title":"Misc Features","text":"(Image: )","category":"page"},{"location":"overview/#Introduction-to-Decapodes","page":"Overview","title":"Introduction to Decapodes","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (Decapodes) is a diagrammatic language used to express systems of ordinary and partial differential equations. The Decapode provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how Decapodes can be generated and interpreted.","category":"page"},{"location":"overview/#Your-First-Decapode","page":"Overview","title":"Your First Decapode","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin with the most basic Decapode, one which only includes a single variable. In the Decapode graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since the Decapode applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0 will be the 0-dimensional data points on some space, or in a discrete context, the values defined on points of a mesh. Similarly, Form1 will be values stored on edges of the mesh, and Form2 will be values stored on the surfaces of the mesh. Below, we provide a very simple Decapode with just a single variable C. and define a convenience function for visualization in later examples.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes\nusing Catlab, Catlab.Graphics\n\nVariable = @decapode begin\n  C::Form0\nend;\n\nto_graphviz(Variable)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting diagram contains a single node, showing the single variable in this system. We can then add a second variable:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"TwoVariables = @decapode begin\n  C::Form0\n  dC::Form1\nend;\n\nto_graphviz(TwoVariables)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"And then can add some relationship between them. In this case, we make an equation which states that dC is the discrete derivative of C:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Equation = @decapode begin\n  C::Form0\n  dC::Form1\n\n  dC == d₀(C)\nend;\n\nto_graphviz(Equation)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the discrete derivative.","category":"page"},{"location":"overview/#A-Little-More-Complicated","page":"Overview","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  (C, Ċ)::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\nend;\n\nto_graphviz(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting Decapode shows the relationships between the three variables with the triangle diagram. Note that these diagrams are automatically layed-out by Graphviz.","category":"page"},{"location":"overview/#Bring-in-the-Dynamics","page":"Overview","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using DifferentialEquations.jl to handle time-stepping and instability detection).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin this process by importing a mesh. The mesh has been pre-generated within CombinatorialSpaces, and is generated such that it has periodic boundary conditions. We will also upload a non-periodic mesh for the sake of visualization, as well as a mapping between the points on the periodic and non-periodic meshes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"See CombinatorialSpaces.jl for mesh construction and importing utilities.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\nperiodic_mesh = loadmesh(Torus_30x10())\npoint_map = loadmesh(Point_Map())\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With the mesh uploaded, we also need to convert the Decapode into something which can be scheduled with explicit time stepping. In order to do this, we take every variable which is the time derivative of another variable and trace back the operations needed to compute this. This process essentially generates a computation graph in the form of a directed wiring diagram.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Since our diagram is already defined, we just need to define a function which implements each of these symbolic operators and pass them to a scheduler for generating the function.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Note that we chose to define k as a function that multiplies by a value k. We could have alternately chosen to represent k as a Constant that we multiply by in the Decapode itself.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using MLStyle\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we generate the simulation function using gen_sim and set up our initial conditions for this problem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"sim = eval(gensim(Diffusion))\nfₘ = sim(periodic_mesh, generate)\n\nusing Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in periodic_mesh[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[point_map])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we solve this PDE problem using the Tsit5() solver and generate an animation of the result!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing MultiScaleArrays\nusing OrdinaryDiffEq\n\nu₀ = construct(PhysicsState, [VectorForm(c)], Float64[], [:C])\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [findnode(sol(t), :C)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diffusion.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = findnode(sol(t), :C)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"overview/#Merging-Multiple-Physics","page":"Overview","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode begin\n  C::Form0\n  ϕ::Form1\n\n  # Fick's first law\n  ϕ ==  k(d₀(C))\nend\n\nAdvection = @decapode begin\n  C::Form0\n  ϕ::Form1\n  V::Form1\n  ϕ == ∧₀₁(C,V)\nend\n\nSuperposition = @decapode begin\n  (C, Ċ)::Form0\n  (ϕ, ϕ₁, ϕ₂)::Form1\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹(dual_d₁(⋆₁(ϕ)))\n  ∂ₜ(C) == Ċ\nend\ntrue # hide","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Advection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"to_graphviz(Superposition)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After this, the physics can be composed as follows:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DiffusionAdvection_cospan = oapply(compose_diff_adv,\n                  [Open(Diffusion, [:C, :ϕ]),\n                   Open(Advection, [:C, :ϕ, :V]),\n                   Open(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\nDiffusionAdvection = apex(DiffusionAdvection_cospan)\n\nto_graphviz(DiffusionAdvection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Similar to before, this physics can be compiled and executed. Note that this process now requires another value to be defined, namely the velocity vector field. We do this using a custom operator called flat_op. This operator is basically the flat operator from CombinatorialSpaces.jl, but specialized to account for the periodic mesh.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We could instead represent the domain as a the surface of a an object with equivalent boundaries in 3D.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"function closest_point(p1, p2, dims)\n    p_res = collect(p2)\n    for i in 1:length(dims)\n        if dims[i] != Inf\n            p = p1[i] - p2[i]\n            f, n = modf(p / dims[i])\n            p_res[i] += dims[i] * n\n            if abs(f) > 0.5\n                p_res[i] += sign(f) * dims[i]\n            end\n        end\n    end\n    Point3{Float64}(p_res...)\nend\n\nfunction flat_op(s::AbstractDeltaDualComplex2D, X::AbstractVector; dims=[Inf, Inf, Inf])\n  tri_map = Dict{Int,Int}(triangle_center(s,t) => t for t in triangles(s))\n\n  map(edges(s)) do e\n    p = closest_point(point(s, tgt(s,e)), point(s, src(s,e)), dims)\n    e_vec = (point(s, tgt(s,e)) - p) * sign(1,s,e)\n    dual_edges = elementary_duals(1,s,e)\n    dual_lengths = dual_volume(1, s, dual_edges)\n    mapreduce(+, dual_edges, dual_lengths) do dual_e, dual_length\n      X_vec = X[tri_map[s[dual_e, :D_∂v0]]]\n      dual_length * dot(X_vec, e_vec)\n    end / sum(dual_lengths)\n  end\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing MLStyle\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :k => x -> 0.05*x\n    :∧₀₁ => (x,y) -> begin\n      ∧(Tuple{0,1}, sd, x,y)\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend\n\nsim = eval(gensim(DiffusionAdvection))\nfₘ = sim(periodic_mesh, generate)\n\nvelocity(p) = [-0.5, -0.5, 0.0]\nv = flat_op(periodic_mesh, DualVectorField(velocity.(periodic_mesh[triangle_center(periodic_mesh),:dual_point])); dims=[30, 10, Inf])\n\nu₀ = construct(PhysicsState, [VectorForm(c), VectorForm(v)], Float64[], [:C, :V])\n\nprob = ODEProblem(fₘ, u₀, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [findnode(sol(t), :C)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = findnode(sol(t), :C)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: ) ```","category":"page"},{"location":"ice_dynamics/#Halfar's-model-of-glacial-flow","page":"Glacial Flow","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing Decapodes\n\n# External Dependencies\nusing MLStyle\nusing MultiScaleArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing SparseArrays\nusing Statistics\nusing CairoMakie\nusing GeometryBasics: Point2, Point3\nPoint2D = Point2{Float64};\nPoint3D = Point3{Float64};","category":"page"},{"location":"ice_dynamics/#Defining-the-models","page":"Glacial Flow","title":"Defining the models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first step is to find a suitable equation for our model, and translate it into the Discrete Exterior Calculus. The Exterior Calculus is a generalization of vector calculus, so for low-dimensional spaces, this translation is straightforward. For example, divergence is typically written as (⋆, d, ⋆). Scalar fields are typically interpreted as \"0Forms\", i.e. values assigned to vertices of a mesh.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We use the @decapode macro to interpret the equations. Here, we have equation 2 from Halfar:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fracpartial hpartial t = frac2n + 2 (fracrho gA)^n fracpartialpartial x(fracpartial hpartial x fracpartial hpartial x ^n-1 h^n+2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll change the term out front to Γ so we can demonstrate composition in a moment.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In the exterior calculus, we could write the above equations like so:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"partial_t(h) = circ(star d star)(Gammaquad d(h)quad textavg_01d(h)^sharp^n-1 quad textavg_01(h^n+2))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"avg here is an operator that performs the midpoint rule, setting the value at an edge to be the average of the values at its two vertices.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form1\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯(d(h)))^(n-1)) * avg₀₁(h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"And here, a formulation of Glen's law from J.W. Glen's 1958 \"The flow law of ice\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"glens_law = @decapode begin\n  #Γ::Form0\n  Γ::Form1\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"ice_dynamics/#Composing-models","page":"Glacial Flow","title":"Composing models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can use operadic composition to specify how our models come together. In this example, we have two Decapodes, and two quantities that are shared between them.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_composition_diagram = @relation () begin\n  dynamics(Γ,n)\n  stress(Γ,n)\nend\n\nto_graphviz(ice_dynamics_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To a apply a composition, we specify which Decapodes to plug into those boxes, and what each calls the corresponding shared variables internally.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"ice_dynamics/#Provide-a-semantics","page":"Glacial Flow","title":"Provide a semantics","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To interpret our composed Decapode, we need to specify what Discrete Exterior Calculus to interpret our quantities in. Let's choose the 1D Discrete Exterior Calculus:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics1D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics1D, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(ice_dynamics1D, op1_res_rules_1D, op2_res_rules_1D)\n\nto_graphviz(ice_dynamics1D)","category":"page"},{"location":"ice_dynamics/#Define-a-mesh","page":"Glacial Flow","title":"Define a mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll need a mesh to simulate on. Since this is a 1D mesh, we can go ahead and make one right now:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# This is a 1D mesh, consisting of edges and vertices.\ns′ = EmbeddedDeltaSet1D{Bool, Point2D}()\n# 20 hundred vertices along a line, connected by edges.\nadd_vertices!(s′, 20, point=Point2D.(range(0, 10_000, length=20), 0))\nadd_edges!(s′, 1:nv(s′)-1, 2:nv(s′))\norient!(s′)\ns = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s′)\nsubdivide_duals!(s, Circumcenter())","category":"page"},{"location":"ice_dynamics/#Define-input-data","page":"Glacial Flow","title":"Define input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need initial conditions to use for our simulation.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\n# We choose a distribution that obeys the shallow height and shallow slope conditions.\nh₀ = map(point(s′)) do (x,_)\n  ((7072-((x-5000)^2))/9e3+2777)/2777e-1\nend\n\n# Visualize initial conditions for ice sheet height.\nlines(map(x -> x[1], point(s′)), h₀, linewidth=5)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need to tell our Decapode which data maps to which symbols. We can wrap up our data like so:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:dynamics_h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-functions","page":"Glacial Flow","title":"Define functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. In the DEC, there are a handful of operators that one uses to construct all the usual vector calculus operations, namely: ♯, ♭, ∧, d, ⋆. The CombinatorialSpaces.jl library specifies many of these for us.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-the-simulation","page":"Glacial Flow","title":"Generate the simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Now, we have everything we need to generate our simulation:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics1D, dimension=1))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first time that you run a function, Julia will pre-compile it, so that later runs will be fast. We'll solve our simulation for a short time span, to trigger this pre-compilation, and then run it.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\ntₑ = 8e3\n\n# This next run should be fast.\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can save our solution file in case we want to examine its contents when this Julia session ends.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics1D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's examine the final conditions:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig,ax,ob = lines(map(x -> x[1], point(s′)), findnode(soln(tₑ), :dynamics_h), linewidth=5)\nylims!(ax, extrema(h₀))\ndisplay(fig)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We see that our distribution converges to a more uniform ice height across our domain, which matches our physical intuition.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's create a GIF to examine an animation of these dynamics:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Create a gif\nbegin\n  frames = 100\n  fig, ax, ob = lines(map(x -> x[1], point(s′)), findnode(soln(0), :dynamics_h))\n  ylims!(ax, extrema(h₀))\n  record(fig, \"ice_dynamics1D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    lines!(map(x -> x[1], point(s′)), findnode(soln(t), :dynamics_h))\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics1D)","category":"page"},{"location":"ice_dynamics/#D-Re-interpretation","page":"Glacial Flow","title":"2D Re-interpretation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first, one-dimensional, semantics that we provided to our Decapode restricted the kinds of glacial sheets that we could model. (i.e. We could only look at glacial sheets which were constant along y). We can give our Decapode an alternate semantics, as some physics on a 2-dimensional manifold.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Note that for these physics, we make no adjustments to the underlying \"dimension-agnostic\" Decapode, we only provide a different set of rules for inferring what the type of each quantity is.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\n\nto_graphviz(ice_dynamics2D)","category":"page"},{"location":"ice_dynamics/#Store-as-JSON","page":"Glacial Flow","title":"Store as JSON","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We quickly demonstrate how to serialize a Decapode to JSON and read it back in:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"write_json_acset(ice_dynamics2D, \"ice_dynamics2D.json\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# When reading back in, we specify that all attributes are \"Symbol\"s.\nice_dynamics2 = read_json_acset(SummationDecapode{Symbol,Symbol,Symbol}, \"ice_dynamics2D.json\")\n# Or, you could choose to interpret the data as \"String\"s.\nice_dynamics3 = read_json_acset(SummationDecapode{String,String,String}, \"ice_dynamics2D.json\")\n\nto_graphviz(ice_dynamics3)","category":"page"},{"location":"ice_dynamics/#Define-our-mesh","page":"Glacial Flow","title":"Define our mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"include(\"../../examples/grid_meshes.jl\")\ns′ = triangulated_grid(10_000,10_000,800,800,Point3D)\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nwireframe(s)","category":"page"},{"location":"ice_dynamics/#Define-our-input-data","page":"Glacial Flow","title":"Define our input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y)\n  (7072-((x-5000)^2 + (y-5000)^2)^(1/2))/9e3+10\nend\n\n# Visualize initial condition for ice sheet height.\nmesh(s′, color=h₀, colormap=:jet)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:dynamics_h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-our-functions","page":"Glacial Flow","title":"Define our functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      ♯(sd, EForm(x))\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      @show length(x)\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-simulation","page":"Glacial Flow","title":"Generate simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run-2","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"tₑ = 5e13\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics2D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize-2","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Final conditions:\nmesh(s′, color=findnode(soln(tₑ), :dynamics_h), colormap=:jet, colorrange=extrema(findnode(soln(0), :dynamics_h)))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 100\n  fig, ax, ob = CairoMakie.mesh(s′, color=findnode(soln(0), :dynamics_h), colormap=:jet, colorrange=extrema(findnode(soln(0), :dynamics_h)))\n  Colorbar(fig[1,2], ob)\n  record(fig, \"ice_dynamics2D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    ob.color = findnode(soln(t), :dynamics_h)\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2D)","category":"page"},{"location":"ice_dynamics/#Manifold-in-3D","page":"Glacial Flow","title":"2-Manifold in 3D","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We note that just because our physics is happening on a 2-manifold, (a surface), this doesn't restrict us to the 2D plane. In fact, we can \"embed\" our 2-manifold in 3D space to simulate a glacial sheets spread across the globe.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s′ = loadmesh(Icosphere(3, 10_000))\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nwireframe(s)\n","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y,z)\n  (z*z)/(10_000*10_000)\nend\n\n# Visualize initial condition for ice sheet height.\n# There is lots of ice at the poles, and no ice at the equator.\nmesh(s′, color=h₀, colormap=:jet)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:dynamics_h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# For brevity's sake, we'll skip the pre-compilation cell.\n\ntₑ = 5e25\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\n# Compare the extrema of the initial and final conditions of ice height.\nextrema(findnode(soln(0), :dynamics_h)), extrema(findnode(soln(tₑ), :dynamics_h))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"mesh(s′, color=findnode(soln(tₑ), :dynamics_h), colormap=:jet, colorrange=extrema(findnode(soln(0), :dynamics_h)))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 200\n  fig, ax, ob = CairoMakie.mesh(s′, color=findnode(soln(0), :dynamics_h), colormap=:jet, colorrange=extrema(findnode(soln(0), :dynamics_h)))\n\n  Colorbar(fig[1,2], ob)\n  # These particular initial conditions diffuse quite quickly, so let's just look at\n  # the first moments of those dynamics.\n  record(fig, \"ice_dynamics2D_sphere.gif\", range(0.0, tₑ/64; length=frames); framerate = 20) do t\n    ob.color = findnode(soln(t), :dynamics_h)\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2DSphere)","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes are a graphical tool for the composition of physical systems. Ultimately, this library will include tooling which takes advantage of the formalization of physical theories described by DEC provided by CombinatorialSpaces.jl.","category":"page"},{"location":"#Getting-started","page":"Decapodes.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Walkthroughs creating, composing, and solving Decapodes are available in the side-bar of this documentation page. Further example scripts are avaiable in the examples folder of the Decapodes.jl GitHub repo, and will be added to this documentation site soon.","category":"page"},{"location":"#NOTE","page":"Decapodes.jl","title":"NOTE","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"This library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"},{"location":"poiseuille/#Poissuille-Flow-for-Fluid-Mechanics","page":"Pipe Flow","title":"Poissuille Flow for Fluid Mechanics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"When modeling a fluid flowing in a pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The noslip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using Catlab\nusing CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nusing Decapodes\n\n# Julia community libraries\nusing CairoMakie\nusing GeometryBasics\nusing LinearAlgebra\nusing OrdinaryDiffEq","category":"page"},{"location":"poiseuille/#Creating-the-Poiseuille-Equations","page":"Pipe Flow","title":"Creating the Poiseuille Equations","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The @decapode macro creates the data structure representing the equations of Poiseuille flow. The first block declares variables, the second block defines intermediate terms and the last block is the core equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# μ̃ = negative viscosity per unit area\n# R = drag of pipe boundary\n\nPoise = @decapode begin\n  P::Form0\n  q::Form1\n\n  # Laplacian of q for the viscous effect\n  Δq == Δ(q)\n  # Gradient of P for the pressure driving force\n  ∇P == d(P)\n\n  # Definition of the time derivative of q\n  ∂ₜ(q) == q̇\n\n  # The core equation\n#  q̇ == μ̃(Δq) + ∇P + R * q\n  q̇ == μ̃  * ∂q(Δq) + ∇P + R * q\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/#Defining-the-Semantics","page":"Pipe Flow","title":"Defining the Semantics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The generate function below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. ","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using MLStyle\ninclude(\"../../examples/boundary_helpers.jl\")\n\nfunction generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :∂ρ => x -> begin\n      x[boundary_edges(sd)] .= 0\n      x\n    end\n    :∧₀₁ => (x,y) -> begin\n      ∧(Tuple{(0,1)}, sd, x,y)\n    end\n    :∂ρ => ρ -> begin\n      ρ[1] = 0\n      ρ[end] = 0\n      ρ\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"poiseuille/#A-Single-Pipe-Segment","page":"Pipe Flow","title":"A Single Pipe Segment","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We create a mesh with one pipe segment to see if we get the right answer. This simulation can be validated with the Poiseuille equation for a single pipe. First we create the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Point3D = Point3{Float64}\ns = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])\nadd_edge!(s, 1, 2, edge_orientation=true)\n\nsd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(sd, Circumcenter())\nsd","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"using MultiScaleArrays\nsim = eval(gensim(Poise))\nfₘ = sim(sd, generate)\nu = construct(PhysicsState, [VectorForm(q)], Float64[], [:q])\nparams = (k = -0.01, μ̃ = 0.5)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/#A-Linear-Pipe-with-Multiple-Segments","page":"Pipe Flow","title":"A Linear Pipe with Multiple Segments","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into n segments. First we define the mesh:","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\n\nsd = linear_pipe(10)\ntrue # hide","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Note that we do not generate new simulation code for Poiseuille flow with gensim again. We provide our new mesh so that our discrete differential operators can be instantiated.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nq = [5,3,4,2,5,2,8,4,3]\nu = construct(PhysicsState, [VectorForm(q)], Float64[], [:q])\nparams = (k = -0.01, μ̃ = 0.5)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5());\nsol.u","category":"page"},{"location":"poiseuille/#A-Distribution-Network","page":"Pipe Flow","title":"A Distribution Network","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"To model a distribution network such as residential drinking water or natural gas, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"function binary_pipe(depth::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertex!(s, point=Point3D(0, 0, 0))\n  for n in 1:depth\n    for prev_v in vertices(s)[end-2^(n-1)+1:end]\n      x, y, _ = s[:point][prev_v]\n      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)\n                                 for sgn in [1,-1]])\n      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)\n    end\n  end\n  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))\n  add_edge!(s, 1, v, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\n  sd\nend\nsd = binary_pipe(2)\ntrue # hide","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"fₘ = sim(sd, generate)\nq = fill(5.0, ne(sd))\nu = construct(PhysicsState, [VectorForm(q)], Float64[], [:q])\nparams = (k = -0.01, μ̃ = 0.5)\nprob = ODEProblem(fₘ, u, (0.0, 10000.0), params)\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/#Multiphysics","page":"Pipe Flow","title":"Multiphysics","text":"","category":"section"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow (q) and the pressure (P) to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"The Decapode can be visualized with graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper [PBHF22]. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# μ̃ = negative viscosity per unit area\n# R = drag of pipe boundary\n# k = pressure as a function of density\nPoise = @decapode begin\n#  ∇P::Form1\n#  (q, q̇, Δq)::Form1\n  q::Form1\n  (P, ρ)::Form0\n\n  # Poiseuille Flow\n  Δq == ∘(d, ⋆, d, ⋆)(q)\n  ∂ₜ(q) == q̇\n#  ∇P == d₀(P)\n  ∇P == d(P)\n#  q̇ == sum₁(sum₁(μ̃(Δq), ¬(∇P)),R(q))\n  q̇ == μ̃ * ∂q(Δq) - ∇P + R * q\n  \n  # Pressure/Density Coupling\n  P == k * ρ\n  ∂ₜ(ρ) == ρ̇\n  #ρ̇ == ⋆₀⁻¹(dual_d₀(⋆₁(∧₀₁(ρ,q)))) # advection\n  ρ_up == ∘(⋆, d, ⋆)(-1 * ∧₀₁(ρ,q)) # advection\n  \n  # Boundary conditions\n  ρ̇ == ∂ρ(ρ_up)\nend\n\nPoise = expand_operators(Poise)\ninfer_types!(Poise, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(Poise, op1_res_rules_1D, op2_res_rules_1D)\nto_graphviz(Poise)","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Then we can create the mesh and solve the equation.","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"# Create mesh and subdivide it.\nfunction linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  sd = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(sd, Circumcenter())\nend\n\nsd = linear_pipe(10)\n\nsim = gensim(Poise)\nfunc = sim(sd, generate)\n\nprob = ODEProblem(func, [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5], (0.0, 10000.0), [10. *i for i in 1:10])\nsol = solve(prob, Tsit5())\nsol.u","category":"page"},{"location":"poiseuille/","page":"Pipe Flow","title":"Pipe Flow","text":"Notice that the solution contains both a vector of flows and a vector of pressures.","category":"page"}]
}
