var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Diagrams","page":"Library Reference","title":"Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Diagrams ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Diagrams","page":"Library Reference","title":"Decapodes.Diagrams","text":"Provides the tooling for defining Decapodes conveniently with symbolic expressions\n\n\n\n\n\n","category":"module"},{"location":"api/#Decapodes.Diagrams.Decapodes2D","page":"Library Reference","title":"Decapodes.Diagrams.Decapodes2D","text":"Decapodes2D A schema which includes any homomorphisms that may be added by the @decapode macro.\n\nTODO: This should be chipped away at as more of this tooling takes advantage of the Catlab GAT system\n\n\n\n\n\n","category":"constant"},{"location":"api/#Decapodes.Diagrams.@decapode-Tuple{Any, Any}","page":"Library Reference","title":"Decapodes.Diagrams.@decapode","text":"decapode(cat, body)\n\nThis macro is called as:\n\n@decapode presentation begin\n  expressions\nend\n\nwhere presentation is a Presentation containing the syntax for the Decapode (operators and form types), and expressions is symbolic expressions of the relations within the Decapode.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Open-Diagrams","page":"Library Reference","title":"Open Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.OpenDiagrams ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.OpenDiagrams.OpenDiagram","page":"Library Reference","title":"Decapodes.OpenDiagrams.OpenDiagram","text":"Open diagram as a structured multicospan in R-form.\n\nAn open diagram is a diagram, represented as a FinDomFunctor, together with a cospan of finite sets whose apex is the object set of the diagram's indexing category.\n\n\n\n\n\n","category":"type"},{"location":"api/#Simulation","page":"Library Reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Simulations ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Simulations.ArbitraryFunc","page":"Library Reference","title":"Decapodes.Simulations.ArbitraryFunc","text":"ArbitraryFunc\n\nOut of place function which applies to any number of arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.ConstantFunc","page":"Library Reference","title":"Decapodes.Simulations.ConstantFunc","text":"ConstantFunc\n\nFunction which always returns the same value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.ElementwiseFunc","page":"Library Reference","title":"Decapodes.Simulations.ElementwiseFunc","text":"ElementwiseFunc\n\nFunction applied to each element of one or more vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.InPlaceFunc","page":"Library Reference","title":"Decapodes.Simulations.InPlaceFunc","text":"InPlaceFunc\n\nFunction which operates on arguments in-place, not returning a value.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.MatrixFunc","page":"Library Reference","title":"Decapodes.Simulations.MatrixFunc","text":"MatrixFunc\n\nLinear operator applied through matrix multiplication.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.TDInPlaceFunc","page":"Library Reference","title":"Decapodes.Simulations.TDInPlaceFunc","text":"TDInPlaceFunc\n\nFunction which accepts the current time as the last argument. Used to set up time-dependent physics or boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Decapodes.Simulations.gen_sim-Tuple{WiringDiagram, Any, Any}","page":"Library Reference","title":"Decapodes.Simulations.gen_sim","text":"gen_sim(dwd::WiringDiagram, name2func::Dict,             s::EmbeddedDeltaDualComplex2D;             form2dim=form2dim, params=[], autodiff=false)\n\nThis function generates a function which evaluates the acylcic directed wiring diagram dwd, using the functions in name2func for operators to execute corresonding to each box and information from the mesh s to pre-allocate necessary memory. This operator can generate a function which is compatible with the autodifferentiation solvers in DifferentialEquations.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#Schedules","page":"Library Reference","title":"Schedules","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Schedules ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Schedules","page":"Library Reference","title":"Decapodes.Schedules","text":"Schedules\n\nThis module contains the tooling which converts diagrams to DWDs.\n\nTODO This module will also include optimization tooling relating to DWD schedules (compressing matrix operations, pre-computing constant values, etc).\n\n\n\n\n\n","category":"module"},{"location":"api/#Decapodes.Schedules.diag2dwd-Tuple{Any}","page":"Library Reference","title":"Decapodes.Schedules.diag2dwd","text":"diag2dwd(diagram; clean = false, calcstates = [], outvars=[], in_vars=[])\n\nGenerates a directed wiring diagram (DWD) from a Decapode diagram. This method generates a DWD which represents a single explicit time step of the system, computed by the dependency graph of each time derivative within the system. This does not necessarily work for all Decapodes, and only generates an explicit time-step solution.\n\nTODO: Functions like this can be created to generate other solution styles, like implicit solutions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Examples","page":"Library Reference","title":"Examples","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Examples ]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.Examples.dual-Union{Tuple{CombinatorialSpaces.SimplicialSets.EmbeddedDeltaSet2D{O, P}}, Tuple{P}, Tuple{O}} where {O, P}","page":"Library Reference","title":"Decapodes.Examples.dual","text":"dual(s::EmbeddedDeltaSet2D{O, P})\n\nGenerates a dual mesh for the provided delta set s.\n\nTODO: This tooling should be upstreamed to CombinatorialSpaces\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.Examples.expand_dwd-Tuple{Any, Any}","page":"Library Reference","title":"Decapodes.Examples.expand_dwd","text":"expanddwd(dwdorig::WiringDiagram, patterns::Dict{Symbol, WiringDiagram})\n\nReplaces any boxes in dwd_orig which map to a key in patterns with their corresponding diagram in patterns. This allows for replacement of complex operations with their definition.\n\n\n\n\n\n","category":"method"},{"location":"api/#PetriNets","page":"Library Reference","title":"PetriNets","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.PetriNets]\nPrivate = false","category":"page"},{"location":"api/#Decapodes.PetriNets.expand_pres!-Tuple{Any, LabelledReactionNet{R, C} where {R, C}}","page":"Library Reference","title":"Decapodes.PetriNets.expand_pres!","text":"expand_pres!(pres::Presentation, pn::LabelledReactionNet)\n\nExpands the syntax of the presentation pres to include the necessary operators for expressing mass action on the Petri net pn.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.PetriNets.gen_functions-Tuple{LabelledReactionNet{R, C} where {R, C}, Any}","page":"Library Reference","title":"Decapodes.PetriNets.gen_functions","text":"gen_functions(pn::LabelledReactionNet, s::EmbeddedDeltaDualComplex2D)\n\nGenerates the functions necessary for executing the Petri net after it has been converted to a Decapode.\n\n\n\n\n\n","category":"method"},{"location":"api/#Decapodes.PetriNets.pn2dec-Tuple{Any, LabelledReactionNet{R, C} where {R, C}}","page":"Library Reference","title":"Decapodes.PetriNets.pn2dec","text":"pn2dec(prs::Presentation, pn::LabelledReactionNet)\n\nGenerates a Decapode diagram which represents the law of mass action applied to the petri net pn with the syntax from the presentation prs.\n\n\n\n\n\n","category":"method"},{"location":"overview/#Introduction-to-DECAPODEs","page":"Overview","title":"Introduction to DECAPODEs","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (DECAPODE) is a diagrammatic language used to express systems of ordinary and partial differential equations. The DECAPODE provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how DECAPODEs can be generated and interpreted.","category":"page"},{"location":"overview/#Your-First-DECAPODE","page":"Overview","title":"Your First DECAPODE","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin with the most basic DECAPODE, one which only includes a single variable. In the DECAPODE graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since the DECAPODE applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0{X} will be the 0-dimensional data points on the space X, or in a discrete context, the values defined on points of a mesh X. Similarly, Form1{X} will be values stored on edges of the mesh, and Form2{X} will be values stored on the surfaces of the mesh. Below, we provide a very simple DECAPODE with just a single variable C. In this example, we also provide the necessary imports, and define a convenience function for visualization in later examples.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes, Decapodes.Diagrams\nusing Catlab.Present, Catlab.Graphics\n\nVariable = @decapode Decapodes2D begin\n  C::Form0{X}\nend;\n\ndraw_equation(decapode) = to_graphviz(decapode, node_labels=true, prog=\"neato\",\n  node_attrs=Dict(:shape=>\"oval\"),\n  graph_attrs=Dict(:nodesep=>\"4.0\"))\n\ndraw_equation(Variable)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting diagram contains a single node, showing the single variable in this system. We can then add a second variable:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"TwoVariables = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\nend;\n\ndraw_equation(TwoVariables)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"And then can add some relationship between them. In this case, we make an equation which states that dC is the discrete derivative of C:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Equation = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\n\n  dC == d₀{X}(C)\nend;\n\ndraw_equation(Equation)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the discrete derivative.","category":"page"},{"location":"overview/#A-Little-More-Complicated","page":"Overview","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration. One issue that we run into here, though, is that there isn't a \"proportionality\" operator in the default DECAPODEs syntax Decapodes2D. Thus, in this next example, we will first extend the Decapodes2D syntax and then define the DECAPODE for diffusion.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@present DiffusionQuantities <: Decapodes2D begin\n  k::Hom(Form1(X), Form1(X))    # diffusivity (usually scalar multiplication)\nend;\n\nDiffusion = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend;\n\ndraw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The resulting DECAPODE shows the relationships between the three variables with the triangle diagram. Note that automatic layout of these labels can result in confusion as to which edge each label corresponds, but any confusion can be resolved by referring back to the original @decapode definition.","category":"page"},{"location":"overview/#Bring-in-the-Dynamics","page":"Overview","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using DifferentialEquatons.jl for the actual computation).","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin this process by importing a mesh. The mesh has been pre-generated within CombinatorialSpaces, and is generated such that it has periodic boundary conditions. We will also upload a non-periodic mesh for the sake of visualization, as well as a mapping between the points on the periodic and non-periodic meshes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\nusing JSON\nusing HTTP: get\n\nperiodic_mesh = parse_json_acset(EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}},\n                                 String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/periodic_mesh.json\").body))\nplot_mesh = parse_json_acset(EmbeddedDeltaSet2D{Bool, Point3{Float64}},\n                                 String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/plot_mesh.json\").body))\npoint_map = JSON.parse(String(get(\"https://raw.githubusercontent.com/AlgebraicJulia/Decapodes.jl/main/docs/assets/meshes/point_map.json\").body))\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With the mesh uploaded, we also need to convert the DECAPODE into something which can be scheduled as an explicit time step. In order to do this, we take every variable which is the time derivative of another variable and trace back the operations needed to compute this. This process generates a computation graph in the form of a directed wiring diagram, as shown below.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes.Schedules\n\nexplicit_ts = diag2dwd(Diffusion)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"As can be seen, diffusion has a very simple explicit time step. With this diagram defined, we just need to define a function which implements each of these symbolic operators and pass them to a scheduler for generating the function. The basic DEC operators can be computed with the sym2func operator, and more complex or custom functions (like the proportionality constant k) can be defined manually. We choose to also define the hodge star (⋆₁) on primal 1-forms manually, as this mesh allows for a diagonal hodge star which is significantly more efficient for computation.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using LinearAlgebra\nusing Decapodes.Examples, Decapodes.Simulations\n\nfuncs = sym2func(periodic_mesh)\n\nfuncs[:k] = Dict(:operator => 0.05 * I(ne(periodic_mesh)), :type => MatrixFunc())\nfuncs[:⋆₁] = Dict(:operator => ⋆(Val{1}, periodic_mesh, hodge=DiagonalHodge()),\n                  :type => MatrixFunc());","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we generate the simulation function using gen_sim and set up our initial conditions for this problem.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"func, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false);\n\nusing Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in periodic_mesh[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[point_map])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Finally, we solve this PDE problem using the Tsit5() solver and generate an animation of the result!","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using OrdinaryDiffEq\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diffusion.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"overview/#Merging-Multiple-Physics","page":"Overview","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Diffusion = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\nend\n\nAdvection = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  (V, ϕ)::Form1{X}\n  ϕ == ∧₀₁{X}(C,V)\nend\n\nSuperposition = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  (ϕ, ϕ₁, ϕ₂)::Form1{X}\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Advection)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"draw_equation(Superposition)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Catlab.Programs\n\ncompose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable,\n            graph_attrs=Dict(:start => \"2\"))\n","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"After this, the physics can be composed as follows:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Decapodes.OpenDiagrams\nDiffusionAdvection = oapply(compose_diff_adv,\n                  [OpenDiagram(Diffusion, [:C, :ϕ]),\n                   OpenDiagram(Advection, [:C, :ϕ, :V]),\n                   OpenDiagram(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\n\ndraw_equation(DiffusionAdvection.functor)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Similar to before, this physics can be converted to a directed wiring diagram, compiled, and executed. Note that this process now requires another value to be defined, namely the velocity vector field. We do this using a custom operator called flat_op. This operator is basically the flat operator from CombinatorialSpaces.jl, but specialized to account for the periodic mesh.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"function closest_point(p1, p2, dims)\n    p_res = collect(p2)\n    for i in 1:length(dims)\n        if dims[i] != Inf\n            p = p1[i] - p2[i]\n            f, n = modf(p / dims[i])\n            p_res[i] += dims[i] * n\n            if abs(f) > 0.5\n                p_res[i] += sign(f) * dims[i]\n            end\n        end\n    end\n    Point3{Float64}(p_res...)\nend\n\nfunction flat_op(s::AbstractDeltaDualComplex2D, X::AbstractVector; dims=[Inf, Inf, Inf])\n  # XXX: Creating this lookup table shouldn't be necessary. Of course, we could\n  # index `tri_center` but that shouldn't be necessary either. Rather, we should\n  # loop over incident triangles instead of the elementary duals, which just\n  # happens to be inconvenient.\n  tri_map = Dict{Int,Int}(triangle_center(s,t) => t for t in triangles(s))\n\n  map(edges(s)) do e\n    p = closest_point(point(s, tgt(s,e)), point(s, src(s,e)), dims)\n    e_vec = (point(s, tgt(s,e)) - p) * sign(1,s,e)\n    dual_edges = elementary_duals(1,s,e)\n    dual_lengths = dual_volume(1, s, dual_edges)\n    mapreduce(+, dual_edges, dual_lengths) do dual_e, dual_length\n      X_vec = X[tri_map[s[dual_e, :D_∂v0]]]\n      dual_length * dot(X_vec, e_vec)\n    end / sum(dual_lengths)\n  end\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"explicit_ts = diag2dwd(DiffusionAdvection.functor)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nfuncs[:∧₀₁] = Dict(:operator => (r, c,v)->r .= ∧(Tuple{0,1}, periodic_mesh, c, v), :type => InPlaceFunc())\n\nfunc, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false, params = [:V]);\n\nvelocity(p) = [-0.5, -0.5, 0.0]\nv = flat_op(periodic_mesh, DualVectorField(velocity.(periodic_mesh[triangle_center(periodic_mesh),:dual_point])); dims=[30, 10, Inf])\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5(), p=v);\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: ) ```","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes are a graphical tool for the composition of physical systems. Ultimately, this library will include tooling which takes advantage of the formalization of physical theories described by DEC provided by CombinatorialSpaces.jl.","category":"page"},{"location":"#NOTE","page":"Decapodes.jl","title":"NOTE","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"This library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"}]
}
