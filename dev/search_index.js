var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Diagrams","page":"Library Reference","title":"Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Diagrams ]\nPrivate = false","category":"page"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams","text":"Diagrams in a category and their morphisms.\n\n\n\n\n\n","category":"module"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.Diagram","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.Diagram","text":"Diagram in a category.\n\nRecall that a diagram in a category C is a functor D J  C, where for us the shape category J is finitely presented. Although such a diagram is captured perfectly well by a FinDomFunctor, there are several different notions of morphism between diagrams. The first type parameter T in this wrapper type distinguishes which diagram category the diagram belongs to. See DiagramHom for more about the possible choices. The parameter T may also be Any to indicate that no choice has (yet) been made.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.DiagramHom","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.DiagramHom","text":"Morphism of diagrams in a category.\n\nIn fact, this type encompasses several different kinds of morphisms from a diagram D J  C to another diagram D J  C:\n\nDiagramHom{id}: a functor F J  J together with a natural transformation ϕ D  FD\nDiagramHom{op}: a functor F J  J together with a natural transformation ϕ FD  D\nDiagramHom{co}: a functor F J  J together with a natural transformation ϕ FD  D.\n\nNote that Diagram{op} is not the opposite category of Diagram{id}, but Diagram{op} and Diagram{co} are opposites of each other. Explicit support is included for both because they are useful for different purposes: morphisms of type DiagramHom{id} and DiagramHom{op} induce morphisms between colimits and between limits of the diagrams, respectively, whereas morphisms of type DiagramHom{co} generalize morphisms of polynomial functors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.QueryDiagram","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.QueryDiagram","text":"Diagram representing a (conjunctive or gluing) query.\n\nBesides the diagram functor itself, a query diagram contains a dictionary of query parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.SimpleDiagram","text":"Default concrete type for diagram in a category.\n\n\n\n\n\n","category":"type"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.diagram-Tuple{Diagram}","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.diagram","text":"Functor underlying a diagram object.\n\n\n\n\n\n","category":"method"},{"location":"api/#Catlab.CategoricalAlgebra.Diagrams.shape-Tuple{Diagram}","page":"Library Reference","title":"Catlab.CategoricalAlgebra.Diagrams.shape","text":"The shape or indexing category of a diagram.\n\nThis is the domain of the underlying functor.\n\n\n\n\n\n","category":"method"},{"location":"api/#Open-Diagrams","page":"Library Reference","title":"Open Diagrams","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.OpenDiagrams ]\nPrivate = false","category":"page"},{"location":"api/#Simulation","page":"Library Reference","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Simulations ]\nPrivate = false","category":"page"},{"location":"api/#Schedules","page":"Library Reference","title":"Schedules","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Schedules ]\nPrivate = false","category":"page"},{"location":"api/#Examples","page":"Library Reference","title":"Examples","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.Examples ]\nPrivate = false","category":"page"},{"location":"api/#PetriNets","page":"Library Reference","title":"PetriNets","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [ Decapodes.PetriNets]\nPrivate = false","category":"page"},{"location":"bc_debug/#Simulation-Setup","page":"Simulation Setup","title":"Simulation Setup","text":"","category":"section"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"This tutorial showcases some of the other features included in the Decapodes.jl package. Currently, these features are the treatment of boundary conditions and the simulation debugger interface. To begin, we set up the same advection-diffusion problem presented in the Overview section. As before, we define the Diffusion, Advection, and Superposition components, and now include a BC (Bounday Condition) component. Decapodes.jl interprets any Hom which begins with a ∂ as a boundary condition. These boundary conditions recieve special treatment at the scheduling step. Below we show the graphical rendering of this boundary condition diagram, which we will use to impose a Dirichlet condition on the time derivative of concentration at the mesh boundary.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using Decapodes, Decapodes.Diagrams, Decapodes.OpenDiagrams\nusing Catlab.Present, Catlab.Graphics, Catlab.Programs\n\n@present DiffusionQuantities <: Decapodes2D begin\n  k::Hom(Form1(X), Form1(X))    # diffusivity (usually scalar multiplication)\n  ∂C::Hom(Form0(X), Form0(X))   # concentration boundary condition\nend;\n\nDiffusion = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\nend\n\nAdvection = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  (V, ϕ)::Form1{X}\n  ϕ == ∧₀₁{X}(C,V)\nend\n\nSuperposition = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  (ϕ, ϕ₁, ϕ₂)::Form1{X}\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend\n\nBoundaryConditions = @decapode DiffusionQuantities begin\n  (Ċ, Ċ_bound)::Form0{X}\n  ∂C(Ċ) == Ċ_bound\nend\n\ndraw_diagram(BoundaryConditions)","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"As before, we compose these physics components over our wiring diagram.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"compose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  bc(Ċ)\n  superposition(ϕ₁, ϕ₂, ϕ, Ċ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable,\n            graph_attrs=Dict(:start => \"2\"))","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"DiffusionAdvection = oapply(compose_diff_adv,\n                  [OpenDiagram(Diffusion, [:C, :ϕ]),\n                   OpenDiagram(Advection, [:C, :ϕ, :V]),\n                   OpenDiagram(BoundaryConditions, [:Ċ]),\n                   OpenDiagram(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :Ċ, :C])])\n\ndraw_diagram(DiffusionAdvection.functor)","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"When this is scheduled, Decapodes will apply any boundary conditions immediately after the impacted value is computed. This implementation choice ensures that this boundary condition holds true for any variables dependent on this variable, though also means that the boundary conditions on a variable have no immediate impact on the variables this variable is dependent on.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Below, we see the generated schedule, which shows that the final operation executed on the data is the boundary condition we are enforcing on the change in concentration.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using Decapodes.Schedules\n\nexplicit_ts = diag2dwd(DiffusionAdvection.functor)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Next we import the mesh we will use. In this case, we are wanting to impose boundary conditions and so we will use the plot_mesh from the previous example instead of the mesh with periodic boundary conditions. Because the mesh is only a primal mesh, we also generate and subdivide the dual mesh.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\n\n# Generate the dual mesh\nplot_mesh_dual = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3{Float64}}(plot_mesh)\n# Calculate distances and subdivisions for the dual mesh\nsubdivide_duals!(plot_mesh_dual, Circumcenter())\n\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Finally, we define our operators, generate the simulation function, and compute the simulation. Note that when we define the boudary condition operator, we hardcode the boundary indices and values into the operator itself. We also move the initial concentration to the left, so that we are able to see a constant concentration on the left boundary which will act as a source in the flow. The modified initial condition is shown below:","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using LinearAlgebra\nusing Decapodes.Examples, Decapodes.Simulations\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\n\nfuncs = sym2func(plot_mesh_dual)\n\nfuncs[:k] = Dict(:operator => 0.05 * I(ne(plot_mesh_dual)), :type => MatrixFunc())\nfuncs[:⋆₁] = Dict(:operator => ⋆(Val{1}, plot_mesh_dual, hodge=DiagonalHodge()),\n                  :type => MatrixFunc());\nfuncs[:∧₀₁] = Dict(:operator => (r, c,v)->r .= ∧(Tuple{0,1}, plot_mesh_dual, c, v), :type => InPlaceFunc())\n\nboundary = Examples.boundary_inds(Val{0}, plot_mesh)\nfuncs[:∂C] = Dict(:operator => (∂ċ, ċ)->(∂ċ .= ċ; ∂ċ[boundary] .= 0), :type => InPlaceFunc())\n\n\nusing Distributions\nc_dist = MvNormal([1, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in plot_mesh_dual[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[1:nv(plot_mesh)])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"And the simulation result is then computed and visualized below.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using OrdinaryDiffEq\nfunc, code = gen_sim(explicit_ts, funcs, plot_mesh_dual; autodiff=false, params = [:V]);\n\nvelocity(p) = [-0.5, 0.0, 0.0]\nv = ♭(plot_mesh_dual, DualVectorField(velocity.(plot_mesh_dual[triangle_center(plot_mesh_dual),:dual_point]))).data\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5(), p=v);\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[1:nv(plot_mesh)] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv_right.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[1:nv(plot_mesh)]\nend","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"(Image: )","category":"page"},{"location":"bc_debug/#Debug-the-Simulation","page":"Simulation Setup","title":"Debug the Simulation","text":"","category":"section"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"The benefit of having the computation graph which we generated above means that we have the opportunity to inspect the simulation at different stages of computation. Since each wire in the computation diagram has the data of a particular form on the mesh, this data can be visualized. The first step of getting at this data, though, is understanding the index associated with each wire. This key between indices and wires can be generated with the sim_key function.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"using Decapodes.Debug\n\nsim_key(explicit_ts)","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Another key piece of data is what the initial state is at the time-step you are debugging. We choose the time step t = 10 for this example, shown below.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"t = 10.0\nfig, ax, ob = mesh(plot_mesh; color=sol(t)[1:nv(plot_mesh_dual)])\nxlims!(ax, (0,10.0))\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Now we can see what the value is of the result of the product between velocity and the concentration.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 2;p = v, xlim=(0, 10.0), ylim=(0.0,10.0))\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Now, this information doesn't seem all that useful at first glance. The result is basically a heatmap of the magnitude of the vector field across each edge of the mesh. Here, we see that this product has a greater magnitude on edges that are both aligned with the flow and have a high concentraiton at that point.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Something which is a little more useful is to includ arrows! By using the use_arrows keyword argument, we are able to get arrows, directed along the mesh edge elements, which show the direction of the vectorfield at that point. The color of these arrows shows the magnitude of the vectorfield in that direction. Note that this method of plotting arrows with CairoMakie is fairly computationally expensive, so as the n_arrows argument increases, so will the time it takes to render.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 2;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Note that all of the arrows from the result of the product are pointing in the direction of flow. This intuitively makes sense for how the concentration flow vectorfield should look.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Below, we show the concentration flow resulting just from the gradient.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 7;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Here, we see that the arrows are pointing away from areas of high concentration to areas of low concentration, and that the magnitude of the arrows grows greater as the slope of concentration is greater.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Next, we can show what happens after the effects of diffusion and advection are added together.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"fig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 4;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Finally, in order to compute the change of concentration, we visualize what the resulting change in concentration is.","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"\nfig, ax, ob = draw_wire(plot_mesh, plot_mesh_dual, explicit_ts, func, sol(10.0), 3;p = v, xlim=(0, 10.0), ylim=(0.0,10.0), use_arrows=true, n_arrows=1200)\nfig","category":"page"},{"location":"bc_debug/","page":"Simulation Setup","title":"Simulation Setup","text":"Here, we can see the positive change which is weighted heavily to the right of the existing distribution, and the slight negative change which follows from where the distribution is flowing.","category":"page"},{"location":"overview/#Introduction-to-DECAPODEs","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"","category":"section"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Discrete Exterior Calculus Applied to Partial and Ordinary Differential Equations (DECAPODE) is a diagrammatic language used to express systems of ordinary and partial differential equations. The DECAPODE provides a visual framework for understanding the coupling between variables within a PDE or ODE system, and a combinatorial data structure for working with them. Below, we provide a high-level overview of how DECAPODEs can be generated and interpreted.","category":"page"},{"location":"overview/#Your-First-DECAPODE","page":"Introduction to DECAPODEs","title":"Your First DECAPODE","text":"","category":"section"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"We begin with the most basic DECAPODE, one which only includes a single variable. In the DECAPODE graphical paradigm, nodes represent variables and arrows represent operators which relate variables to each other. Since the DECAPODE applies this diagrammatic language specifically to the Discrete Exterior Calculus (DEC), variables are typed by the dimension and orientation of the information they contain. So a variable of type Form0{X} will be the 0-dimensional data points on the space X, or in a discrete context, the values defined on points of a mesh X. Similarly, Form1{X} will be values stored on edges of the mesh, and Form2{X} will be values stored on the surfaces of the mesh. Below, we provide a very simple DECAPODE with just a single variable C. In this example, we also provide the necessary imports, and define a convenience function for visualization in later examples.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using Decapodes, Decapodes.Diagrams\nusing Catlab.Present, Catlab.Graphics\n\nVariable = @decapode Decapodes2D begin\n  C::Form0{X}\nend;\n\ndraw_equation(decapode) = to_graphviz(decapode, node_labels=true, prog=\"neato\",\n  node_attrs=Dict(:shape=>\"oval\"),\n  graph_attrs=Dict(:nodesep=>\"4.0\"))\n\ndraw_equation(Variable)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"The resulting diagram contains a single node, showing the single variable in this system. We can then add a second variable:","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"TwoVariables = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\nend;\n\ndraw_equation(TwoVariables)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"And then can add some relationship between them. In this case, we make an equation which states that dC is the discrete derivative of C:","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Equation = @decapode Decapodes2D begin\n  C::Form0{X}\n  dC::Form1{X}\n\n  dC == d₀{X}(C)\nend;\n\ndraw_equation(Equation)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Here, the two nodes represent the two variables, and the arrow between them shows how they are related by the discrete derivative.","category":"page"},{"location":"overview/#A-Little-More-Complicated","page":"Introduction to DECAPODEs","title":"A Little More Complicated","text":"","category":"section"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Now that we've seen how to construct a simple equation, it's time to move on to some actual PDE systems! One classic PDE example is the diffusion equation. This equation states that the change of concentration at each point is proportional to the Laplacian of the concentration. One issue that we run into here, though, is that there isn't a \"proportionality\" operator in the default DECAPODEs syntax Decapodes2D. Thus, in this next example, we will first extend the Decapodes2D syntax and then define the DECAPODE for diffusion.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"@present DiffusionQuantities <: Decapodes2D begin\n  k::Hom(Form1(X), Form1(X))    # diffusivity (usually scalar multiplication)\nend;\n\nDiffusion = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\n  # Diffusion equation\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend;\n\ndraw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"The resulting DECAPODE shows the relationships between the three variables with the triangle diagram. Note that automatic layout of these labels can result in confusion as to which edge each label corresponds, but any confusion can be resolved by referring back to the original @decapode definition.","category":"page"},{"location":"overview/#Bring-in-the-Dynamics","page":"Introduction to DECAPODEs","title":"Bring in the Dynamics","text":"","category":"section"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Now that we have a reasonably complex PDE, we can demonstrate some of the developed tooling for actually solving the PDE. Currently, the tooling will automatically generate an explicit method for solving the system (using DifferentialEquatons.jl for the actual computation).","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"We begin this process by importing a mesh. The mesh has been pre-generated within CombinatorialSpaces, and is generated such that it has periodic boundary conditions. We will also upload a non-periodic mesh for the sake of visualization, as well as a mapping between the points on the periodic and non-periodic meshes.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using Catlab.CategoricalAlgebra\nusing CombinatorialSpaces, CombinatorialSpaces.DiscreteExteriorCalculus\nusing CairoMakie\n\nplot_mesh = loadmesh(Rectangle_30x10())\nperiodic_mesh = loadmesh(Torus_30x10())\npoint_map = loadmesh(Point_Map())\n\nfig, ax, ob = wireframe(plot_mesh)\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"With the mesh uploaded, we also need to convert the DECAPODE into something which can be scheduled as an explicit time step. In order to do this, we take every variable which is the time derivative of another variable and trace back the operations needed to compute this. This process generates a computation graph in the form of a directed wiring diagram, as shown below.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using Decapodes.Schedules\n\nexplicit_ts = diag2dwd(Diffusion)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"As can be seen, diffusion has a very simple explicit time step. With this diagram defined, we just need to define a function which implements each of these symbolic operators and pass them to a scheduler for generating the function. The basic DEC operators can be computed with the sym2func operator, and more complex or custom functions (like the proportionality constant k) can be defined manually. We choose to also define the hodge star (⋆₁) on primal 1-forms manually, as this mesh allows for a diagonal hodge star which is significantly more efficient for computation.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using LinearAlgebra\nusing Decapodes.Examples, Decapodes.Simulations\n\nfuncs = sym2func(periodic_mesh)\n\nfuncs[:k] = Dict(:operator => 0.05 * I(ne(periodic_mesh)), :type => MatrixFunc())\nfuncs[:⋆₁] = Dict(:operator => ⋆(Val{1}, periodic_mesh, hodge=DiagonalHodge()),\n                  :type => MatrixFunc());","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Next, we generate the simulation function using gen_sim and set up our initial conditions for this problem.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"func, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false);\n\nusing Distributions\nc_dist = MvNormal([7, 5], [1.5, 1.5])\nc = [pdf(c_dist, [p[1], p[2]]) for p in periodic_mesh[:point]]\n\nfig, ax, ob = mesh(plot_mesh; color=c[point_map])\nax.aspect = AxisAspect(3.0)\nfig","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Finally, we solve this PDE problem using the Tsit5() solver and generate an animation of the result!","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using OrdinaryDiffEq\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5());\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diffusion.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"(Image: )","category":"page"},{"location":"overview/#Merging-Multiple-Physics","page":"Introduction to DECAPODEs","title":"Merging Multiple Physics","text":"","category":"section"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Now that we've seen the basic pipeline, it's time for a more complex example that demonstrates some of the benefits reaped from using Catlab.jl as the backend to our data structures. In this example, we will take two separate physics (diffusion and advection), and combine them together using a higher-level composition pattern.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"We begin by defining the three systems we need. The first two systems are the relationships between concentration and flux under diffusion and advection respectively. The third is the relationship between the two fluxes and the change of concentration under superposition of fluxes.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Diffusion = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  ϕ::Form1{X}\n\n  # Fick's first law\n  ϕ ==  k(d₀{X}(C))\nend\n\nAdvection = @decapode DiffusionQuantities begin\n  C::Form0{X}\n  (V, ϕ)::Form1{X}\n  ϕ == ∧₀₁{X}(C,V)\nend\n\nSuperposition = @decapode DiffusionQuantities begin\n  (C, Ċ)::Form0{X}\n  (ϕ, ϕ₁, ϕ₂)::Form1{X}\n\n  ϕ == ϕ₁ + ϕ₂\n  Ċ == ⋆₀⁻¹{X}(dual_d₁{X}(⋆₁{X}(ϕ)))\n  ∂ₜ{Form0{X}}(C) == Ċ\nend","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"draw_equation(Diffusion)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"draw_equation(Advection)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"draw_equation(Superposition)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Next, we define the pattern of composition which we want to compose these physics under. This pattern of composition is described by an undirected wiring diagram, which has the individual physics as nodes and the shared variables as the small junctions.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using Catlab.Programs\n\ncompose_diff_adv = @relation (C, V) begin\n  diffusion(C, ϕ₁)\n  advection(C, ϕ₂, V)\n  superposition(ϕ₁, ϕ₂, ϕ, C)\nend\n\nto_graphviz(compose_diff_adv, box_labels=:name, junction_labels=:variable,\n            graph_attrs=Dict(:start => \"2\"))\n","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"After this, the physics can be composed as follows:","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using Decapodes.OpenDiagrams\nDiffusionAdvection = oapply(compose_diff_adv,\n                  [OpenDiagram(Diffusion, [:C, :ϕ]),\n                   OpenDiagram(Advection, [:C, :ϕ, :V]),\n                   OpenDiagram(Superposition, [:ϕ₁, :ϕ₂, :ϕ, :C])])\n\ndraw_equation(DiffusionAdvection.functor)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"Similar to before, this physics can be converted to a directed wiring diagram, compiled, and executed. Note that this process now requires another value to be defined, namely the velocity vector field. We do this using a custom operator called flat_op. This operator is basically the flat operator from CombinatorialSpaces.jl, but specialized to account for the periodic mesh.","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"function closest_point(p1, p2, dims)\n    p_res = collect(p2)\n    for i in 1:length(dims)\n        if dims[i] != Inf\n            p = p1[i] - p2[i]\n            f, n = modf(p / dims[i])\n            p_res[i] += dims[i] * n\n            if abs(f) > 0.5\n                p_res[i] += sign(f) * dims[i]\n            end\n        end\n    end\n    Point3{Float64}(p_res...)\nend\n\nfunction flat_op(s::AbstractDeltaDualComplex2D, X::AbstractVector; dims=[Inf, Inf, Inf])\n  # XXX: Creating this lookup table shouldn't be necessary. Of course, we could\n  # index `tri_center` but that shouldn't be necessary either. Rather, we should\n  # loop over incident triangles instead of the elementary duals, which just\n  # happens to be inconvenient.\n  tri_map = Dict{Int,Int}(triangle_center(s,t) => t for t in triangles(s))\n\n  map(edges(s)) do e\n    p = closest_point(point(s, tgt(s,e)), point(s, src(s,e)), dims)\n    e_vec = (point(s, tgt(s,e)) - p) * sign(1,s,e)\n    dual_edges = elementary_duals(1,s,e)\n    dual_lengths = dual_volume(1, s, dual_edges)\n    mapreduce(+, dual_edges, dual_lengths) do dual_e, dual_length\n      X_vec = X[tri_map[s[dual_e, :D_∂v0]]]\n      dual_length * dot(X_vec, e_vec)\n    end / sum(dual_lengths)\n  end\nend","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"explicit_ts = diag2dwd(DiffusionAdvection.functor)\nto_graphviz(explicit_ts, orientation=LeftToRight)","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"using CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nfuncs[:∧₀₁] = Dict(:operator => (r, c,v)->r .= ∧(Tuple{0,1}, periodic_mesh, c, v), :type => InPlaceFunc())\n\nfunc, code = gen_sim(explicit_ts, funcs, periodic_mesh; autodiff=false, params = [:V]);\n\nvelocity(p) = [-0.5, -0.5, 0.0]\nv = flat_op(periodic_mesh, DualVectorField(velocity.(periodic_mesh[triangle_center(periodic_mesh),:dual_point])); dims=[30, 10, Inf])\n\nprob = ODEProblem(func, c, (0.0, 100.0))\nsol = solve(prob, Tsit5(), p=v);\n\n# Plot the result\ntimes = range(0.0, 100.0, length=150)\ncolors = [sol(t)[point_map] for t in times]\n\n# Initial frame\nfig, ax, ob = mesh(plot_mesh, color=colors[1], colorrange = extrema(vcat(colors...)))\nax.aspect = AxisAspect(3.0)\nColorbar(fig[1,2], ob)\nframerate = 30\n\n# Animation\nrecord(fig, \"diff_adv.gif\", range(0.0, 100.0; length=150); framerate = 30) do t\nob.color = sol(t)[point_map]\nend","category":"page"},{"location":"overview/","page":"Introduction to DECAPODEs","title":"Introduction to DECAPODEs","text":"(Image: ) ```","category":"page"},{"location":"ice_dynamics/#Halfar's-model-of-glacial-flow","page":"Glacial Flow","title":"Halfar's model of glacial flow","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's model glacial flow using a model of how ice height of a glacial sheet changes over time, from P. Halfar's 1981 paper: \"On the dynamics of the ice sheets\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# AlgebraicJulia Dependencies\nusing Catlab\nusing Catlab.Graphics\nusing CombinatorialSpaces\nusing Decapodes\n\n# External Dependencies\nusing MLStyle\nusing MultiScaleArrays\nusing LinearAlgebra\nusing OrdinaryDiffEq\nusing JLD2\nusing SparseArrays\nusing Statistics\nusing GLMakie\nusing GeometryBasics: Point2\nPoint2D = Point2{Float64};","category":"page"},{"location":"ice_dynamics/#Defining-the-models","page":"Glacial Flow","title":"Defining the models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first step is to find a suitable equation for our model, and translate it into the Discrete Exterior Calculus. The Exterior Calculus is a generalization of vector calculus, so for low-dimensional spaces, this translation is straightforward. For example, divergence is typically written as (⋆, d, ⋆). Scalar fields are typically interpreted as \"0Forms\", i.e. values assigned to vertices of a mesh.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We use the @decapode macro to interpret the equations. Here, we have equation 2 from Halfar:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fracpartial hpartial t = frac2n + 2 (fracrho gA)^n fracpartialpartial x(fracpartial hpartial x fracpartial hpartial x ^n-1 h^n+2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll change the term out front to Γ so we can demonstrate composition in a moment.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"halfar_eq2 = @decapode begin\n  h::Form0\n  Γ::Form1\n  n::Constant\n\n  ḣ == ∂ₜ(h)\n  ḣ == ∘(⋆, d, ⋆)(Γ * d(h) * avg₀₁(mag(♯(d(h)))^(n-1)) * avg₀₁(h^(n+2)))\nend\n\nto_graphviz(halfar_eq2)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"And here, a formulation of Glen's law from J.W. Glen's 1958 \"The flow law of ice\".","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"glens_law = @decapode begin\n  #Γ::Form0\n  Γ::Form1\n  (A,ρ,g,n)::Constant\n  \n  Γ == (2/(n+2))*A*(ρ*g)^n\nend\n\nto_graphviz(glens_law)","category":"page"},{"location":"ice_dynamics/#Composing-models","page":"Glacial Flow","title":"Composing models","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can use operadic composition to specify how our models come together. In this example, we have two Decapodes, and two quantities that are shared between them.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_composition_diagram = @relation () begin\n  dynamics(n,Γ)\n  stress(Γ,n)\nend\n\nto_graphviz(ice_dynamics_composition_diagram, box_labels=:name, junction_labels=:variable, prog=\"circo\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To a apply a composition, we specify which Decapodes to plug into those boxes, and what each calls the corresponding shared variables internally.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics_cospan = oapply(ice_dynamics_composition_diagram,\n  [Open(halfar_eq2, [:h,:Γ,:n]),\n  Open(glens_law, [:Γ,:n])])\n\nice_dynamics = apex(ice_dynamics_cospan)\nto_graphviz(ice_dynamics)","category":"page"},{"location":"ice_dynamics/#Provide-a-semantics","page":"Glacial Flow","title":"Provide a semantics","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"To interpret our composed Decapode, we need to specify what Discrete Exterior Calculus to interpret our quantities in. Let's choose the 1D Discrete Exterior Calculus:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics1D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics1D, op1_inf_rules_1D, op2_inf_rules_1D)\nresolve_overloads!(ice_dynamics1D, op1_res_rules_1D, op2_res_rules_1D)\n\nto_graphviz(ice_dynamics1D)","category":"page"},{"location":"ice_dynamics/#Define-a-mesh","page":"Glacial Flow","title":"Define a mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We'll need a mesh to simulate on. Since this is a 1D mesh, we can go ahead and make one right now:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# This is a 1D mesh, consisting of edges and vertices.\ns′ = EmbeddedDeltaSet1D{Bool, Point2D}()\n# 20 hundred vertices along a line, connected by edges.\nadd_vertices!(s′, 20, point=Point2D.(range(0, 10_000, length=20), 0))\nadd_edges!(s′, 1:nv(s′)-1, 2:nv(s′))\norient!(s′)\ns = EmbeddedDeltaDualComplex1D{Bool, Float64, Point2D}(s′)\nsubdivide_duals!(s, Circumcenter())","category":"page"},{"location":"ice_dynamics/#Define-input-data","page":"Glacial Flow","title":"Define input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need initial conditions to use for our simulation.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\n# We choose a distribution that obeys the shallow height and shallow slope conditions.\nh₀ = map(point(s′)) do (x,_)\n  ((7072-((x-5000)^2))/9e3+2777)/2777e-1\nend\n\n# Visualize initial conditions for ice sheet height.\nlines(map(x -> x[1], point(s′)), h₀, linewidth=5)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We need to tell our Decapode which data maps to which symbols. We can wrap up our data like so:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-functions","page":"Glacial Flow","title":"Define functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. In the DEC, there are a handful of operators that one uses to construct all the usual vector calculus operations, namely: ♯, ♭, ∧, d, ⋆. The CombinatorialSpaces.jl library specifies many of these for us.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      # This is an implementation of the \"sharp\" operator from the exterior\n      # calculus, which takes co-vector fields to vector fields.\n      # This could be up-streamed to the CombinatorialSpaces.jl library. (i.e.\n      # this operation is not bespoke to this simulation.)\n      e_vecs = map(edges(sd)) do e\n        point(sd, sd[e, :∂v0]) - point(sd, sd[e, :∂v1])\n      end\n      neighbors = map(vertices(sd)) do v\n        union(incident(sd, v, :∂v0), incident(sd, v, :∂v1))\n      end\n      n_vecs = map(neighbors) do es\n        [e_vecs[e] for e in es]\n      end\n      map(neighbors, n_vecs) do es, nvs\n        sum([nv*norm(nv)*x[e] for (e,nv) in zip(es,nvs)]) / sum(norm.(nvs))\n      end\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-the-simulation","page":"Glacial Flow","title":"Generate the simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Now, we have everything we need to generate our simulation:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics1D, dimension=1))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first time that you run a function, Julia will pre-compile it, so that later runs will be fast. We'll solve our simulation for a short time span, to trigger this pre-compilation, and then run it.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")\n\ntₑ = 8e3\n\n# This next run should be fast.\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We can save our solution file in case we want to examine its contents when this Julia session ends.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics1D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's examine the final conditions:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"fig,ax,ob = lines(map(x -> x[1], point(s′)), findnode(soln(tₑ), :h), linewidth=5)\nylims!(ax, extrema(h₀))\ndisplay(fig)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We see that our distribution converges to a more uniform ice height across our domain, which matches our physical intuition.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Let's create a GIF to examine an animation of these dynamics:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Create a gif\nbegin\n  frames = 100\n  fig, ax, ob = lines(map(x -> x[1], point(s′)), findnode(soln(0), :h))\n  ylims!(ax, extrema(h₀))\n  record(fig, \"ice_dynamics1D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    lines!(map(x -> x[1], point(s′)), findnode(soln(t), :h))\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics1D)","category":"page"},{"location":"ice_dynamics/#D-Re-interpretation","page":"Glacial Flow","title":"2D Re-interpretation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"The first, one-dimensional, semantics that we provided to our Decapode restricted the kinds of glacial sheets that we could model. (i.e. We could only look at glacial sheets which were constant along y). We can give our Decapode an alternate semantics, as some physics on a 2-dimensional manifold.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"Note that for these physics, we make no adjustments to the underlying \"dimension-agnostic\" Decapode, we only provide a different set of rules for inferring what the type of each quantity is.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"ice_dynamics2D = expand_operators(ice_dynamics)\ninfer_types!(ice_dynamics2D)\nresolve_overloads!(ice_dynamics2D)\n\nto_graphviz(ice_dynamics2D)","category":"page"},{"location":"ice_dynamics/#Store-as-JSON","page":"Glacial Flow","title":"Store as JSON","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We quickly demonstrate how to serialize a Decapode to JSON and read it back in:","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"write_json_acset(ice_dynamics2D, \"ice_dynamics2D.json\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# When reading back in, we specify that all attributes are \"Symbol\"s.\nice_dynamics2 = read_json_acset(SummationDecapode{Symbol,Symbol,Symbol}, \"ice_dynamics2D.json\")\n# Or, you could choose to interpret the data as \"String\"s.\nice_dynamics3 = read_json_acset(SummationDecapode{String,String,String}, \"ice_dynamics2D.json\")\n\nto_graphviz(ice_dynamics3)","category":"page"},{"location":"ice_dynamics/#Define-our-mesh","page":"Glacial Flow","title":"Define our mesh","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"include(\"../../grid_meshes.jl\")\ns′ = triangulated_grid(10_000,10_000,800,800,Point3D)\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nwireframe(s)","category":"page"},{"location":"ice_dynamics/#Define-our-input-data","page":"Glacial Flow","title":"Define our input data","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y)\n  (7072-((x-5000)^2 + (y-5000)^2)^(1/2))/9e3+10\nend\n\n# Visualize initial condition for ice sheet height.\nmesh(s′, color=h₀, colormap=:jet)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/#Define-our-functions","page":"Glacial Flow","title":"Define our functions","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"function generate(sd, my_symbol; hodge=GeometricHodge())\n  op = @match my_symbol begin\n    :♯ => x -> begin\n      ♯(sd, EForm(x))\n    end\n    :mag => x -> begin\n      norm.(x)\n    end\n    :avg₀₁ => x -> begin\n      I = Vector{Int64}()\n      J = Vector{Int64}()\n      V = Vector{Float64}()\n      for e in 1:ne(s)\n          append!(J, [s[e,:∂v0],s[e,:∂v1]])\n          append!(I, [e,e])\n          append!(V, [0.5, 0.5])\n      end\n      avg_mat = sparse(I,J,V)\n      avg_mat * x\n    end\n    :^ => (x,y) -> x .^ y\n    :* => (x,y) -> x .* y\n    :show => x -> begin\n      @show x\n      @show length(x)\n      x\n    end\n    x => error(\"Unmatched operator $my_symbol\")\n  end\n  return (args...) -> op(args...)\nend","category":"page"},{"location":"ice_dynamics/#Generate-simulation","page":"Glacial Flow","title":"Generate simulation","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/#Pre-compile-and-run-2","page":"Glacial Flow","title":"Pre-compile and run","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@info(\"Precompiling Solver\")\n# We run for a short timespan to pre-compile.\nprob = ODEProblem(fₘ, u₀, (0, 1e-8), constants_and_parameters)\nsoln = solve(prob, Tsit5())\nsoln.retcode != :Unstable || error(\"Solver was not stable\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"tₑ = 5e13\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"@save \"ice_dynamics2D.jld2\" soln","category":"page"},{"location":"ice_dynamics/#Visualize-2","page":"Glacial Flow","title":"Visualize","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# Final conditions:\nmesh(s′, color=findnode(soln(tₑ), :h), colormap=:jet, colorrange=extrema(findnode(soln(0), :h)))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 100\n  fig, ax, ob = GLMakie.mesh(s′, color=findnode(soln(0), :h), colormap=:jet, colorrange=extrema(findnode(soln(0), :h)))\n  Colorbar(fig[1,2], ob)\n  record(fig, \"ice_dynamics2D.gif\", range(0.0, tₑ; length=frames); framerate = 15) do t\n    ob.color = findnode(soln(t), :h)\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2D)","category":"page"},{"location":"ice_dynamics/#Manifold-in-3D","page":"Glacial Flow","title":"2-Manifold in 3D","text":"","category":"section"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"We note that just because our physics is happening on a 2-manifold, (a surface), this doesn't restrict us to the 2D plane. In fact, we can \"embed\" our 2-manifold in 3D space to simulate a glacial sheets spread across the globe.","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"s′ = loadmesh(Icosphere(3, 10_000))\ns = EmbeddedDeltaDualComplex2D{Bool, Float64, Point3D}(s′)\nsubdivide_duals!(s, Barycenter())\nwireframe(s)\n","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"n = 3\nρ = 910\ng = 9.8\nA = 1e-16\n\n# Ice height is a primal 0-form, with values at vertices.\nh₀ = map(point(s′)) do (x,y,z)\n  (z*z)/(10_000*10_000)\nend\n\n# Visualize initial condition for ice sheet height.\n# There is lots of ice at the poles, and no ice at the equator.\nmesh(s′, color=h₀, colormap=:jet)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"u₀ = construct(PhysicsState, [VectorForm(h₀)], Float64[], [:h])\nconstants_and_parameters = (\n  n = n,\n  stress_ρ = ρ,\n  stress_g = g,\n  stress_A = A)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"sim = eval(gensim(ice_dynamics2D, dimension=2))\nfₘ = sim(s, generate)","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"# For brevity's sake, we'll skip the pre-compilation cell.\n\ntₑ = 1e11\n\n@info(\"Solving\")\nprob = ODEProblem(fₘ, u₀, (0, tₑ), constants_and_parameters)\nsoln = solve(prob, Tsit5())\n@show soln.retcode\n@info(\"Done\")\n\n# Compare the extrema of the initial and final conditions of ice height.\nextrema(findnode(soln(0), :h)), extrema(findnode(soln(tₑ), :h))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"mesh(s′, color=findnode(soln(tₑ), :h), colormap=:jet, colorrange=extrema(findnode(soln(0), :h)))","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"begin\n  frames = 200\n  fig, ax, ob = GLMakie.mesh(s′, color=findnode(soln(0), :h), colormap=:jet, colorrange=extrema(findnode(soln(0), :h)))\n  Colorbar(fig[1,2], ob)\n  # These particular initial conditions diffuse quite quickly, so let's just look at\n  # the first moments of those dynamics.\n  record(fig, \"ice_dynamics2D_sphere.gif\", range(0.0, tₑ/64; length=frames); framerate = 20) do t\n    ob.color = findnode(soln(t), :h)\n  end\nend","category":"page"},{"location":"ice_dynamics/","page":"Glacial Flow","title":"Glacial Flow","text":"(Image: IceDynamics2DSphere)","category":"page"},{"location":"#Decapodes.jl","page":"Decapodes.jl","title":"Decapodes.jl","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Decapodes are a graphical tool for the composition of physical systems. Ultimately, this library will include tooling which takes advantage of the formalization of physical theories described by DEC provided by CombinatorialSpaces.jl.","category":"page"},{"location":"#Getting-started","page":"Decapodes.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"Walkthroughs creating, composing, and solving Decapodes are available in the side-bar of this documentation page. Further example scripts are avaiable in the examples folder of the Decapodes.jl GitHub repo, and will be added to this documentation site soon.","category":"page"},{"location":"#NOTE","page":"Decapodes.jl","title":"NOTE","text":"","category":"section"},{"location":"","page":"Decapodes.jl","title":"Decapodes.jl","text":"This library is currently under active development, and so is not yet at a point where a constant API/behavior can be assumed. That being said, if this project looks interesting/relevant please contact us and let us know!","category":"page"},{"location":"poiseuille/#Poissuille-Flow-for-Fluid-Mechanics","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"When modeling a fluid flowing in pipe, one can ignore the multidimensional structure of the pipe and approximate the system as a 1 dimensional flow along the pipe. The noslip boundary condition and the geometry of the pipe enter a 1D equation in the form of a resistance term.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"using CombinatorialSpaces\nusing CombinatorialSpaces.ExteriorCalculus\nimport Catlab.Theories: otimes, oplus, compose, ⊗, ⊕, ⋅, associate, associate_unit, Ob, Hom, dom, codom\nusing CombinatorialSpaces.DiscreteExteriorCalculus: ∧\nusing Catlab.Theories\nusing Catlab.Present\nusing Catlab.Graphics\nusing Catlab.Syntax\nusing Catlab.CategoricalAlgebra\nusing LinearAlgebra\n\nusing Decapodes.Simulations\nusing Decapodes.Examples\nusing Decapodes.Diagrams\nusing Decapodes.Schedules\n\n# Julia community libraries\n\nusing CairoMakie\nusing Decapodes.Debug\nusing OrdinaryDiffEq\n\n\n\"\"\" Decapodes1D\nA schema which includes any homomorphisms that may be added by the @decapode\nmacro.\n\nTODO: This should be chipped away at as more of this tooling takes advantage\nof the Catlab GAT system\n\"\"\"\n\n@present Decapodes1D(FreeExtCalc1D) begin\n  X::Space\n  proj₁_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  proj₂_⁰⁰₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  proj₁_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))\n  proj₂_⁰⁰₀⁺::Hom(Form0(X)⊕Form0(X),Form0(X))\n  proj₁_⁰¹₀::Hom(Form0(X)⊗Form1(X),Form0(X))\n  proj₂_⁰¹₁::Hom(Form0(X)⊗Form1(X),Form1(X))\n  proj₁_⁰¹₀⁺::Hom(Form0(X)⊕Form1(X),Form0(X))\n  proj₂_⁰¹₁⁺::Hom(Form0(X)⊕Form1(X),Form1(X))\n  proj₁_⁰⁰̃₀::Hom(Form0(X)⊗DualForm0(X),Form0(X))\n  proj₂_⁰⁰̃₀̃::Hom(Form0(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_⁰⁰̃₀⁺::Hom(Form0(X)⊕DualForm0(X),Form0(X))\n  proj₂_⁰⁰̃₀̃⁺::Hom(Form0(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_⁰¹̃₀::Hom(Form0(X)⊗DualForm1(X),Form0(X))\n  proj₂_⁰¹̃₁̃::Hom(Form0(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_⁰¹̃₀⁺::Hom(Form0(X)⊕DualForm1(X),Form0(X))\n  proj₂_⁰¹̃₁̃⁺::Hom(Form0(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_¹⁰₁::Hom(Form1(X)⊗Form0(X),Form1(X))\n  proj₂_¹⁰₀::Hom(Form1(X)⊗Form0(X),Form0(X))\n  proj₁_¹⁰₁⁺::Hom(Form1(X)⊕Form0(X),Form1(X))\n  proj₂_¹⁰₀⁺::Hom(Form1(X)⊕Form0(X),Form0(X))\n  proj₁_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  proj₂_¹¹₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  proj₁_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))\n  proj₂_¹¹₁⁺::Hom(Form1(X)⊕Form1(X),Form1(X))\n  proj₁_¹⁰̃₁::Hom(Form1(X)⊗DualForm0(X),Form1(X))\n  proj₂_¹⁰̃₀̃::Hom(Form1(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_¹⁰̃₁⁺::Hom(Form1(X)⊕DualForm0(X),Form1(X))\n  proj₂_¹⁰̃₀̃⁺::Hom(Form1(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_¹¹̃₁::Hom(Form1(X)⊗DualForm1(X),Form1(X))\n  proj₂_¹¹̃₁̃::Hom(Form1(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_¹¹̃₁⁺::Hom(Form1(X)⊕DualForm1(X),Form1(X))\n  proj₂_¹¹̃₁̃⁺::Hom(Form1(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_⁰̃⁰₀̃::Hom(DualForm0(X)⊗Form0(X),DualForm0(X))\n  proj₂_⁰̃⁰₀::Hom(DualForm0(X)⊗Form0(X),Form0(X))\n  proj₁_⁰̃⁰₀̃⁺::Hom(DualForm0(X)⊕Form0(X),DualForm0(X))\n  proj₂_⁰̃⁰₀⁺::Hom(DualForm0(X)⊕Form0(X),Form0(X))\n  proj₁_⁰̃¹₀̃::Hom(DualForm0(X)⊗Form1(X),DualForm0(X))\n  proj₂_⁰̃¹₁::Hom(DualForm0(X)⊗Form1(X),Form1(X))\n  proj₁_⁰̃¹₀̃⁺::Hom(DualForm0(X)⊕Form1(X),DualForm0(X))\n  proj₂_⁰̃¹₁⁺::Hom(DualForm0(X)⊕Form1(X),Form1(X))\n  proj₁_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  proj₂_⁰̃⁰̃₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))\n  proj₂_⁰̃⁰̃₀̃⁺::Hom(DualForm0(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_⁰̃¹̃₀̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm0(X))\n  proj₂_⁰̃¹̃₁̃::Hom(DualForm0(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_⁰̃¹̃₀̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm0(X))\n  proj₂_⁰̃¹̃₁̃⁺::Hom(DualForm0(X)⊕DualForm1(X),DualForm1(X))\n  proj₁_¹̃⁰₁̃::Hom(DualForm1(X)⊗Form0(X),DualForm1(X))\n  proj₂_¹̃⁰₀::Hom(DualForm1(X)⊗Form0(X),Form0(X))\n  proj₁_¹̃⁰₁̃⁺::Hom(DualForm1(X)⊕Form0(X),DualForm1(X))\n  proj₂_¹̃⁰₀⁺::Hom(DualForm1(X)⊕Form0(X),Form0(X))\n  proj₁_¹̃¹₁̃::Hom(DualForm1(X)⊗Form1(X),DualForm1(X))\n  proj₂_¹̃¹₁::Hom(DualForm1(X)⊗Form1(X),Form1(X))\n  proj₁_¹̃¹₁̃⁺::Hom(DualForm1(X)⊕Form1(X),DualForm1(X))\n  proj₂_¹̃¹₁⁺::Hom(DualForm1(X)⊕Form1(X),Form1(X))\n  proj₁_¹̃⁰̃₁̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm1(X))\n  proj₂_¹̃⁰̃₀̃::Hom(DualForm1(X)⊗DualForm0(X),DualForm0(X))\n  proj₁_¹̃⁰̃₁̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm1(X))\n  proj₂_¹̃⁰̃₀̃⁺::Hom(DualForm1(X)⊕DualForm0(X),DualForm0(X))\n  proj₁_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\n  proj₂_¹̃¹̃₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\n  proj₁_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))\n  proj₂_¹̃¹̃₁̃⁺::Hom(DualForm1(X)⊕DualForm1(X),DualForm1(X))\n  sum₀::Hom(Form0(X)⊗Form0(X),Form0(X))\n  sum₁::Hom(Form1(X)⊗Form1(X),Form1(X))\n  sum₀̃::Hom(DualForm0(X)⊗DualForm0(X),DualForm0(X))\n  sum₁̃::Hom(DualForm1(X)⊗DualForm1(X),DualForm1(X))\nend","category":"page"},{"location":"poiseuille/#Creating-the-Poiseuille-Equations","page":"Poissuille Flow for Fluid Mechanics","title":"Creating the Poiseuille Equations","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"The first step is to present an extension of the generic Decapodes1D presentation with specific named linear operators for the viscosity effect and the drag effect. This is purely syntactic, we will add the corresponding matrices later. ","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"The @decapode macro creates the data structure representing the equations of Poiseuille flow. The first block declares variables, the second block defines intermediate terms and the last block is the core equation.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"@present Poiseuille <: Decapodes1D begin\n  (R, μ̃)::Hom(Form1(X), Form1(X))\n  # μ̃ = negative viscosity per unit area\n  # R = drag of pipe boundary\nend;\n\nPoise = @decapode Poiseuille begin\n  (∇P)::Form1{X}\n  (q, q̇, Δq)::Form1{X}\n  P::Form0{X}\n\n  # Laplacian of q for the viscous effect\n  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))\n  # Gradient of P for the pressure driving force\n  ∇P == d₀{X}(P)\n  # definition of time derivative of q\n  ∂ₜ{Form1{X}}(q) == q̇\n\n  # the core equation\n  q̇ == sum₁(sum₁(μ̃(Δq), ∇P),R(q))\nend;","category":"page"},{"location":"poiseuille/#Defining-the-Semantics","page":"Poissuille Flow for Fluid Mechanics","title":"Defining the Semantics","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"In order to solve our equations, we will need numerical linear operators that give meaning to our symbolic operators. The operator funcs code below assigns the necessary matrices as definitions for the symbols. In order to define the viscosity effect correctly we have to identify boundary edges and apply a mask. This is because the DEC has discrete dual cells at the boundaries that need to be handled specially for the viscosity term. We found empirically that if you allow nonzero viscosity at the boundary edges, the flows at the boundaries will be incorrect. ","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"\"\"\"    boundary_edges(ds)\n\nCompute the edges of a 1D simplicial set that are either incident to in-degree 1 or out-degree 1 nodes.\nFor a graph, these are boundary vertices meaning leaf nodes. For our pipeflow problems,\nthese are the edges where material can enter the pipe network.\n\"\"\"\nfunction boundary_edges(ds)\n  out_degree(x) = length(incident(ds, x, :∂v1))\n  in_degree(x) = length(incident(ds, x, :∂v0))\n  bpoints = findall(x -> out_degree(x) == 0 || in_degree(x) == 0, 1:nv(ds))\n  sedges = vcat(incident(ds,bpoints,:∂v0)...)\n  tedges = vcat(incident(ds,bpoints,:∂v1)...)\n  bedges = collect(union(sedges, tedges))\n  return bedges\nend\n\n\"\"\"    mask_boundary_edges(ds)\n\nProvides the `boundary_edges(ds)` as a vector of 0/1 entries to use as a mask.\n\"\"\"\nfunction mask_boundary_edges(ds)\n  D = ones(Int, ne(ds))\n  D[boundary_edges(ds)] .= 0\n  return D\nend\n\n\nopbind(f, T) = Dict(:operator=>f, :type=>T)\n\nfunction create_funcs(ds, hodge=DiagonalHodge())\n  funcs = Dict{Symbol, Dict}()\n  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₁] = opbind(⋆(Val{1}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₀] = opbind(⋆(Val{0}, ds, hodge=hodge), MatrixFunc())\n  funcs[:⋆₀⁻¹] = opbind(inv(⋆(Val{0}, ds, hodge=hodge)), MatrixFunc())\n  funcs[:⋆₁⁻¹] = opbind(inv(⋆(Val{1}, ds, hodge=hodge)), MatrixFunc())\n  funcs[:d₀] = opbind(d(Val{0}, ds), MatrixFunc())\n  funcs[:dual_d₀] = opbind(dual_derivative(Val{0}, ds), MatrixFunc());\n  funcs[:sum₁] = opbind((x′, x, y)->(x′ .= x .+ y), InPlaceFunc())\n  funcs[:∧₀₁] = opbind((r, c, v) -> r .= -∧(Tuple{0,1}, ds, c, v), InPlaceFunc())\n  return funcs\nend\n\n##\nfunction create_funcs(ds, operators, boundaries, hodge=DiagonalHodge())\n  funcs = create_funcs(ds, hodge)\n  merge!(funcs, operators, boundaries)\n  return funcs\nend\n\nfunction operator_funcs(ds)\n  F = Dict(\n    :μ̃ => opbind(0.5 *  Diagonal(mask_boundary_edges(ds)), MatrixFunc()),\n    :R => opbind(-0.1 * I(ne(ds)), MatrixFunc()),\n    :¬ => opbind(-I(ne(ds)), MatrixFunc()),\n    :k => opbind(1.0 * I(nv(ds)), MatrixFunc()))\n  B = Dict(\n    :∂ρ => opbind((ρᵇ, ρ) -> begin ρᵇ .= ρ; ρᵇ[1] = 0; ρᵇ[end] = 0; return ρᵇ end, InPlaceFunc())\n  )\n  create_funcs(ds, F, B)\nend\nform2dim = Dict(:Scalar => x->1,\n                :Form0 => nv,\n                :Form1 => ne,\n                :DualForm1 => nv,\n                :DualForm0 => ne)\n","category":"page"},{"location":"poiseuille/#A-Single-Pipe-Segment","page":"Poissuille Flow for Fluid Mechanics","title":"A Single Pipe Segment","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"We create a mesh with one pipe segment to see if we get the right answer. This simulation can be validated with the Poiseuille equation for a single pipe. First we create the mesh.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Point3D = Point3{Float64}\ns = EmbeddedDeltaSet1D{Bool,Point3D}()\nadd_vertices!(s, 2, point=[Point3D(-1, 0, 0), Point3D(+1, 0, 0)])\nadd_edge!(s, 1, 2, edge_orientation=true)\n\nds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\nsubdivide_duals!(ds, Circumcenter())\nds","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"funcs = operator_funcs(ds)\nfunc, code = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P]);\nprob = ODEProblem(func, [2.], (0.0, 10000.0), [1.,11.])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#A-Linear-Pipe-with-Multiple-Segments","page":"Poissuille Flow for Fluid Mechanics","title":"A Linear Pipe with Multiple Segments","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"We then move on to a linear sequence of pipe segments. You can visualize this as the discretization of a single long pipe into n segments. First we define the mesh:","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\n\nds, func, funcs = linear_pipe(10)\nds","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Then we solve the equation. Notice that the equilibrium flow is constant down the length of the pipe. This must be true because of conservation of mass. The segments are all the same length and the total flow in must equal the total flow out of each segment.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"prob = ODEProblem(func, [5,3,4,2,5,2,8,4,3], (0.0, 10000.0), [10. *i for i in 1:10])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#A-Distribution-Network","page":"Poissuille Flow for Fluid Mechanics","title":"A Distribution Network","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"To model a distribution network such as residential drinking water or natural gas, we will build a binary tree of pipes that at each junction have a bifurcation into two pipes. We expect that the flow will be divided by two at each level of the tree. First we make the mesh.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"function binary_pipe(depth::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertex!(s, point=Point3D(0, 0, 0))\n  for n in 1:depth\n    for prev_v in vertices(s)[end-2^(n-1)+1:end]\n      x, y, _ = s[:point][prev_v]\n      vs = add_vertices!(s, 2, point=[Point3D(sgn*3^0.5 + x, y+1, 0)\n                                 for sgn in [1,-1]])\n      add_edges!(s, vs, [prev_v,prev_v], edge_orientation=true)\n    end\n  end\n  v = add_vertex!(s, point=Point3D(3^0.5, -1, 0))\n  add_edge!(s, 1, v, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\nds, func, funcs = binary_pipe(2);\nds","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Then we solve the equations.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"prob = ODEProblem(func,\n                 [5. for _ in 1:ne(ds)],\n                 (0.0, 10000.0),\n                 Float64[2^(7-p[2]) for p in ds[:point]])\n\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/#Multiphysics","page":"Poissuille Flow for Fluid Mechanics","title":"Multiphysics","text":"","category":"section"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Decapodes really shines when you want to extend or refine your physics. We will change our physics by adding in a term for density of the material and the corresponding changes in pressure. This is not the only formulation for including a dynamic pressure effect into this system. If you can think of a better way to include this effect, we invite you to try it as an exercise!","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Because the pressure is no longer being supplied as a parameter of the system controlled by the operators, we need to introduce a density term and a boundary condition for that density. In this system you can think of forcing a prescribed amount of material per unit time through the openings of the pipe and allowing the flow (q) and the pressure (P) to fluctuate. Before we were enforcing a fixed pressure gradient and and letting the flow fluctuate to achieve equilibrium. In the prior model, we were not accounting for the amount of material that had to flow in order to achieve that (flow, pressure) combination.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"The Decapode can be visualized with graphviz, note that the boundary conditions are explicitly represented in the Decapode as operators that implement a masking operation. This is not consistent with the Diagrammatic Equations in Physics paper [PBHF22]. This approach is more directly tied to the computational method and will eventually be replaced with one based on morphisms of diagrams.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"@present Poiseuille <: Decapodes1D begin\n  (R, μ̃, ¬)::Hom(Form1(X), Form1(X))\n  k::Hom(Form0(X), Form0(X))\n  # μ̃ = negative viscosity per unit area\n  # R = drag of pipe boundary\n  # k = pressure as a function of density\n  # boundary conditions\n  ∂ρ::Hom(Form0(X), Form0(X))\nend;\n\nPoise = @decapode Poiseuille begin\n  (∇P)::Form1{X}\n  (q, q̇, Δq)::Form1{X}\n  (P, ρ, ρ̇)::Form0{X}\n\n  # Poiseuille Flow\n  Δq == d₀{X}(⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(q))))\n  ∂ₜ{Form1{X}}(q) == q̇\n  ∇P == d₀{X}(P)\n  q̇ == sum₁(sum₁(μ̃(Δq), ¬(∇P)),R(q))\n  \n  # Pressure/Density Coupling\n  P == k(ρ)\n  ∂ₜ{Form0{X}}(ρ) == ρ̇\n  ρ̇ == ⋆₀⁻¹{X}(dual_d₀{X}(⋆₁{X}(∧₀₁{X}(ρ,q)))) # advection\n  \n  # Boundary conditions\n  ρᵇ::Form0{X}\n  ∂ρ(ρ̇) == ρᵇ\nend;\n\nto_graphviz(Poise, node_labels=true, prog=\"neato\", node_attrs=Dict(:shape=>\"oval\"))","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Then we can create the mesh and solve the equation.","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"function linear_pipe(n::Int)\n  s = EmbeddedDeltaSet1D{Bool,Point3D}()\n  add_vertices!(s, n, point=[Point3D(i, 0, 0) for i in 1:n])\n  add_edges!(s, 1:n-1, 2:n, edge_orientation=true)\n  orient!(s)\n  ds = EmbeddedDeltaDualComplex1D{Bool,Float64,Point3D}(s)\n  subdivide_duals!(ds, Circumcenter())\n  funcs = operator_funcs(ds)\n  func, _ = gen_sim(diag2dwd(Poise, in_vars=[:q, :ρ]), funcs, ds; autodiff=false, form2dim=form2dim, params=[:P])\n  return ds, func, funcs\nend\n\nds, func, funcs = linear_pipe(10)\n\nprob = ODEProblem(func, [5,3,4,2,5,2,3,4,3, 10,9,8,7,6,5,5,5,5,5], (0.0, 10000.0), [10. *i for i in 1:10])\nsol = solve(prob, Tsit5(); progress=true);\nsol.u","category":"page"},{"location":"poiseuille/","page":"Poissuille Flow for Fluid Mechanics","title":"Poissuille Flow for Fluid Mechanics","text":"Notice that the solution contains both a vector of flows and a vector of pressures.","category":"page"}]
}
